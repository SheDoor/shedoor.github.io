<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"/ media="defer" onload="this.media='all'">
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<meta name="referrer" content="no-referrer" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ocnyang.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一文详尽 Android 通信：四大组件之间 &amp; 进程间 &amp; 线程间 &amp; 多个App间">
<meta property="og:type" content="article">
<meta property="og:title" content="详解 Android 通信">
<meta property="og:url" content="http://ocnyang.com/2017/02/13/AndroidComm/index.html">
<meta property="og:site_name" content="OCNYang の 博客">
<meta property="og:description" content="一文详尽 Android 通信：四大组件之间 &amp; 进程间 &amp; 线程间 &amp; 多个App间">
<meta property="og:locale">
<meta property="og:image" content="http://img.shedoor.net/ocnyang/android_comm/androidcomm.jpg">
<meta property="og:image" content="http://img.shedoor.net/ocnyang/android_comm/%E9%80%9A%E4%BF%A1fragment.jpg">
<meta property="og:image" content="http://img.shedoor.net/ocnyang/android_comm/Fragment%E9%80%9A%E4%BF%A1_gif.gif">
<meta property="og:image" content="http://img.shedoor.net/ocnyang/android_comm/intent-chooser.png">
<meta property="og:image" content="http://img.shedoor.net/ocnyang/android_comm/EventBus-Publish-Subscribe.png">
<meta property="article:published_time" content="2017-02-13T22:03:15.000Z">
<meta property="article:modified_time" content="2021-07-20T01:47:39.591Z">
<meta property="article:author" content="OCNYang">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.shedoor.net/ocnyang/android_comm/androidcomm.jpg">

<link rel="canonical" href="http://ocnyang.com/2017/02/13/AndroidComm/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>详解 Android 通信 | OCNYang の 博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
<script defer src="/live2d-widget/autoload.js"></script>
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">OCNYang の 博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">ʕ•̫͡•ʕ̢·͡˔·ོɁ̡̣-̫͡-ʕ•͓͡•ʔ-̫͡-ʔ</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://ocnyang.com/2017/02/13/AndroidComm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OCNYang">
      <meta itemprop="description" content="前线 Android 开发者，亦涉猎 Flutter。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OCNYang の 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          详解 Android 通信
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-02-13 22:03:15" itemprop="dateCreated datePublished" datetime="2017-02-13T22:03:15+00:00">2017-02-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-20 01:47:39" itemprop="dateModified" datetime="2021-07-20T01:47:39+00:00">2021-07-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Android教程系列</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>18 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>一文详尽 Android 通信：四大组件之间 &amp; 进程间 &amp; 线程间 &amp; 多个App间</p>
</blockquote>
<p><img src="http://img.shedoor.net/ocnyang/android_comm/androidcomm.jpg">  </p>
<span id="more"></span>

<h2 id="本文大纲"><a href="#本文大纲" class="headerlink" title="本文大纲"></a>本文大纲</h2><p><strong>看完本文能收获什么？按目录索引，你可以学习到：</strong></p>
<ol>
<li><p>组件间的通信，Activity，fragment，Service， Provider，Receiver</p>
</li>
<li><p>进程间的通信，AIDL</p>
</li>
<li><p>线程间的通信，Handler，AnsycTask，IntentService</p>
</li>
<li><p>多个App间的通信</p>
</li>
<li><p>使用大型开源框架完成组件通信，EventBus，otto</p>
</li>
</ol>
<p><strong>建议阅读本文时遵循以下学习思路</strong></p>
<ol>
<li><p>研究对象：Activity，fragment等组件</p>
</li>
<li><p>信息存在形式：Intent，Bundle，静态变量，全局变量，还是点击事件，触摸事件的回调监听，或者文件形式（Sharepreference，SQLite，File , NetStream） ，本质就是信息源</p>
</li>
<li><p>信息传递的形式：网路，回调监听，线程，Intent，全局Application</p>
</li>
<li><p>相同形式的思路，不会出现第二次，请读者举一反三</p>
</li>
<li><p>最后强调研究对象是单一的</p>
</li>
</ol>
<h2 id="Activity通信"><a href="#Activity通信" class="headerlink" title="Activity通信"></a>Activity通信</h2><h3 id="Activity-和-Activity"><a href="#Activity-和-Activity" class="headerlink" title="Activity 和 Activity"></a>Activity 和 Activity</h3><p><strong>1. 常规方式：Intent Bundle</strong></p>
<p>通过Intent 启动另一个Activity时，有两种重载方式：</p>
<pre><code>startActivity(new Intent(),new Bundle());
startActivityForResult(new Intent(),FLAG,new Bundle());
</code></pre>
<p>从参数列表就可以总结出来，有Intent，和Bundle,可以传递8种基本数据类型和可序列化的数据类型，比如字符串和字节数组。提到可序列化，就引发 Intent和Bundle 的局限性了:</p>
<ol>
<li>Intent Bundle 无法传递“不可序列化”的数据，比如Bitmap，InputStream，解决办法有很多种，最简单的就是将“不可序列化”的对象，转换成字节数组，这里因为主要是讲解通信，所以不展开讲了。  </li>
<li>Intent Bundle 能传递的数据大小在40K以内 。  </li>
</ol>
<blockquote>
<p>很多人不理解为什么把Intent和Bundle放在一起谈，因为Intent 底层存储信息的原理也是通过Bundle存储！</p>
</blockquote>
<p><strong>2. 公有静态变量</strong></p>
<p>比如 <code>public static String flag=“杨欧神”；</code></p>
<p>使用方式 比如在其他Activity当中 <code>FirstActivity.flag=“OCNYang”;</code> 修改静态变量的值</p>
<p><strong>3. 基于物理形式：</strong></p>
<p>比如 <strong><code>File，SQLite，Sharepreference</code></strong> 物理形式</p>
<p><strong>4. 全局变量：</strong></p>
<p>比如Application：Application是与Activity，Service齐名的组件，非常强大，它的特点是全局组件共用，单例形式存在，在其他组件中，我们只需要 <code>Context.getApplication（）</code> 获得该对象的引用即可</p>
<h3 id="Activity-和-Fragment，Service，BrodcastReceiver"><a href="#Activity-和-Fragment，Service，BrodcastReceiver" class="headerlink" title="Activity 和 Fragment，Service，BrodcastReceiver"></a>Activity 和 Fragment，Service，BrodcastReceiver</h3><p>首先都遵循，如何启动它们，就如何传递信息的原则：</p>
<p><strong>1. Activity与Fragment</strong></p>
<p><code>1. 通过构造函数传递</code>  <code>2. 获取Fragment的实例对象</code>   </p>
<pre><code>//CustFragment 是自定义的fragment，参数列表也可以自己定义咯，
getSupportFragmentManager().beginTransaction()
             .add(new CustFragment(自定义的的参数列表),new String(&quot;参数&quot;))

//------------------method two-----------------------
getSupportFragmentManager().findFragmentById(R.id.headlines_fragment);
//------------------method three----------------------
getSupportFragmentManager().findFragmentByTag(&quot;HeadLines&quot;);
</code></pre>
<blockquote>
<p>聪明的读者可能会问Fragment如何与Activity通信类似的问题，这是个好问题，请注意我们的研究的原则是单一目标原则，在这节我研究的是Activity，你的疑惑在后面都会一一解答  </p>
</blockquote>
<p><strong>2. Activity与Service</strong></p>
<p>Activity启动Service的两种方式：</p>
<pre><code>//CustomService 是自定义Service，完成一些后台操作

startService(new Intent(FirstActivity.this，CustomService.class));

bindService(new Intent(FirstActivity.this，CustomService.class)), new ServiceConnection() &#123;
          @Override
          public void onServiceConnected(ComponentName name, IBinder service) &#123;
              //当前启动的service 一些数据就会回调回这里，我们在Activity中操作这些数据即可
              get
          &#125;

          @Override
          public void onServiceDisconnected(ComponentName name) &#123;

          &#125;
      &#125;,flags);
</code></pre>
<p>从启动方式就可以看出，通过Bundle对象的形式存储，通过Intent传输，来完成Activity向Service传递数据的操作</p>
<p><strong>3. Activity与BroadcastReceiver</strong></p>
<p>启动广播的形式也有两种:</p>
<pre><code>//method one ！！！-----------------------------------------------
registerReceiver(new BroadcastReceiver() &#123;
          @Override
          public void onReceive(Context context, Intent intent) &#123;

          &#125;
      &#125;,new IntentFilter(),&quot;&quot;,new Handler());

//method two ！！！-----------------------------------------------
registerReceiver(new BroadcastReceiver() &#123;
          @Override
          public void onReceive(Context context, Intent intent) &#123;

          &#125;
      &#125;,new IntentFilter());  
</code></pre>
<blockquote>
<p>关于method one 的第三个参数Handler很多人会很费解<br>参照registerReceiver中源码关于该Handler参数的解释：<br><code>Handler identifying the thread that will receive the Intent. If null, the main thread of the process will be used.</code><br>定义了一个用于接收Intent的子线程，如果不填或者默认为null，那么就会在主线程中完成接收Intent的操作  </p>
</blockquote>
<p>很明显，Activity与BroadcastReceiver通信时，用的也是Intent传递，Bundle存储。</p>
<p><strong>4. 通讯时的同步问题</strong></p>
<blockquote>
<p>这里的同步通讯问题，为下文Fragment通讯作铺垫，不是这个问题不重要，不值得引起你注意，只是我想把问题放在它最应该出现的位置。</p>
</blockquote>
<p>以上只是基础的传递数据的形式，大部分都是静态的，现在有一种需求，用户操作Activity，发出了某些指令，比如按下，滑动，触摸等操作，如何完成这些信息传递呢？这就要求同步了。</p>
<p>同步传递消息也很简单，就是调用系统写好的回调接口</p>
<p>首先我们要知道，用户 点击，触摸 这些行为 也属于 通信的范畴—点击和触摸属于 信息源；<br>比如用户行为进行点击，那就实现 ：</p>
<pre><code>new Button(mCotext).setOnClickListener(new View.OnClickListener() &#123;
       @Override
       public void onClick(View v) &#123;
           new ImageView(mCotext).invalidate();
       &#125;
   &#125;);
</code></pre>
<p>通过此招提示指定的ImageView：嘿！老兄，你该刷新了</p>
<p>又或者 当用户 进行触摸操作，我们需要实现放大缩小平移指定的区域：</p>
<pre><code>new RelativeLayout(mCotext).setOnTouchListener(new View.OnTouchListener() &#123;
          @Override
          public boolean onTouch(View v, MotionEvent event) &#123;
              //缩放
              v.setScaleX(1f);
              v.setScaleY(1f);
              //平移
              v.setTranslationX(1f);
              v.setTranslationY(1f);
              v.setTranslationY(1f);
              //旋转
              v.setRotation(2f);
              v.setRotationX(2f);
              v.setRotationY(2f);

              v.invalidate();
              return true;
          &#125;
      &#125;);
</code></pre>
<p>嘿，你看，当用户进行触摸操作，我们可以通过回调onTouchListenter来完成“触摸”这一操作</p>
<blockquote>
<p>关于View重绘机制以及优化刷新UI的细节，不属于本文讨论范围。</p>
</blockquote>
<h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><h3 id="1-Fragment-与Activity通信"><a href="#1-Fragment-与Activity通信" class="headerlink" title="1. Fragment 与Activity通信"></a>1. Fragment 与Activity通信</h3><p>通过实例对象传递</p>
<p>同样的，在 Fragment 中 <code>getActivity()</code> 可以获取到它相关联的 Activity 实例，就可以轻松获取并且修改 Activity 的数据。</p>
<h3 id="2-Fragment-与-多个Fragment通信"><a href="#2-Fragment-与-多个Fragment通信" class="headerlink" title="2. Fragment 与 多个Fragment通信"></a>2. Fragment 与 多个Fragment通信</h3><p>首先，两个Fragment之间不可能直接通信（非正规因素除外），Google官方提出的解决办法是 通过相关联的Activity来完成两个Fragment的通信</p>
<p>只需要记住三步：</p>
<p><strong>1. 定义一个接口：</strong></p>
<p>在让Fragment关联Activity之前，可以在Fragment中定义一个接口，然后让宿主Activity来实现这个接口。接着，在Fragment中捕获这个接口，并且在onAttach()中 捕获Activity实例</p>
<pre><code>//只需关注接口是如何定义的，以及onAttack中的实现
public class HeadlinesFragment extends ListFragment &#123;
    //定义的接口引用
    OnHeadlineSelectedListener mCallback;

    // 自定义回调接口，宿主Activity必须要实现它
    public interface OnHeadlineSelectedListener &#123;
        public void onArticleSelected(int position);
    &#125;

    @Override
    public void onAttach(Activity activity) &#123;
        super.onAttach(activity);

        // 在这里只是为了确保Activity实现了我们定义的接口，如果没有实现，则抛出异常
        try &#123;
            mCallback = (OnHeadlineSelectedListener) activity;
        &#125; catch (ClassCastException e) &#123;
            throw new ClassCastException(activity.toString()
                    + &quot; must implement OnHeadlineSelectedListener&quot;);
        &#125;
    &#125;

    ...
&#125;
</code></pre>
<p>一旦 Activity 通过 <code>OnHeadlineSelectedListener</code> 的实例 mCallBack 回调  <code>onArticleSelected（）</code> ，Fragment 就可以传递信息给 Activity 了</p>
<p>例如 下面是 ListFragment 的一个回调方法，当用户点击了 list 中的 item，这个 Fragment 就会通过回调接口向宿主 Activity 传递事件</p>
<pre><code>@Override
   public void onListItemClick(ListView l, View v, int position, long id) &#123;
       // 向Activity传递事件信息
       mCallback.onArticleSelected(position);
   &#125;
</code></pre>
<p><strong>2. 在宿主Activity实现这个接口</strong></p>
<p>怎么实现？很简单，参考下面代码：</p>
<pre><code>public static class MainActivity extends Activity
        implements HeadlinesFragment.OnHeadlineSelectedListener&#123;
    ...

    public void onArticleSelected(int position) &#123;
        // 用户从从 HeadlinesFragment选中了一个标题
        //响应用户的操作，做一些业务逻辑
    &#125;
&#125;
</code></pre>
<p><strong>3. 向其他Fragment传递信息 （完成通信）</strong></p>
<p>宿主Activity可以通过findFragmentById()向指定的Fragment传递信息，宿主Activity可以直接获取Fragment实例，回调Fragment的公有方法</p>
<p>例如：</p>
<p>宿主Activity 包含了一个Listfragment用来展示条目信息，当每个条目被点击的时候，我们希望ListFragment向另外一个DetailsFragment传递一个信息用来 展示不同的细节</p>
<pre><code>public static class MainActivity extends Activity
        implements HeadlinesFragment.OnHeadlineSelectedListener&#123;
    ...

     public void onArticleSelected(int position) &#123;
        // 用户在 HeadlinesFragment中选中了一个item

        //在activity中添加新的fragment
        ArticleFragment articleFrag = (ArticleFragment)
                getSupportFragmentManager().findFragmentById(R.id.article_fragment);

        if (articleFrag != null) &#123;
            // If article 对象 可以复用, 我们就不需要创建两遍了

            // 回调articleFrag 更新
            articleFrag.updateArticleView(position);

        &#125; else &#123;
            // 创建 Fragment 并为其添加一个参数，用来指定应显示的文章
            ArticleFragment newFragment = new ArticleFragment();
            Bundle args = new Bundle();
            args.putInt(ArticleFragment.ARG_POSITION, position);
            newFragment.setArguments(args);

            FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();

            // 将 fragment_container View 时中的内容替换为此 Fragment ，
            // 然后将该事务添加到返回堆栈，以便用户可以向后回滚
            transaction.replace(R.id.fragment_container, newFragment);
            int setTransition=TRANSIT_FRAGMENT_OPEN;
            transaction.setTransition(setTransition);
            transaction.addToBackStack(null);

            // 执行事务
            transaction.commit();
        &#125;
    &#125;
&#125;
</code></pre>
<p>下面我写了一个实例来供大家理解：</p>
<p>各个类的联系图：</p>
<p><img src="http://img.shedoor.net/ocnyang/android_comm/%E9%80%9A%E4%BF%A1fragment.jpg">  </p>
<p>这里写图片描述</p>
<p>效果如下：</p>
<p><img src="http://img.shedoor.net/ocnyang/android_comm/Fragment%E9%80%9A%E4%BF%A1_gif.gif">  </p>
<p>这里写图片描述</p>
<p><a target="_blank" rel="noopener" href="http://download.csdn.net/detail/chivalrousman/9545616">Fragment 通信 Demo 实例</a>  </p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h3 id="Service-与-Activity-通信"><a href="#Service-与-Activity-通信" class="headerlink" title="Service 与 Activity 通信"></a>Service 与 Activity 通信</h3><p>主要是如何获得Service实例的问题<br>总结来说两步：</p>
<ol>
<li><p>在Service定义内部类，继承Binder，封装Service作为内部类的属性，并且在onBind方法中返回内部类的实例对象  </p>
</li>
<li><p>在Activity中实现ServiceConnection ，获取到Binder对象，再通过Binder获取Service</p>
<blockquote>
</blockquote>
<p> public class LocalService extends Service {</p>
<pre><code> // 传递给客户端的Binder
 private final IBinder mBinder = new LocalBinder();
 //构造Random对象
 private final Random mGenerator = new Random();

 /**
  * 这个类提供给客户端  ，因为Service总是运行在同一个进程中的
  */
 public class LocalBinder extends Binder &#123;
     LocalService getService() &#123;
         // 当客户端回调的时候，返回LoacalService实例
         return LocalService.this;
     &#125;
 &#125;

 @Override
 public IBinder onBind(Intent intent) &#123;
     return mBinder;
 &#125;

 /**交给客户端回调的方法 */
 public int getRandomNumber() &#123;
   return mGenerator.nextInt(100);
 &#125;
</code></pre>
<p> }</p>
<p> public class BindingActivity extends Activity {</p>
<pre><code> LocalService mService;
 boolean mBound = false;

 @Override
 protected void onCreate(Bundle savedInstanceState) &#123;
     super.onCreate(savedInstanceState);
     setContentView(R.layout.main);
 &#125;

 @Override
 protected void onStart() &#123;
     super.onStart();
     // 绑定 LocalService
     Intent intent = new Intent(this, LocalService.class);
     bindService(intent, mConnection, Context.BIND_AUTO_CREATE);
 &#125;

 @Override
 protected void onStop() &#123;
     super.onStop();
     // 解绑 service
     if (mBound) &#123;
         unbindService(mConnection);
         mBound = false;
     &#125;
 &#125;

 /**button已经通过 android:onClick (attribute) 设置此方法响应用户click*/
 public void onButtonClick(View v) &#123;
     if (mBound) &#123;
         // 回调 LocalService的方法.
         //因为在主线程中刷新UI，可能会造成线程阻塞，这里只是为了测试
         int num = mService.getRandomNumber();
         Toast.makeText(this, &quot;number: &quot; + num, Toast.LENGTH_SHORT).show();
     &#125;
 &#125;

 /**定义通过bindService 回调的Binder */
 private ServiceConnection mConnection = new ServiceConnection() &#123;

     @Override
     public void onServiceConnected(ComponentName className,
             IBinder service) &#123;
        //先通过Binder获得Service的内部类 LoacalBinder
         LocalBinder binder = (LocalBinder) service;
          // 现在可以获得service对象了
         mService = binder.getService();
         mBound = true;
     &#125;

     @Override
     public void onServiceDisconnected(ComponentName arg0) &#123;
         mBound = false;
     &#125;
 &#125;;
</code></pre>
<p> }</p>
</li>
</ol>
<p>除了这种回调的方式外</p>
<p>还有一种方式 是在Service中 发送广播，</p>
<p>比如 在 Service 中 开启了一个子线程执行任务，就在子线程的 run() 方法中去 <code>sendBroadcast(intent);</code><br>数据用Intent封装，传递形式用广播</p>
<h2 id="AIDL-完成进程间通信"><a href="#AIDL-完成进程间通信" class="headerlink" title="AIDL 完成进程间通信"></a>AIDL 完成进程间通信</h2><p>关于进程和线程的细节改天详细说明，我们首先了解一下进程和线程的概念：</p>
<blockquote>
<p>当某个应用组件启动且该应用没有运行其他任何组件时，<a href="http://ocnyang.com/">Android</a> 系统会使用单个执行线程为应用启动新的 Linux<br>进程。默认情况下，同一应用的所有组件在相同的进程和线程（称为“主”线程）中运行。<br>如果某个应用组件启动且该应用已存在进程（因为存在该应用的其他组件），则该组件会在此进程内启动并使用相同的执行线程。<br>但是，我们也可以安排应用中的其他组件在单独的进程中运行，并为任何进程创建额外的线程。  </p>
</blockquote>
<blockquote>
<p>各类组件元素的清单文件条目—：activity，servicer，eceiver 和 provider 均支持 android:process 属性，此属性可以指定该组件应在哪个进程运行。我们可以设置此属性，使每个组件均在各自的进程中运行，或者使一些组件共享一个进程，而其他组件则不共享。 此外，我们还可以设置 android:process，使不同应用的组件在相同的进程中运行  </p>
</blockquote>
<p>以及了解一下 进程间通信的概念</p>
<blockquote>
<p>Android 利用远程过程调用 (RPC) 提供了一种进程间通信 (IPC) 机制，通过这种机制，由 Activity<br>或其他应用组件调用的方法将（在其他进程中）远程执行，而所有结果将返回给调用方。这就要求把方法调用及其数据分解至操作系统可以识别的程度，并将其从本地进程和地址空间传输至远程进程和地址空间，然后在远程进程中重新组装并执行该调用。<br>然后，返回值将沿相反方向传输回来。 Android 提供了执行这些 IPC 事务所需的全部代码，因此我们只需集中精力定义和实现 RPC<br>编程接口即可。  </p>
</blockquote>
<blockquote>
<p>要执行 IPC，必须使用 bindService() 将应用绑定到服务上。</p>
</blockquote>
<p>具体实现 可以 <a target="_blank" rel="noopener" href="http://blog.csdn.net/u013478336/article/details/43818185">参考这个实例</a> 和文末给出的官方文档</p>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>Handler 和AsyncTask都是用来完成子线程和主线程即UI线程通信的</p>
<p>都可以解决主线程 处理耗时操作，造成界面卡顿或者程序无响应ANR异常 这一类问题</p>
<p>Handler 是 一种机制【Handler+Message+Looper】，所有的数据通过Message携带，，所有的执行顺序按照队列的形式执行，Looper用来轮询判断消息队列，Handler用来接收和发送Message</p>
<p>AsyncTask 是一个单独的类，设计之初的目的只是为了 异步方式完成耗时操作的，顺便可以通知主线程刷新Ui，AsyncTask的内部机制则是维护了一个线程池，提升性能。</p>
<p>在这里提供另一种优雅的做法完成线程间的通信：</p>
<p>扩展 IntentService 类</p>
<p>由于大多数启动服务都不必同时处理多个请求（实际上，这种多线程情况可能很危险），因此使用 IntentService 类实现服务值得一试。<br>但如需同时处理多个启动请求，则更适合使用该基类Service。</p>
<p>IntentService 执行以下操作：</p>
<ul>
<li>创建默认的工作线程，用于在应用的主线程外执行传递给 onStartCommand() 的所有 Intent。</li>
<li>创建工作队列，用于将一个 Intent 逐一传递给 onHandleIntent() 实现，这样我们就永远不必担心多线程问题。</li>
<li>在处理完所有启动请求后停止服务，因此我们不必调用 stopSelf()。</li>
<li>提供 onBind() 的默认实现（返回 null）。</li>
<li>提供 onStartCommand() 的默认实现，可将 Intent 依次发送到工作队列和 onHandleIntent() 实现。<br>综上所述，您只需实现 onHandleIntent() 来完成客户端提供的工作即可。（不过，我们还需要为服务提供小型构造函数。）  </li>
</ul>
<p>以下是 IntentService 的实现示例：</p>
<pre><code>public class HelloIntentService extends IntentService &#123;

  /**
   * 必须有构造函数 必须调用父 IntentService(String)带有name的构造函数来执行工作线程
   */
  public HelloIntentService() &#123;
      super(&quot;HelloIntentService&quot;);
  &#125;

  /**
   * IntentService 调用默认的工作线程启动服务
   * 当此方法结束，, IntentService 服务结束
   */
  @Override
  protected void onHandleIntent(Intent intent) &#123;
      // 通常在这里会执行一些操作，比如下载文件
      //在这里只是sleep 5 s
      long endTime = System.currentTimeMillis() + 5*1000;
      while (System.currentTimeMillis() &amp;lt; endTime) &#123;
          synchronized (this) &#123;
              try &#123;
                  wait(endTime - System.currentTimeMillis());
              &#125; catch (Exception e) &#123;
              &#125;
          &#125;
      &#125;
  &#125;
&#125;
</code></pre>
<p>看吧，我们只需要一个构造函数和一个 onHandleIntent() 实现即可。</p>
<p>对于Service 当然也有基础一点的做法，来完成多线程的操作，只不过代码量更多了：</p>
<pre><code>public class HelloService extends Service &#123;
  private Looper mServiceLooper;
  private ServiceHandler mServiceHandler;

  // Handler 接收来自主线程的Message
  private final class ServiceHandler extends Handler &#123;
      public ServiceHandler(Looper looper) &#123;
          super(looper);
      &#125;
      @Override
      public void handleMessage(Message msg) &#123;
         //执行任务，比如下载什么的，这里只是 让线程sleep
          long endTime = System.currentTimeMillis() + 5*1000;
          while (System.currentTimeMillis() &amp;lt; endTime) &#123;
              synchronized (this) &#123;
                  try &#123;
                      wait(endTime - System.currentTimeMillis());
                  &#125; catch (Exception e) &#123;
                  &#125;
              &#125;
          &#125;
          // 手动停止服务，来处理下一个线程
          stopSelf(msg.arg1);
      &#125;
  &#125;

  @Override
  public void onCreate() &#123;
    //启动线程.  注意我们在主线程中创建了一些子线程, 这些线程都没有加锁同步. 这些现场都是后台线程，所以不会阻塞UI线程
    HandlerThread thread = new HandlerThread(&quot;ServiceStartArguments&quot;,
            Process.THREAD_PRIORITY_BACKGROUND);
    thread.start();

    // Handler开始轮询遍历了
    mServiceLooper = thread.getLooper();
    mServiceHandler = new ServiceHandler(mServiceLooper);
  &#125;

  @Override
  public int onStartCommand(Intent intent, int flags, int startId) &#123;
      Toast.makeText(this, &quot;service starting&quot;, Toast.LENGTH_SHORT).show();

      // 每一次请求，都会通过handler发送Message
      // startID只是为了让我们知道正在进行的是哪一个线程，以便于我们停止服务
      Message msg = mServiceHandler.obtainMessage();
      msg.arg1 = startId;
      mServiceHandler.sendMessage(msg);

      // If we get killed, after returning from here, restart
      return START_STICKY;
  &#125;

  @Override
  public IBinder onBind(Intent intent) &#123;
      // 不提供 binding, 所以返回空
      return null;
  &#125;

  @Override
  public void onDestroy() &#123;
    Toast.makeText(this, &quot;service done&quot;, Toast.LENGTH_SHORT).show();
  &#125;
&#125;
</code></pre>
<h2 id="多个App间的通信"><a href="#多个App间的通信" class="headerlink" title="多个App间的通信"></a>多个App间的通信</h2><p>首先我们要知道以下两点：</p>
<ol>
<li>Android 应用一般具有若干个Activity。每个Activity显示一个用户界面，用户可通过该界面执行特定任务（比如，查看地图或拍照）。要将用户从一个Activity转至另一Activity，应用必须使用 Intent 定义做某事的“意向”。 当我们使用诸如 startActivity() 的方法将 Intent 传递至系统时，系统会使用 Intent 识别和启动相应的应用组件。使用意向甚至可以让我们的应用开始另一个应用中包含的Activity。</li>
<li>Intent 可以为 显式 以便启动特定组件（特定的 Activity 实例）或隐式 以便启动处理意向操作（比如“拍摄照片”）的任何组件。  </li>
</ol>
<h3 id="1-向另一个应用发送用户"><a href="#1-向另一个应用发送用户" class="headerlink" title="1. 向另一个应用发送用户"></a>1. 向另一个应用发送用户</h3><p>Android最重要的功能之一，是可以操作其他应用，比如在我们的应用中，需要使用地图显示公司地址，我们无序在地图应用程序中构建Activity，而是直接创建Intent查看 地址的请求，Android系统之后启动 可以在地图上显示 地址的应用。</p>
<p><strong>1) 构建隐式的意图</strong></p>
<p>隐式意图不用声明要启动的组件类名称，而是声明操作，比如查看，编辑，发送，或者获取某项。</p>
<p>如果您我们的数据是Uri，可以这样构建Intent：</p>
<pre><code>//当我们的应用通过startActivity()调用此Intent时，电话应用会发起向指定电话号码呼叫
Uri number = Uri.parse(&quot;tel:5551234&quot;);
Intent callIntent = new Intent(Intent.ACTION_DIAL, number);  
</code></pre>
<p>这里还有一些其他Intent的操作和Uri数据对:</p>
<p><strong>·</strong> <code>查看地图：</code></p>
<pre><code>// 基于地址的地图位置
Uri location = Uri.parse(&quot;geo:0,0?q=1600+Amphitheatre+Parkway,+Mountain+View,+California&quot;);
// 基于经纬度的地图位置
// Uri location = Uri.parse(&quot;geo:37.422219,-122.08364?z=14&quot;); // z param is zoom level
Intent mapIntent = new Intent(Intent.ACTION_VIEW, location);
</code></pre>
<p><strong>·</strong> <code>查看网页：</code></p>
<pre><code>Uri webpage = Uri.parse(&quot;http://www.ocnyang.com&quot;);
Intent webIntent = new Intent(Intent.ACTION_VIEW, webpage);
</code></pre>
<p>有的同学会问了，我从哪里可以知道，Intent可以传递的 Uri的类型，或者其他数据类型呢？</p>
<p>答：可以查阅 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/content/Intent.html#ACTION_VIEW">Google Intent 的 API</a></p>
<p><strong>2) 确认是否存在 接收意向的应用</strong></p>
<blockquote>
<p>注意：如果调用了意向，但设备上没有可用于处理意向的应用，我们的应用将崩溃。</p>
</blockquote>
<p>要确认是否存在可响应意向的可用Activity，请调用 queryIntentActivities() 来获取能够处理ntent 的Activity列表。 如果返回的 List 不为空，则可以安全地使用该意向。例如：</p>
<pre><code>PackageManager packageManager = getPackageManager();
List activities = packageManager.queryIntentActivities(intent,
        PackageManager.MATCH_DEFAULT_ONLY);
boolean isIntentSafe = activities.size() &gt; 0;
</code></pre>
<p>如果 isIntentSafe 是 true，则至少有一个应用将响应该意向。 如果它是 false，则没有任何应用处理该意向。</p>
<p><strong>3) 启动指定Activity</strong></p>
<p>当我指定意图后，通过startActivity(intent);就可以启动指定Activity</p>
<p>此处有一个Google官方的示例：</p>
<pre><code>// 构建Intent
Uri location = Uri.parse(&quot;geo:0,0?q=1600+Amphitheatre+Parkway,+Mountain+View,+California&quot;);
Intent mapIntent = new Intent(Intent.ACTION_VIEW, location);

// 确定意图可以被接收
PackageManager packageManager = getPackageManager();
List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(mapIntent, 0);
boolean isIntentSafe = activities.size() &gt; 0;

//启动指定应用
if (isIntentSafe) &#123;
    startActivity(mapIntent);
&#125;
</code></pre>
<p><strong>4) 显示应用选择器</strong></p>
<p>比如我们要完成 <strong>分享操作</strong>，用户可以使用多个App完成分享，我们应明确显示选择器对话框，如图</p>
<p><img src="http://img.shedoor.net/ocnyang/android_comm/intent-chooser.png" alt="intent-chooser">  </p>
<p>要显示选择器，需要使用Intent的createChooser()方法 创建Intent，并将其传递至 startActivity()</p>
<pre><code>Intent intent = new Intent(Intent.ACTION_SEND);
...

String title = getResources().getString(R.string.chooser_title);
// Create intent to show chooser
Intent chooser = Intent.createChooser(intent, title);

// Verify the intent will resolve to at least one activity
if (intent.resolveActivity(getPackageManager()) != null) &#123;
    startActivity(chooser);
&#125;
</code></pre>
<p>这将显示一个对话框，其中有响应传递给 createChooser() 方法的意向的应用列表，并且将提供的文本用作 对话框标题</p>
<h3 id="2-接收其他Activity返回的结果"><a href="#2-接收其他Activity返回的结果" class="headerlink" title="2. 接收其他Activity返回的结果"></a>2. 接收其他Activity返回的结果</h3><p>通过Intent.startActivityForResult()来完成。</p>
<p>首先在启动另一个Activity时，我们需要指定request code以便返回结果时，我们可以正常处理它。</p>
<pre><code>static final int PICK_CONTACT_REQUEST = 1;  // The request code
...
private void pickContact() &#123;
    Intent pickContactIntent = new Intent(Intent.ACTION_PICK, Uri.parse(&quot;content://contacts&quot;));
    pickContactIntent.setType(Phone.CONTENT_TYPE);
    startActivityForResult(pickContactIntent, PICK_CONTACT_REQUEST);
&#125;
</code></pre>
<p>当用户完成操作后，返回数据，系统会调用Activity的 onActivityResult()方法，</p>
<pre><code>@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;
    // 检查requestCode是否真确
    if (requestCode == PICK_CONTACT_REQUEST) &#123;
        // 确保请求时成功的
        if (resultCode == RESULT_OK) &#123;
           // 完成我们的业务逻辑
        &#125;
    &#125;
&#125;
</code></pre>
<p>为了成功处理结果，我们必须了解Intent的格式，比如联系人返回的是带内容的URI，照相机返回的是Bitmap<br>如何根据返回的URI来读取数据，我们需要对ContentResolver 和 ContentProvider 有了解</p>
<p>下面就是一个三者结合的获取联系人的实例：</p>
<pre><code>@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;
    // 检查requestCode
    if (requestCode == PICK_CONTACT_REQUEST) &#123;
        // 确保请求成功
        if (resultCode == RESULT_OK) &#123;
            //获得选择的联系人的URI
            Uri contactUri = data.getData();
            // 我们只需要NUMBER这一列的信息，
            String[] projection = &#123;Phone.NUMBER&#125;;

            // 显示根据NUMBER查询的结果
            // We don&#39;t need a selection or sort order (there&#39;s only one result for the given URI)
            // 在这里我们并没有对查询的结果进行排序，因为在主线程中进行这种数据库操作，有可能阻塞线程
            //优化方案是异步完成排序的操作，这里只是展示多个App间的通信
            Cursor cursor = getContentResolver()
                    .query(contactUri, projection, null, null, null);
            cursor.moveToFirst();

            //从NUMBER那一列当中取回phone NUMBER
            int column = cursor.getColumnIndex(Phone.NUMBER);
            String number = cursor.getString(column);
            //接下来就是要操作这些phone number了
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="3-接收其他Activity返回的结果"><a href="#3-接收其他Activity返回的结果" class="headerlink" title="3. 接收其他Activity返回的结果"></a>3. 接收其他Activity返回的结果</h3><p>要允许其他应用开始您的Activity，需要 在相应元素的宣示说明文件中添加一个 元素。</p>
<p>例如，此处有一个在数据类型为文本或图像时处理 ACTION_SEND 意向的意向过滤器：</p>
<pre><code>&lt;activity android:name=&quot;ShareActivity&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.SEND&quot;/&gt;
        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;
        &lt;data android:mimeType=&quot;text/plain&quot;/&gt;
        &lt;data android:mimeType=&quot;image/*&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>
<p>定义操作，通常是系统定义的值之一，比如ACTION_SEND 或 ACTION_VIEW。</p>
<p>定义与Intent关联的数据，只需通过 android:mimeType 指定我们接收的数据类型，比如text/plain 或 image/jpeg。</p>
<p>所有的隐式Intent，都使用 CATEGORY_DEFAULT 进行定义</p>
<h3 id="4-处理Activity中的Intent"><a href="#4-处理Activity中的Intent" class="headerlink" title="4. 处理Activity中的Intent"></a>4. 处理Activity中的Intent</h3><p>当Activity开始时，调用getIntent检索开始Activity的Intent，</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) &#123;
    super.onCreate(savedInstanceState);

    setContentView(R.layout.main);

    Intent intent = getIntent();
    Uri data = intent.getData();

    // 指出接收的数据类型
    if (intent.getType().indexOf(&quot;image/&quot;) != -1) &#123;
        // 处理带有图片的Intent
    &#125; else if (intent.getType().equals(&quot;text/plain&quot;)) &#123;
        // 处理带有文本的Intent
    &#125;
&#125;
</code></pre>
<h3 id="5-向指定Activity中返回数据"><a href="#5-向指定Activity中返回数据" class="headerlink" title="5. 向指定Activity中返回数据"></a>5. 向指定Activity中返回数据</h3><p>只需调用setResult指定结果代码和Intent</p>
<pre><code>Intent result = new Intent(&quot;com.example.RESULT_ACTION&quot;, Uri.parse(&quot;content://result_uri&quot;);
setResult(Activity.RESULT_OK, result);
finish();
</code></pre>
<p>记住必须为结果指定结果码，通常为 RESULT_OK 或 RESULT_CANCELED。</p>
<p>我们也可以在Intent中 用Bundle存储额外的信息</p>
<p>细心的同学可能发现一个问题：</p>
<p>启动 Activity 有 startActivity() 和 startActivityForResult() 两种启动方式，返回结果的形式id偶有 setResult() 吗？</p>
<p>如果开启当前Activity的Intent可能需要结果，只需调用 setResult()。 如果原始 Activity 已调用 startActivityForResult()，则系统将向其传递您提供给 setResult() 的结果；否则，会忽略结果。</p>
<h2 id="使用大型开源框架完成组件间的通信"><a href="#使用大型开源框架完成组件间的通信" class="headerlink" title="使用大型开源框架完成组件间的通信"></a>使用大型开源框架完成组件间的通信</h2><p>Github上非常火的两大通信组件EventBus和otto：</p>
<h3 id="1-EventBus"><a href="#1-EventBus" class="headerlink" title="1. EventBus"></a>1. EventBus</h3><p>EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。</p>
<p>传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。</p>
<p><strong>1）概念：</strong></p>
<p>事件(Event)：又可称为消息，本文中统一用事件表示。其实就是一个对象，可以是网络请求返回的字符串，也可以是某个开关状态等等。事件类型(EventType)指事件所属的 Class。</p>
<p>事件分为一般事件和 Sticky 事件，相对于一般事件，Sticky 事件不同之处在于，当事件发布后，再有订阅者开始订阅该类型事件，依然能收到该类型事件最近一个 Sticky 事件。</p>
<p>订阅者(Subscriber)：订阅某种事件类型的对象。当有发布者发布这类事件后，EventBus 会执行订阅者的 onEvent 函数，这个函数叫事件响应函数。订阅者通过 register 接口订阅某个事件类型，unregister 接口退订。订阅者存在优先级，优先级高的订阅者可以取消事件继续向优先级低的订阅者分发，默认所有订阅者优先级都为 0。</p>
<p>发布者(Publisher)：发布某事件的对象，通过 post 接口发布事件。</p>
<p>本项目较为简单，总体设计和流程图：</p>
<p><img src="http://img.shedoor.net/ocnyang/android_comm/EventBus-Publish-Subscribe.png" alt="EventBus-Publish-Subscribe">  </p>
<p>使用方式：</p>
<p>build.gradle 中加入依赖</p>
<pre><code>compile &#39;org.greenrobot:eventbus:3.0.0&#39;
</code></pre>
<p>代码中指需三步</p>
<blockquote>
<p><strong>1.</strong> 定义事件：只需要是一个Java类</p>
</blockquote>
<pre><code>public class MessageEvent &#123;
    public final String message;
    public MessageEvent(String message) &#123;
        this.message = message;
    &#125;
&#125;
</code></pre>
<blockquote>
<p><strong>2.</strong> 完成订阅者</p>
</blockquote>
<pre><code>//MessageEvent被Eventbus post提交的时候 将会回调这个方法
//这种方式 提示我们可以直接定义自己的事件
@Subscribe
public void onMessageEvent(MessageEvent event)&#123;
    Toast.makeText(getActivity(), event.message, Toast.LENGTH_SHORT).show();
&#125;

// 当一些其他事件post提交的时候，回调这个方法
@Subscribe
public void handleSomethingElse(SomeOtherEvent event)&#123;
    doSomethingWith(event);
</code></pre>
<blockquote>
<p>在Activity或者Fragment中绑定订阅者</p>
</blockquote>
<pre><code>@Override
public void onStart() &#123;
    super.onStart();
    EventBus.getDefault().register(this);
&#125;

@Override
public void onStop() &#123;
   EventBus.getDefault().unregister(this);
    super.onStop();
&#125;
</code></pre>
<blockquote>
<p><strong>3.</strong> 发布事件：</p>
</blockquote>
<pre><code>EventBus.getDefault().post(new MessageEvent(&quot;Hello everyone!&quot;));
</code></pre>
<h2 id="本文参考并翻译"><a href="#本文参考并翻译" class="headerlink" title="本文参考并翻译"></a>本文参考并翻译</h2><blockquote>
<p><a target="_blank" rel="noopener" href="http://www.androidchina.net/5028.html#rd">文章来源</a></p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.android.com/training/basics/fragments/communicating.html">Google 课程 Communicating with Other Fragments</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.android.com/guide/components/aidl.html">Google 解释 AIDL进程间通信</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.android.com/training/multiple-threads/communicate-ui.html">Google 解释 Handler</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/os/AsyncTask.html">Google 解释 AsyncTask</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/content/BroadcastReceiver.html">Google BroadcastReceiver API</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.android.com/training/basics/intents/index.html?hl=vi">Google 课程 Interacting with Other Apps</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.android.com/guide/topics/providers/content-provider-creating.html">Google 解释 contentprovider</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/content/BroadcastReceiver.html">Google BroadcastReceiver 课程</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.android.com/guide/components/services.html">Google Service 课程</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.android.com/guide/components/processes-and-threads.html#">Google 解释 进程和线程</a></li>
<li><a target="_blank" rel="noopener" href="http://greenrobot.org/eventbus/documentation/">EventBus官方文档</a></li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>OCNYang
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="http://ocnyang.com/2017/02/13/AndroidComm/" title="详解 Android 通信">http://ocnyang.com/2017/02/13/AndroidComm/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"><i class="fa fa-tag"></i> Android</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/01/05/WindowSoftware/" rel="prev" title="常用电脑软件你选对了吗？">
      <i class="fa fa-chevron-left"></i> 常用电脑软件你选对了吗？
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/02/13/DonkeyAndPrincess/" rel="next" title="向日葵公主与驴的爱情故事">
      向日葵公主与驴的爱情故事 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E6%96%87%E5%A4%A7%E7%BA%B2"><span class="nav-number">1.</span> <span class="nav-text">本文大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Activity%E9%80%9A%E4%BF%A1"><span class="nav-number">2.</span> <span class="nav-text">Activity通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Activity-%E5%92%8C-Activity"><span class="nav-number">2.1.</span> <span class="nav-text">Activity 和 Activity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Activity-%E5%92%8C-Fragment%EF%BC%8CService%EF%BC%8CBrodcastReceiver"><span class="nav-number">2.2.</span> <span class="nav-text">Activity 和 Fragment，Service，BrodcastReceiver</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fragment"><span class="nav-number">3.</span> <span class="nav-text">Fragment</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Fragment-%E4%B8%8EActivity%E9%80%9A%E4%BF%A1"><span class="nav-number">3.1.</span> <span class="nav-text">1. Fragment 与Activity通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Fragment-%E4%B8%8E-%E5%A4%9A%E4%B8%AAFragment%E9%80%9A%E4%BF%A1"><span class="nav-number">3.2.</span> <span class="nav-text">2. Fragment 与 多个Fragment通信</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Service"><span class="nav-number">4.</span> <span class="nav-text">Service</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Service-%E4%B8%8E-Activity-%E9%80%9A%E4%BF%A1"><span class="nav-number">4.1.</span> <span class="nav-text">Service 与 Activity 通信</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AIDL-%E5%AE%8C%E6%88%90%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">5.</span> <span class="nav-text">AIDL 完成进程间通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">6.</span> <span class="nav-text">线程间通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AAApp%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">7.</span> <span class="nav-text">多个App间的通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%90%91%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E5%8F%91%E9%80%81%E7%94%A8%E6%88%B7"><span class="nav-number">7.1.</span> <span class="nav-text">1. 向另一个应用发送用户</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8E%A5%E6%94%B6%E5%85%B6%E4%BB%96Activity%E8%BF%94%E5%9B%9E%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="nav-number">7.2.</span> <span class="nav-text">2. 接收其他Activity返回的结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%8E%A5%E6%94%B6%E5%85%B6%E4%BB%96Activity%E8%BF%94%E5%9B%9E%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="nav-number">7.3.</span> <span class="nav-text">3. 接收其他Activity返回的结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%A4%84%E7%90%86Activity%E4%B8%AD%E7%9A%84Intent"><span class="nav-number">7.4.</span> <span class="nav-text">4. 处理Activity中的Intent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%90%91%E6%8C%87%E5%AE%9AActivity%E4%B8%AD%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE"><span class="nav-number">7.5.</span> <span class="nav-text">5. 向指定Activity中返回数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%A7%E5%9E%8B%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E5%AE%8C%E6%88%90%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">8.</span> <span class="nav-text">使用大型开源框架完成组件间的通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-EventBus"><span class="nav-number">8.1.</span> <span class="nav-text">1. EventBus</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E6%96%87%E5%8F%82%E8%80%83%E5%B9%B6%E7%BF%BB%E8%AF%91"><span class="nav-number">9.</span> <span class="nav-text">本文参考并翻译</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">OCNYang</p>
  <div class="site-description" itemprop="description">前线 Android 开发者，亦涉猎 Flutter。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OCNYang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">381k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">5:47</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>
<br /> #换行
<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("04/21/2019 15:54:40");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '',
      clientSecret: '',
      repo        : '',
      owner       : '',
      admin       : [''],
      id          : 'ae183d21e5505c7022f4cbe346f0a94f',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

  
</body>
</html>
