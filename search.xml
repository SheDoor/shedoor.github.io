<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>EditText的使用及值得注意的地方</title>
    <url>/2016/08/09/Android-EditText-YouShouldKnow/</url>
    <content><![CDATA[<p>Android上有很多输入法应用，每种输入法都有各自的特点，输入法多数时候是和EditText配合使用，结合我自己的亲身实践分享一下使用EditText过程中遇到的一些问题及解决方法。</p>
<span id="more"></span>

<hr>
<h3 id="设置默认输入法"><a href="#设置默认输入法" class="headerlink" title="设置默认输入法"></a>设置默认输入法</h3><p>有时候为了提高用户体验，在弹出输入法时需要设置默认的输入状态，比如单词应用弹出输入法时，输入法最好是在英文输入状态下。如果是字典应用，弹出输入法时最好是在中文输入状态下，Android并没有提供设置默认的输入状态的接口，但我们可以通过如下方法一样能够达到想要的效果：</p>
<p><strong>默认中文：</strong></p>
<p>mEditText.setInputType(EditorInfo.TYPE_CLASS_TEXT);</p>
<p><strong>默认英文：</strong></p>
<p>mEditText.setInputType(EditorInfo.TYPE_TEXT_VARIATION_URI);</p>
<h3 id="打开和关闭输入法"><a href="#打开和关闭输入法" class="headerlink" title="打开和关闭输入法"></a>打开和关闭输入法</h3><p>手动控制输入法的开关状态也能提升用户体验，比如：</p>
<ul>
<li>有的搜索框会有一个清除按钮，点击清除按钮时就应该弹出输入法，因为用户清除搜索内容的目的多数时候是需要输入新的内容；</li>
<li>执行搜索时应该隐藏输入法，因为显示输入法时会遮挡搜索结果，用户体验不太好；</li>
<li>闹钟来时或者有其它window弹出时应该隐藏输入法，因为输入法也是window，如果不隐藏可能导致输入法遮挡住了其它window等用户体验不太友好的问题。</p></li>
</ul>
<p><strong>打开输入法：</strong></p>
<pre><code>private void open(Context context, View editText) &#123;
        InputMethodManager inputMethodManager = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
        inputMethodManager.showSoftInput(editText, 0);
    &#125;
</code></pre>
<p><strong>关闭输入法：</strong></p>
<pre><code>private void close(Context context,View editText)&#123;
    InputMethodManager inputMethodManager = (InputMethodManager)context.getSystemService(Context.INPUT_METHOD_SERVICE);
    inputMethodManager.hideSoftInputFromWindow(editText.getWindowToken(),0);
</code></pre>
<p>}</p>
<h3 id="监听EditText的输入状态"><a href="#监听EditText的输入状态" class="headerlink" title="监听EditText的输入状态"></a>监听EditText的输入状态</h3><ul>
<li>类似新浪微博，在输入内容时会提示还可以输入多少字；</li>
<li>有的搜索引擎，输入内容时实时显示搜索结果；</li>
<li>有的输入框有输入长度限制，输入内容超过长度限制时弹出提示信息。</li>
</ul>
<p>上面这些都可以通过监听EditText的输入状态来实现，具体实现方式如下：</p>
<pre><code>mInputEditTxt.addTextChangedListener(newTextWatcher()&#123;
    @Override
    publicvoidbeforeTextChanged(CharSequences,intstart,intcount,intafter)&#123;

    &#125;

    @Override
    publicvoidonTextChanged(CharSequences,intstart,intbefore,intcount)&#123;
        System.out.println(&quot;监听EditText输入内容的变化，在这里可以监听输入内容的长度。&quot;);
    &#125;

    @Override
    publicvoidafterTextChanged(Editables)&#123;
        System.out.println(&quot;这里可以实现所输即所得，用户输入的同时可以立即在这里根据输入内容执行操作，显示搜索结果！&quot;);
    &#125;
&#125;);
</code></pre>
<h3 id="监听输入法中的回车按钮"><a href="#监听输入法中的回车按钮" class="headerlink" title="监听输入法中的回车按钮"></a>监听输入法中的回车按钮</h3><p>比如搜狗输入法的右下角有一个回车按钮，我们希望用户点击它时也执行确认功能，可以通过监听EditText的按键点击事件来实现：</p>
<pre><code>/**
 * 监听输入法按键
 *
 * */
mInputEditTxt.setOnKeyListener(newOnKeyListener()&#123;
    @Override
    publicbooleanonKey(Viewv,intkeyCode,KeyEvent event)&#123;
        if(keyCode == KeyEvent.KEYCODE_ENTER &amp;&amp; event.getAction() == KeyEvent.ACTION_UP)&#123;
            System.out.println(&quot;手指弹起时执行确认功能&quot;);
            returntrue;
        &#125;

        returnfalse;
    &#125;
&#125;);
</code></pre>
<h3 id="改变输入法中回车按钮的显示内容"><a href="#改变输入法中回车按钮的显示内容" class="headerlink" title="改变输入法中回车按钮的显示内容"></a>改变输入法中回车按钮的显示内容</h3><p>如果回车按钮是执行搜索功能，则回车按钮上显示”搜索”，如果是执行发送功能，则显示”发送”,如果是下一步，则显示”下一步”。</p>
<p>实现这个功能需要调用EditText的setImeOptions方法：</p>
<pre><code>/**
*
* IME_ACTION_SEARCH 搜索
* IME_ACTION_SEND 发送
* IME_ACTION_NEXT 下一步
* IME_ACTION_DONE 完成
*/
mInputEditTxt.setImeOptions(EditorInfo.IME_ACTION_SEARCH);
</code></pre>
<h3 id="限制输入内容"><a href="#限制输入内容" class="headerlink" title="限制输入内容"></a>限制输入内容</h3><p>有时候我们根本就不想用户输入一些杂七杂八的内容，因为这需要程序针对输入的内容做各种处理，如果处理不当还会有好多不可预见的问题，索性在输入内容时就禁止用户输入一些非法字符，这可以通过下面的方式实现，新建一个类InputTxtFilter：</p>
<pre><code>publicclassInputTxtFilter&#123;
publicstaticfinalintINPUT_TYPE_EN = 0x01;
publicstaticfinalintINPUT_TYPE_CH = 0x02;
privatestaticfinalString[]SPELL = newString[]&#123;
    &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;i&quot;,&quot;j&quot;,&quot;k&quot;,&quot;l&quot;,&quot;m&quot;,&quot;n&quot;,&quot;o&quot;,&quot;p&quot;,&quot;q&quot;,&quot;r&quot;,&quot;s&quot;,&quot;t&quot;,&quot;u&quot;,&quot;v&quot;,&quot;w&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;,
    &quot;ā&quot;,&quot;á&quot;,&quot;ǎ&quot;,&quot;à&quot;,&quot;ō&quot;,&quot;ó&quot;,&quot;ǒ&quot;,&quot;ò&quot;,&quot;ē&quot;,&quot;é&quot;,&quot;ě&quot;,&quot;è&quot;,&quot;ī&quot;,&quot;í&quot;,&quot;ǐ&quot;,&quot;ì&quot;,&quot;ū&quot;,&quot;ú&quot;,&quot;ǔ&quot;,&quot;ù&quot;,&quot;ǖ&quot;,&quot;ǘ&quot;,&quot;ǚ&quot;,&quot;ǜ&quot;,&quot;ü&quot;
&#125;;
privatestaticchar[]chineseParam = newchar[]&#123;&#39;」&#39;,&#39;，&#39;,&#39;。&#39;,&#39;？&#39;,&#39;…&#39;,&#39;：&#39;,&#39;～&#39;,&#39;【&#39;,&#39;＃&#39;,&#39;、&#39;,&#39;％&#39;,&#39;＊&#39;,&#39;＆&#39;,&#39;＄&#39;,&#39;（&#39;,&#39;‘&#39;,&#39;’&#39;,&#39;“&#39;,&#39;”&#39;,&#39;『&#39;,&#39;〔&#39;,&#39;｛&#39;,&#39;【&#39;
    ,&#39;￥&#39;,&#39;￡&#39;,&#39;‖&#39;,&#39;〖&#39;,&#39;《&#39;,&#39;「&#39;,&#39;》&#39;,&#39;〗&#39;,&#39;】&#39;,&#39;｝&#39;,&#39;〕&#39;,&#39;』&#39;,&#39;”&#39;,&#39;）&#39;,&#39;！&#39;,&#39;；&#39;,&#39;—&#39;&#125;;

privateInputTxtFilter()&#123;

&#125;

publicstaticvoidinputFilter(finalContext context,finalEditText editText,finalinttype,finalintinputLimit)&#123;
    InputFilter[]filters = newInputFilter[1];
    filters[0] = newInputFilter.LengthFilter(inputLimit)&#123;
        publicCharSequence filter(CharSequence source,intstart,intend,Spanned dest,intdstart,intdend)&#123;
            booleanisRightCharater = false;
            if(type == INPUT_TYPE_EN)&#123;
                isRightCharater = isLetter(source.toString());
            &#125;elseif(type == INPUT_TYPE_CH)&#123;
                isRightCharater = isChineseWord(source.toString());
            &#125;

            if( !isRightCharater|| dest.toString().length()&gt;=inputLimit)&#123;
                return&quot;&quot;;
            &#125;

            returnsource;
        &#125;
    &#125;;
    editText.setFilters(filters);
&#125;

/**
 * 检测String是否全是中文
 *
 */
publicstaticbooleanisChineseWord(Stringname)&#123;
    booleanres=true;
    char[]cTemp = name.toCharArray();

    for(inti = 0;i &lt; name.length();i++ )&#123;
        if( !isChinese(cTemp[i]))&#123;
            res=false;
            break;
        &#125;
    &#125;

    returnres;
&#125;

/**
 * 是否为英文字母
 *
 * */
publicstaticbooleanisLetter(StringinputStr)&#123;
    char[]inputArray = inputStr.toCharArray();
    List&lt;String&gt;spellList = Arrays.asList(SPELL);

    for(charinput : inputArray)&#123;
        if( !spellList.contains(input + &quot;&quot;))&#123;
            returnfalse;
        &#125;
    &#125;

    returntrue;
&#125;

/**
 * 判定输入汉字
 * @param c
 */
publicstaticbooleanisChinese(charc)&#123;
    for(charparam : chineseParam)&#123;
        if(param == c)&#123;
            returnfalse;
        &#125;
    &#125;

    Character.UnicodeBlock ub = Character.UnicodeBlock.of(c);
    if(ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS
        || ub == Character.UnicodeBlock.CJK_COMPATIBILITY_IDEOGRAPHS
        || ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A
        || ub == Character.UnicodeBlock.GENERAL_PUNCTUATION
        || ub == Character.UnicodeBlock.CJK_SYMBOLS_AND_PUNCTUATION
        || ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS)&#123;
        returntrue;
    &#125;

    returnfalse;
&#125;
</code></pre>
<p>}</p>
<p>在初始化EditText时，调用InputTxtFilter的inputFilter方法，传入输入长度限制、输入内容的类型限制等即可，eg：</p>
<pre><code>InputTxtFilter.inputFilter(this,mInputEditTxt,InputTxtFilter.INPUT_TYPE_EN,5);
</code></pre>
<h3 id="屏蔽EditText的复制、粘贴功能"><a href="#屏蔽EditText的复制、粘贴功能" class="headerlink" title="屏蔽EditText的复制、粘贴功能"></a>屏蔽EditText的复制、粘贴功能</h3><p>在低版本的Android SDK中，如果对EditText的输入长度有限制时，长按EditText并将选中的内容拖动到EditText输入框中，如果这时候的长度超过了EditText的输入长度限制，程序会直接崩溃掉，在高版本的Android SDK中这个问题已经改了，如果出现上面的情况会直接清空输入框中的内容，为了避免这种讨厌的问题，我们可以屏蔽EditText的复制和粘贴功能，只需要屏蔽EditText的长按响应即可：</p>
<pre><code>/**
 * 屏蔽复制、粘贴功能
 *
 * */
mInputEditTxt.setCustomSelectionActionModeCallback(newActionMode.Callback()&#123;
    publicbooleanonCreateActionMode(ActionMode actionMode,Menu menu)&#123;
        returnfalse;
    &#125;

    publicbooleanonPrepareActionMode(ActionMode actionMode,Menu menu)&#123;
        returnfalse;
    &#125;

    publicbooleanonActionItemClicked(ActionMode actionMode,MenuItem menuItem)&#123;
        returnfalse;
    &#125;

    @Override
    publicvoidonDestroyActionMode(ActionMode mode)&#123;

    &#125;
&#125;);

mInputEditTxt.setLongClickable(false);
</code></pre>
<blockquote>
<p>来源： 张明云（@UperOne）</p>
<p>链接： <a href="http://www.jianshu.com/p/1f05bb1fde3e">http://www.jianshu.com/p/1f05bb1fde3e</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android控件</category>
      </categories>
      <tags>
        <tag>Android控件</tag>
        <tag>EditText</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>在Android 6.0 设备上动态获取权限</title>
    <url>/2016/08/16/Android6Permission/</url>
    <content><![CDATA[<p>众所周知，Android 6.0 相比之前的Android版本有一个很大的不同点，就是动态获取权限。今天自己在做拨号功能时，正巧遇到这个问题， 顺手记录下在Android 6.0 上如何动态获取权限。</p>
<span id="more"></span>

<p>下面从自己一开始的问题入手</p>
<h3 id="实现拨号功能"><a href="#实现拨号功能" class="headerlink" title="实现拨号功能"></a>实现拨号功能</h3><p>说到拨号，一个 Intent 就搞定，代码如下，</p>
<pre><code>   private void callDirectly(String mobile)&#123;
        Intent intent = new Intent();
        intent.setAction(&quot;android.intent.action.CALL&quot;);
        intent.setData(Uri.parse(&quot;tel:&quot; + mobile));
        mContext.startActivity(intent);
    &#125;
</code></pre>
<p>当然 你可别忘了在 Manifest 文件中去声明拨号的权限</p>
<pre><code>   &lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot; /&gt;
</code></pre>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如果在 Android 6.0 以前的设备上，上面的代码都是没有问题的，但是如果是在 Android 6.0 设备上，并且项目的 targetSdkVersion 你设置的是23，那么 当你执行上面的拨号代码时，程序将会奔溃掉。</p>
<p>此时你肯定想到了 如果 targetSdkVersion 值设置的小于23是不是就不会奔溃了，恩，确实如此， 此时即使使用Android6.0的设备，程序也不会奔溃，原因显而易见，Android 的权限机制是 Android M 后才加入的。从 Android M 开始 应用程序申请的权限是在运行时动态赋给用户的。</p>
<p>关于动态分配权限，一些同学可能不是很清楚。这里稍稍提一下 Android 6.0 的权限动态分配。 如果你只对最终的解决方案感兴趣，可以跳过下面这节，直接去看解决方案</p>
<h3 id="权限动态分配"><a href="#权限动态分配" class="headerlink" title="权限动态分配"></a>权限动态分配</h3><p>在 Android6.0 之前，下载好一个应用程序，点击安装我们看到的大都是像这样的界面。  </p>
<p><img src="http://img.shedoor.net/android_m_install.jpg">  </p>
<p>上图分别是Nexus6和小米手机在安装软件时的界面。</p>
<p>在安装时你会发现，手机操作系统会提示，这个软件会索要了你手机的那些权限，并且给用一个列表进行展示，但是这些提示只是在安装是提示，只要你点击接受或者安装， 表示你允许这个应用在可以获取它申明的所有权限。一般很少有人在安装时，会因为看到某个应用因为申请了某一个敏感权限而放弃安装应用。因为这个权限虽然敏感， 但是对于当前的用户是不可感知的，因为他现在并没有立即去查看你的最近通话、短信记录…</p>
<p>说到这里，我们自然而然的会想到，其实最好的方式是，当这个应用在用户使用过程中，正准备使用某个权限时，比如说读取短信列表，系统能及时的弹出一个提示框，说这个应用要读取您的短信内容， 您是否允许。然后用户结合当前应用的执行动作，依据当前条件判断，是不是应该授予应用读取短信记录的权限。这绝对的最完美的。 因为在具体的使用过程中，用户可以结合当前应用的使用场景，去思考、判断是不是应该给这个应用相应的权限。不给能怎样，给了会怎样， 这样对用户而言，完全是主动的，相比安装时那种选择，这样的做法无疑是对用户莫大的尊重，同时这也保证了用户的个人隐私。</p>
<p>说到这里，不得不插一句，其实 MIUI 早就实现了这个系统特性，在这一点上 MIUI 确实走到了 Android团队的前面，恩，给 MIUI 点个赞。</p>
<p>然而直到 Android 6.0 这个版本开始，上面的假设终于得到了谷歌的实践，除了在应用安装时，操作系统会提示应用会获取那些权限，在运行过程中，当应用去真的获取一些敏感 权限时，系统还会弹出一个提示框，询问用户是不是授予应用相应的权限。如下图所示。  </p>
<p><img src="http://img.shedoor.net/android_m_sms.jpeg">  </p>
<p>这就是 Android 6.0 的运行时权限检查机制。下面是Google官方对此的解释，只截取介绍部分</p>
<blockquote>
<p>Beginning in Android 6.0 (API level 23), users grant permissions to apps while the app is running, not when they install the app. This approach streamlines the app install process, since the user does not need to grant permissions when they install or update the app. It also gives the user more control over the app’s functionality; for example, a user could choose to give a camera app access to the camera but not to the device location. The user can revoke the permissions at any time, by going to the app’s Settings screen.</p>
</blockquote>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>其实上面已经说了一种取巧的方案，将 targetSdkVersion 设为小于23的值，程序将不会奔溃， 但是在Android 6.0 上你的应用程序依旧拨不了电话，这是真的。所以要想兼容6.0版本，必须通过下面的方式进行代码层面的兼容。</p>
<p>对Android版本做判断，然后对Android 6.0 做特殊处理，代码如下</p>
<pre><code> final public static int REQUEST_CODE_ASK_CALL_PHONE = 123;

 public void onCall(String mobile)&#123;
        this.mMobile = mobile;
        if (Build.VERSION.SDK_INT &gt;= 23) &#123;
            int checkCallPhonePermission = ContextCompat.checkSelfPermission(mContext,Manifest.permission.CALL_PHONE);
            if(checkCallPhonePermission != PackageManager.PERMISSION_GRANTED)&#123;
                ActivityCompat.requestPermissions(mContext,new String[]&#123;Manifest.permission.CALL_PHONE&#125;,REQUEST_CODE_ASK_CALL_PHONE);
                return;
            &#125;else&#123;
                //上面已经写好的拨号方法
                callDirectly(mobile);
            &#125;
        &#125; else &#123;
            //上面已经写好的拨号方法
            callDirectly(mobile);
        &#125;
    &#125;
</code></pre>
<p>此时，如果一个Android6.0的用户触发拨号动作，执行上面的代码，那么他将会看到一个很好看的MaterialDialog，如下图所示。</p>
<p><img src="http://img.shedoor.net/android_m_permission.jpeg"></p>
<p>那么用户点击拒绝或者允许，我们怎么才能拿到回调呢，如果能拿到回调，我们就可以根据用户的选择来执行不同的操作了。</p>
<p>这里应该会看到在 ActivityCompat 的 requestPermissions 方法中，最后一个参数是一个requestCode，看到它自然而然想到了经常用到的onActivityResult， 这里当执行 ActivityCompat 的 requestPermissions 方法后有一个回调机制，需要我们在当前 Activity 中实现 onRequestPermissionsResult 这个方法，具体如下</p>
<pre><code>@Override
public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123;
    switch (requestCode) &#123;
        case REQUEST_CODE_ASK_CALL_PHONE:
            if (grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123;
                // Permission Granted
                callDirectly(mobile);
            &#125; else &#123;
                // Permission Denied
                Toast.makeText(MainActivity.this, &quot;CALL_PHONE Denied&quot;, Toast.LENGTH_SHORT)
                        .show();
            &#125;
            break;
        default:
            super.onRequestPermissionsResult(requestCode, permissions, grantResults);
    &#125;
&#125;
</code></pre>
<p>这里会对提供了一个对用户点击做判断的入口，开发者可以根据 grantResults[0] 的类型，来判断用户点击的是允许还是拒绝，接着就可以执行相应的逻辑了。</p>
<h3 id="有用的链接"><a href="#有用的链接" class="headerlink" title="有用的链接"></a>有用的链接</h3><p>关于AndroidM上权限的动态获取，这里只给出了一个最简单的示例，如果你还没有尽兴，那么下面这篇国外的博文，一定会让你满足。</p>
<p><a href="https://inthecheesefactory.com/blog/things-you-need-to-know-about-android-m-permission-developer-edition/en">Everything every Android Developer must know about new Android’s Runtime Permission</a></p>
<p>这篇英文博文内容很长、内容也比较多，十足的干货。您慢用~</p>
<p>后记：偶然发现已经有哥们把上面的这篇文章做了翻译，真是极好的，这里给大家也摘录过来了，附上**<a href="http://ocnyang.com/2016/08/16/AndroidMPermission/">翻译链接</a>**，给翻译者同学点赞，辛苦！</p>
<p>另外，最近看到一个Github上的开源项目 <a href="https://github.com/k0shk0sh/PermissionHelper">PermissionHelper</a> ，专门用于处理 Android 6.0 的权限兼容问题。  </p>
<blockquote>
<p><a href="http://gudong.name/%E6%8A%80%E6%9C%AF/2015/11/10/android_m_permission.html">摘录来源</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android教程系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android6.0权限</tag>
        <tag>Android教程系列</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 7.1 新特性：快捷方式 Shortcuts</title>
    <url>/2016/11/23/Android7Shortcuts/</url>
    <content><![CDATA[<h2 id="一、Shortcuts-介绍"><a href="#一、Shortcuts-介绍" class="headerlink" title="一、Shortcuts 介绍"></a>一、Shortcuts 介绍</h2><p>Android 7.1 允许 App 自定义 Shortcuts，类似 iOS 的 3D touch。通过在桌面长按 App 弹出 Shortcut 列表，点击某个 Shortcut 快速进入某项操作，同时 Shortcut 可以拖动到桌面进行固定，如下图：  </p>
<p><img src="http://img.shedoor.net/ocnyang/android-7.1-app-shortcuts.jpg" alt="android-7.1-app-shortcuts">  </p>
<span id="more"></span>

<h3 id="1-Shortcuts-作用及分类"><a href="#1-Shortcuts-作用及分类" class="headerlink" title="1. Shortcuts 作用及分类"></a>1. Shortcuts 作用及分类</h3><p>Shortcuts 为 App 常用操作提供了快速访问的方式，如上面日历的新建提醒。  </p>
<p>这个功能目前只能在 <a href="http://ocnyang.com/">Android 7.1</a> 系统桌面进行使用，这个依然保留着“应用抽屉”古老设计的产品国内应该没多少用户。三方桌面可以通过 API 接入这个功能。<br>目前支持 Shortcut 的应用主要还是 Google 的 App，看到有即刻的朋友说他们在 7.1 系统发布时快速支持了这个功能并上线，速度很赞。  </p>
<p>类似 BroadcastReceiver 可通过静态和动态方式注册，Shortcuts 也可以通过静态和动态方式添加。  </p>
<h3 id="2-静态-Shortcuts-Static-Shortcuts"><a href="#2-静态-Shortcuts-Static-Shortcuts" class="headerlink" title="2. 静态 Shortcuts(Static Shortcuts)"></a>2. 静态 Shortcuts(Static Shortcuts)</h3><p>静态 ShortcutsStatic Shortcuts通过在 Manifest 中声明添加。缺点是不可以修改，只能通过应用升级来添加新的静态 Shortcuts。添加主要分为两步：  </p>
<p><strong>2.1</strong>  AndroidManifest.xml 的 Main Launcher 对应的 Activity 内添加 <code>meta-data meta-data name</code> 为<code>android.app.shortcuts</code>，如下：</p>
<pre><code>&lt;application
    ……&gt;
    &lt;activity android:name=&quot;.main.MainActivity&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;

            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;
        &lt;/intent-filter&gt;

        &lt;meta-data
            android:name=&quot;android.app.shortcuts&quot;
            android:resource=&quot;@xml/shortcuts&quot;/&gt;
    &lt;/activity&gt;
&lt;/application&gt;
</code></pre>
<p>必须在 Main Launcher 对应的 Activity 内设置，其中android:resource指向定义了 shortcuts 的资源文件。</p>
<p><strong>2.2</strong> 资源文件中定义具体的 shortcuts<br>res 目录下新建 xml 文件夹，并新建 shortcuts.xml 文件，内容如下：  </p>
<pre><code>&lt;shortcuts xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;shortcut
        android:enabled=&quot;true&quot;
        android:icon=&quot;@drawable/search&quot;
        android:shortcutId=&quot;search&quot;
        android:shortcutDisabledMessage=&quot;@string/disabled&quot;
        android:shortcutLongLabel=&quot;@string/menu_label&quot;
        android:shortcutShortLabel=&quot;@string/launcher_label&quot;&gt;
        &lt;intent
            android:action=&quot;android.intent.action.VIEW&quot;
            android:targetClass=&quot;cn.trinea.android.demo.SearchActivity&quot;
            android:targetPackage=&quot;cn.trinea.android.demo&quot;/&gt;
        &lt;intent
            ……/&gt;
    &lt;/shortcut&gt;
    ……
&lt;/shortcuts&gt;
</code></pre>
<p>以shortcuts元素为根，可以包含多个shortcut元素，每个shortcut元素表示一个 shortcut。其中属性分别表示：  </p>
<ol>
<li>shortcutId表示 shortcut 唯一标识符，相同的 shortcutId 会被覆盖。必须字段。  </li>
<li>shortcutShortLabel为将 shortcut 拖动到桌面时显示的名字，官方建议不超过 10 个字符，必须字段。  </li>
<li>shortcutLongLabel为 shortcut 列表中每个 shortcut 的名字，不宜过长，如果过长或未设置默认会显示 ShortLabel，官方建议不超过 25 个字符。可选字段。  </li>
<li>icon为 shortcut 的 icon，在列表展示和拖动到桌面时显示需要，可选字段。  </li>
<li>enabled表示 shortcut 是否可用，false 表示禁用。xml 中这个属性几乎没有被设置为 false 的实际场景，具体原因可见<strong>6.7 如何更好的删除(废弃)老的 Shortcut</strong>中介绍。  </li>
<li>shortcutDisabledMessage为已固定在桌面的 shortcut 被 Disabled 后点击时的 Toast 提示内容。可选字段。  </li>
<li>intent为点击 shortcut 时响应的 Intent，必须字段。  </li>
</ol>
<p>这里可以添加多个 Intent，但点击时不会启动所有 Intent，而是启动最后一个 Intent，在这个 Intent 回退时会启动它前面一个 Intent，相当于自动将所有 Intent 添加到了堆栈。<br>对于先跳转到某个页面，Back 键希望退回主页而不是结束 App 这类场景，多个 Intents 挺实用的。  </p>
<blockquote>
<p><strong>intent可设置属性包括：</strong><br>android:action、android:data、android:mimeType、android:targetClass、android:targetPackage<br>其中android:action为必须属性。  </p>
</blockquote>
<h3 id="3-动态-Shortcuts-Dynamic-Shortcuts"><a href="#3-动态-Shortcuts-Dynamic-Shortcuts" class="headerlink" title="3. 动态 Shortcuts(Dynamic Shortcuts)"></a>3. 动态 Shortcuts(Dynamic Shortcuts)</h3><p>动态 ShortcutsDynamic Shortcuts 通过 ShortcutManager API 进行操作。可以动态添加、修改、删除。  </p>
<pre><code>if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.N_MR1) &#123;
    return;
&#125;

ShortcutManager shortcutManager = getSystemService(ShortcutManager.class);
ShortcutInfo shortcut = new ShortcutInfo.Builder(this, &quot;id1&quot;)
    .setShortLabel(&quot;trinea.cn&quot;)
    .setLongLabel(&quot;Open trinea.cn&quot;)
    .setDisabledMessage(&quot;Disabled&quot;)
    .setIcon(Icon.createWithResource(context, R.drawable.trinea_cn))
    .setIntent(new Intent(Intent.ACTION_VIEW, Uri.parse(&quot;http://www.trinea.cn/&quot;)))
    .build();
shortcutManager.setDynamicShortcuts(Arrays.asList(shortcut));
</code></pre>
<p>通过ShortcutInfo.Builder新建 ShortcutInfo，再通过shortcutManager添加即可。其他：</p>
<ol>
<li>setDynamicShortcuts(List)可以替换并添加所有 shortcut 列表；  </li>
<li>addDynamicShortcuts(List)可以添加新的 shortcut 到列表，超过最大个数会报异常；  </li>
<li>updateShortcuts(List)可以更新一组 shortcuts；  </li>
<li>removeDynamicShortcuts(List)和removeAllDynamicShortcuts() 可以删除部分或所有 shortcuts。  </li>
</ol>
<p>ShortcutInfo的属性与 xml 中定义字段含义一致，shortcutId shortcutShortLabel intent 是必须设置的字段，并且intent必须设置Action。  </p>
<h3 id="4-固定的-Shortcuts-Pinned-Shortcuts"><a href="#4-固定的-Shortcuts-Pinned-Shortcuts" class="headerlink" title="4. 固定的 Shortcuts(Pinned Shortcuts)"></a>4. 固定的 Shortcuts(Pinned Shortcuts)</h3><p>指通过拖动固定到桌面的 Shortcuts，App 不可以添加、修改、删除这些 Shortcuts，只能禁用他们。即便 App 内删除了某个 Shorcut，对应的已固定到桌面的 Shortcuts 也不会被删除。  </p>
<p>可以通过：  </p>
<ol>
<li>getPinnedShortcuts()得到所有固定的 Shortcuts 的信息。  </li>
<li>disableShortcuts(List)或disableShortcuts(List, CharSequence)禁用动态的 Shortcuts。  </li>
</ol>
<p>对于静态的 Shortcuts 需要在资源文件中设置<code>android:enabled=&quot;false&quot;</code>进行禁用，不过没有必要，静态 Shortcuts 可直接通过删除达到禁用的效果，具体原因可见<strong>6.7 如何更好的删除(废弃)老的 Shortcut</strong>中介绍。</p>
<p>静态 Shortcuts 和动态 Shortcuts 是有最大个数限制的，默认为 5，超过最大个数后添加会报异常。而固定的 Shortcuts 并没有个数限制，并且固定的 Shortcut 对应的 Shortcut 即便被动态删除了，依然可以通过 id 进行 Update 操作。  </p>
<h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h3><h4 id="5-1-动态-Shortcuts-与静态-Shortcuts-区别"><a href="#5-1-动态-Shortcuts-与静态-Shortcuts-区别" class="headerlink" title="5.1 动态 Shortcuts 与静态 Shortcuts 区别"></a>5.1 动态 Shortcuts 与静态 Shortcuts 区别</h4><ol>
<li>静态 Shortcuts 只能通过升级应用修改，动态 Shortcuts 随时可以修改；</li>
<li>静态 Shortcuts 的 Intent 无法设置 Flag，默认为<code>FLAG_ACTIVITY_NEW_TASK</code>和<code>FLAG_ACTIVITY_CLEAR_TASK Flag</code>，即若应用运行中会清除所有已存在的 Activity。动态 Shortcuts 的 Intent 可以设置 Flag；</li>
<li>静态 Shortcuts 的rank系统默认根据声明顺序设置，动态 Shortcuts 的rank可以通过setRank(int rank)接口主动设置，rank 不能小于 0，值越大表示在 shortcut 列表展示时离 App Icon 越远。静态 Shortcuts 默认比动态 Shortcuts 离 App Icon 更近。</li>
<li>静态 Shortcuts 删除可以直接删除，动态 Shortcuts 建议通过禁用删除；</li>
</ol>
<h4 id="5-2-动态-Shortcuts-操作的频率问题"><a href="#5-2-动态-Shortcuts-操作的频率问题" class="headerlink" title="5.2 动态 Shortcuts 操作的频率问题"></a>5.2 动态 Shortcuts 操作的频率问题</h4><p>当应该完全退到后台<a href="http://ocnyang.com/">(无 Activity 或 Service 在前台时)</a>，其操作 Shortcut(包括添加、删除、修改) 的频率是受限的。可通过isRateLimitingActive()查询是否已受限，true表示已受限。  </p>
<h4 id="5-3-跟踪-Shorcut-使用情况"><a href="#5-3-跟踪-Shorcut-使用情况" class="headerlink" title="5.3 跟踪 Shorcut 使用情况"></a>5.3 跟踪 Shorcut 使用情况</h4><p>在 Shortcut 被选择或者其关联的操作被操作时需调用reportShortcutUsed(String shortcutId)接口上报数据，为了方便启动器收集应用 Shortcuts 使用情况，以便未来进行预测或者向开发者展示哪些操作适合作为 Shortcuts 以及其优先级。  </p>
<blockquote>
<p>PS：这个接口其实挺尴尬的，一方面需要 App 主动上报，侵入性太强。另一方面这个预测功能未来也不好加到 Shortcuts 推荐里，更多是个开发工具相关功能。<br>最好是由启动器自己纯粹收集 Shortcut 被选择的使用情况数据，而不需要统计 Shortcut 被关联操作通过其他方式调用的使用情况数据。至于哪些操作适合作为 Shortcuts，开发者大可通过其他监控 SDK 去判断。</p>
</blockquote>
<h4 id="5-4-应用备份"><a href="#5-4-应用备份" class="headerlink" title="5.4 应用备份"></a>5.4 应用备份</h4><p>如果应用通过备份恢复到另外一台机器上，固定的 Shortcuts 是可以直接恢复的，不过启动器不保存这些 Shortcut 的 icon，所以应用内需要存在这些 icon 对应的资源以便启动器能找到。  </p>
<p>静态 Shortcuts 需要应用重新安装、升级才能生效。<br>动态 Shortcuts 需要相应代码被执行过才能生效。</p>
<h2 id="二、Shortcuts-一些实践-amp-问题"><a href="#二、Shortcuts-一些实践-amp-问题" class="headerlink" title="二、Shortcuts 一些实践&amp;问题"></a>二、Shortcuts 一些实践&amp;问题</h2><p><img src="http://img.shedoor.net/ocnyang/android-7.1-app-shortcuts-3.jpg"><br><img src="http://img.shedoor.net/ocnyang/android-7.1-app-shortcuts-4.jpg"></p>
<h3 id="6-最佳实践"><a href="#6-最佳实践" class="headerlink" title="6. 最佳实践"></a>6. 最佳实践</h3><p>这块官网已经给出了一部分建议，包括：  </p>
<ol>
<li>设计上和系统 App 的 Shortcuts 保持一致。</li>
<li>最多添加 4 个 Shortcuts 以保持在启动器中显示的样式最佳<br>目前虽然说是 5 个，但实际最多只能添加 4 个，可见<strong>7.2 Shortcut 添加或修改无效</strong>中介绍。</li>
<li>限制 Label 长度<br>其中shortcutShortLabel建议不超过 10 个字符，shortcutLongLabel 建议不超过 25 个字符。这块可能有些问题，可见<strong>7.1 LongLabel 和 ShortLabel</strong>中介绍。</li>
<li>记录 Shortcut 及其对应操作使用记录。<br>这个在<strong>5.3 跟踪 Shorcut 使用情况</strong>中已经介绍了。</li>
<li>只在 Shortcut 意义不变的情况下更新，否则新增。</li>
<li>动态 Shortcuts 在 BackUp 恢复后不可以直接恢复，考虑适时新增或更新已有的 Shortcuts  </li>
</ol>
<p><strong>除了以上这些外，个人觉得还有几点需要遵守：</strong><br>7. 如何更好的删除(废弃)老的 Shortcut<br>这里主要考虑到删除老的 Shortcut，可能会影响已经固定的 Shortcut。<br>对于静态 Shortcuts，直接删除配置文件中对应的 Shortcut 即可，系统桌面会将已固定的该 Shortcut 置灰，点击会提示 shortcutDisabledMessage。<br>对于动态 Shortcuts 建议通过禁用的方式而不是直接删除的方式，因为已经删除的动态 Shortcut 如果被固定了依然是可用的，所以希望该入口不可用最好的方式是禁用。<br>8. 始终设置shortcutDisabledMessage<br>根据上面的介绍废弃老的 Shortcut 较好的方式是禁用，通过自定义shortcutDisabledMessage去更友好的提示用户。<br>9. 动态添加 Shortcut 前需要判断 API 版本不小于 25<br>否则在低版本会报 ClassNotFoundException 异常。</p>
<h3 id="7-一些问题"><a href="#7-一些问题" class="headerlink" title="7. 一些问题"></a>7. 一些问题</h3><h4 id="7-1-LongLabel-和-ShortLabel"><a href="#7-1-LongLabel-和-ShortLabel" class="headerlink" title="7.1 LongLabel 和 ShortLabel"></a>7.1 LongLabel 和 ShortLabel</h4><p>LongLabel和ShortLabel的含义，官方 API 文档解释的并不是很清楚。<br>在 Nexus 6 上测试，当 LongLabel 长度大于 17 个小写字符时，会显示 ShortLabel，而不是 LongLabel。这里的界限长度跟大小写、空格都有关，应该是受限于桌面 Shortcuts 列表 Item 的宽度！</p>
<h4 id="7-2-Shortcut-添加、修改、点击无效"><a href="#7-2-Shortcut-添加、修改、点击无效" class="headerlink" title="7.2 Shortcut 添加、修改、点击无效"></a>7.2 Shortcut 添加、修改、点击无效</h4><p>可能原因：  </p>
<ol>
<li>shortcutId 被覆盖<br>shortcutId 是唯一标识，相同 shortcutId 会被覆盖。  </li>
<li>intent 不对<br>intent 必须设置 android:action 属性，同时目标 Activity 必须有效即已在 Manifest 中声明。  </li>
<li>后台 App 有频率限制<br>当应该完全退到后台(无 Activity 或 Service 在前台时)，其操作 Shortcut(包括添加、删除、修改) 的频率是受限的。可通过isRateLimitingActive()查询是否已受限，true表示已受限。<br>若已受限，可通过开发者选项中“重置 ShortcutManager 调用频率限制”或命令行<code>adb shell cmd shortcut reset-throttling [ --user USER-ID ]</code>解决。  </li>
<li>Shortcut 个数限制<br>虽然官方文档介绍静态和动态 Shortcut 总和不能超过 5 个，通过getMaxShortcutCountPerActivity()得到的也是 5，但实际测试下来是不超过4个！即静态和动态shortcuts加起来总数最多是五个.<br>当我们尝试添加第六个shortcut时, 应用会抛出异常:<br> <code>java.lang.IllegalArgumentException: Max number of dynamic shortcuts exceeded.</code><br>虽然总数限制是5个, 但是当我正好有5个(2个静态 + 3个动态)的时候, 长按只显示了4个shortcuts.</li>
</ol>
<p><img src="http://img.shedoor.net/ocnyang/android-7.1-app-shortcuts-5.png" alt="android-7.1-app-shortcuts数量的限制">  </p>
<h4 id="7-3-getIntents-有-Bug"><a href="#7-3-getIntents-有-Bug" class="headerlink" title="7.3 getIntents() 有 Bug"></a>7.3 getIntents() 有 Bug</h4><p>从 <a href="https://android.googlesource.com/platform/frameworks/base/+/android-7.1.0_r7/core/java/android/content/pm/ShortcutInfo.java#1170">getIntents()</a> 实现 中可以看出未做mIntents是否为 null 及 empty 的判断，在 null 时会出现：  </p>
<pre><code>java.lang.NullPointerException: Attempt to get length of null array
</code></pre>
<p>的异常。</p>
<h3 id="8-三方桌面支持-Shortcuts——LauncherApps"><a href="#8-三方桌面支持-Shortcuts——LauncherApps" class="headerlink" title="8. 三方桌面支持 Shortcuts——LauncherApps"></a>8. 三方桌面支持 Shortcuts——LauncherApps</h3><p>如果三方桌面希望支持这个特性，请参考 <a href="https://developer.android.com/reference/android/content/pm/LauncherApps.html">LauncherApps API</a> 介绍，不过只有系统默认桌面才有权限得到其他 <a href="http://ocnyang.com/">App Shortcuts</a> 信息。  </p>
<p>可通过hasShortcutHostPermission()查看是否拥有权限，如果没有权限，会报如下异常：  </p>
<pre><code>java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;com.xx/com.xx.XXActivity&#125;:
java.lang.SecurityException: Caller can&#39;t access shortcut information
   at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2665)
   at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2726)
</code></pre>
<p>通过getShortcuts API 获取到所有 Shortcuts 信息。</p>
<blockquote>
<p>参考:<br>App Shortcuts的官方文档: <a href="https://developer.android.com/preview/shortcuts.html">App Shortcuts</a><br><a href="https://catinean.com/2016/10/20/exploring-android-nougat-7-1-app-shortcuts/">Exploring Android Nougat 7.1 App Shortcuts</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android教程系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android教程系列</tag>
        <tag>Android7新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Animation Detailed Tutorial / Android 动画详尽教程</title>
    <url>/2018/03/23/AndroidAnimationDetailedTutorial/</url>
    <content><![CDATA[<div  align="center">
<img src="http://img.shedoor.net/blog/header_bg.jpg" alt="Android Animation Set" align=center />
</div>



<br/>

<ul>
<li><strong>中文讲解（README）请直接点击对应标题</strong>  </li>
<li><strong>English explanation(or readme), Do not click on the title, please click on the tip address</strong></li>
</ul>
<span id="more"></span>

<h2 id="Ⅰ-View-Animation-视图动画"><a href="#Ⅰ-View-Animation-视图动画" class="headerlink" title="Ⅰ. View Animation / 视图动画"></a>Ⅰ. <a href="https://github.com/OCNYang/Android-Animation-Set/tree/master/view-animation">View Animation / 视图动画</a></h2><p><a href="https://developer.android.com/guide/topics/graphics/view-animation.html">English explanation can go to read this article</a>  </p>
<h2 id="Ⅱ-Drawable-Animation-帧动画-Frame-动画"><a href="#Ⅱ-Drawable-Animation-帧动画-Frame-动画" class="headerlink" title="Ⅱ. Drawable Animation / 帧动画 / Frame 动画"></a>Ⅱ. <a href="https://github.com/OCNYang/Android-Animation-Set/tree/master/drawable-animation">Drawable Animation / 帧动画 / Frame 动画</a></h2><p><a href="https://developer.android.com/reference/android/graphics/drawable/AnimationDrawable.html">English explanation can go to read this article</a>  </p>
<h2 id="Ⅲ-Property-Animation-属性动画"><a href="#Ⅲ-Property-Animation-属性动画" class="headerlink" title="Ⅲ. Property Animation / 属性动画"></a>Ⅲ. <a href="https://github.com/OCNYang/Android-Animation-Set/tree/master/property-animation">Property Animation / 属性动画</a></h2><p><a href="https://developer.android.com/guide/topics/graphics/prop-animation.html">English explanation can go to read this article</a>  </p>
<h2 id="Ⅳ-Ripple-Effect-Touch-Feedback-触摸反馈动画"><a href="#Ⅳ-Ripple-Effect-Touch-Feedback-触摸反馈动画" class="headerlink" title="Ⅳ. Ripple Effect / Touch Feedback / 触摸反馈动画"></a>Ⅳ. <a href="https://github.com/OCNYang/Android-Animation-Set/tree/master/ripple-animation">Ripple Effect / Touch Feedback / 触摸反馈动画</a></h2><p><a href="https://guides.codepath.com/android/Ripple-Animation">English explanation can go to read this article</a>  </p>
<h2 id="Ⅴ-Reveal-Effect-揭露动画"><a href="#Ⅴ-Reveal-Effect-揭露动画" class="headerlink" title="Ⅴ. Reveal Effect / 揭露动画"></a>Ⅴ. <a href="https://github.com/OCNYang/Android-Animation-Set/tree/master/reveal-animation">Reveal Effect / 揭露动画</a></h2><p><a href="http://anjithsasindran.in/blog/2015/08/15/material-sharing-card/">English explanation can go to read this article</a>  </p>
<h2 id="Ⅵ-Transition-Animation-转场动画-amp-共享元素"><a href="#Ⅵ-Transition-Animation-转场动画-amp-共享元素" class="headerlink" title="Ⅵ. Transition Animation / 转场动画 &amp; 共享元素"></a>Ⅵ. <a href="https://github.com/OCNYang/Android-Animation-Set/tree/master/transition-animation">Transition Animation / 转场动画 &amp; 共享元素</a></h2><p><a href="https://github.com/OCNYang/Android-Animation-Set/blob/master/transition-animation/README_EN.md">English explanation can go to read this readme</a>  </p>
<h2 id="Ⅶ-Animate-View-State-Changes-视图状态动画"><a href="#Ⅶ-Animate-View-State-Changes-视图状态动画" class="headerlink" title="Ⅶ. Animate View State Changes / 视图状态动画"></a>Ⅶ. <a href="https://github.com/OCNYang/Android-Animation-Set/tree/master/state-animation">Animate View State Changes / 视图状态动画</a></h2><p><a href="https://developer.android.com/training/material/animations.html">English explanation can go to read </a><br><a href="https://developer.android.com/reference/android/animation/StateListAnimator.html"><strong>StateListAnimator</strong></a> and <a href="https://developer.android.com/reference/android/graphics/drawable/StateListDrawable.html"><strong>StateListDrawable</strong></a></p>
<h2 id="Ⅷ-AnimatedVectorDrawable-矢量图动画"><a href="#Ⅷ-AnimatedVectorDrawable-矢量图动画" class="headerlink" title="Ⅷ. AnimatedVectorDrawable / 矢量图动画"></a>Ⅷ. <a href="https://github.com/OCNYang/Android-Animation-Set/tree/master/vector-animation">AnimatedVectorDrawable / 矢量图动画</a></h2><p><a href="https://www.androiddesignpatterns.com/2016/11/introduction-to-icon-animation-techniques.html">English explanation can go to read this article</a><br>or <a href="https://developer.android.com/reference/android/graphics/drawable/AnimatedVectorDrawable.html">AnimatedVectorDrawable</a><br>or <a href="https://developer.android.com/reference/android/graphics/drawable/VectorDrawable.html">VectorDrawable</a></p>
<h2 id="Wiki-附属文章"><a href="#Wiki-附属文章" class="headerlink" title="Wiki 附属文章"></a><a href="https://github.com/OCNYang/Android-Animation-Set/wiki">Wiki 附属文章</a></h2><ul>
<li><a href="https://github.com/OCNYang/Android-Animation-Set/wiki/%E5%AE%9E%E7%8E%B0-Activity-%E7%9A%84%E5%88%87%E6%8D%A2%E5%8A%A8%E7%94%BB">实现 Activity 的切换动画</a>  </li>
<li><a href="https://github.com/OCNYang/Android-Animation-Set/wiki/SVG-%E8%AE%B2%E8%A7%A3">SVG 讲解</a>  </li>
<li><a href="https://github.com/OCNYang/Android-Animation-Set/wiki/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E4%B9%8B-ViewPropertyAnimator-%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90">属性动画之 ViewPropertyAnimator 原理解析</a>  </li>
<li><a href="https://github.com/OCNYang/Android-Animation-Set/wiki/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Content-Transition">深入理解 Content Transition</a>  </li>
</ul>
<p><em>更全面的讲解将会逐步补充 / 欢迎 Star / 欢迎 Fork</em></p>
]]></content>
      <categories>
        <category>Android教程系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android初级躲不开的那些坑</title>
    <url>/2016/08/31/AndroidGu/</url>
    <content><![CDATA[<p>这里是作者<a href="http://ocnyang.com/">(OCN.Yang)</a>在Android初级阶段遇到的那些坑坑洼洼，有些还是开发中要知道的小技巧。相信大多数初学者难免也会遇到相同的坑，大家大概看看有者避之，还没遇到的就躲之。大牛和已经进阶的朋友可以绕道（相信你们很忙的）。  </p>
<span id="more"></span>

<h3 id="1、Ctrl-O快捷键"><a href="#1、Ctrl-O快捷键" class="headerlink" title="1、Ctrl + O快捷键"></a>1、Ctrl + O快捷键</h3><p>查看代码的大纲  即类的方法列表。  </p>
<h3 id="2、layout-weight"><a href="#2、layout-weight" class="headerlink" title="2、layout_weight"></a>2、layout_weight</h3><ul>
<li><strong>android:layout_weight</strong>的真实含义是:<br>一旦View设置了该属性(假设有效的情况下)，那么该 View的宽度等于原有宽度(android:layout_width)加上剩余空间的占比！  </li>
<li>如果width设置了match_parent ，那么，加上的是负的长度（相当于减去一部分长度）  </li>
<li>如果width设置了warp_content ，那么，剩余空间是“父容器总长度”减去“组件的内容占的长度”，然后再按比重值分。　　</li>
</ul>
<h3 id="3、Background-”-null”"><a href="#3、Background-”-null”" class="headerlink" title="3、Background=”@null”"></a>3、Background=”@null”</h3><p>可以给背景设置一个null值，在一定情况下这样做是有必要的。  </p>
<h3 id="4、判断String是否为空"><a href="#4、判断String是否为空" class="headerlink" title="4、判断String是否为空"></a>4、判断String是否为空</h3><pre><code>TextUtils.isEmpty(String str)
</code></pre>
<h3 id="5、Int-int-还是等于整型，太容易出错了。"><a href="#5、Int-int-还是等于整型，太容易出错了。" class="headerlink" title="5、Int/int  还是等于整型，太容易出错了。"></a>5、Int/int  还是等于整型，太容易出错了。</h3><h3 id="6、LinearLayout中的orientation-amp-gravity"><a href="#6、LinearLayout中的orientation-amp-gravity" class="headerlink" title="6、LinearLayout中的orientation &amp; gravity"></a>6、LinearLayout中的orientation &amp; gravity</h3><p>当LinearLayout布局中设置**orientation=”vertical”**属性：</p>
<ul>
<li>如果子组件设置**layout_gravity=”center_vertical”**是无效的；  </li>
<li>如果LinearLayout中设置**gravity=”center_vertical”**是可以起到作用将子组件垂直居中的。水平布局同理  </li>
</ul>
<h3 id="7、单例模式的Activity"><a href="#7、单例模式的Activity" class="headerlink" title="7、单例模式的Activity"></a>7、单例模式的Activity</h3><p>设置为单例模式的Activity，会单独开一个任务栈单独存放这个activity，这个任务栈只会在程序退出后消除。  </p>
<h3 id="8、选择手机中的图片并显示在ImageView上"><a href="#8、选择手机中的图片并显示在ImageView上" class="headerlink" title="8、选择手机中的图片并显示在ImageView上"></a>8、选择手机中的图片并显示在ImageView上</h3><pre><code>Intent intent = new Intent();  
/* 开启Pictures画面Type设定为image */  
intent.setType(&quot;image/*&quot;);  
/* 使用Intent.ACTION_GET_CONTENT这个Action */  
intent.setAction(Intent.ACTION_GET_CONTENT);   
/* 取得相片后返回本画面 */  
startActivityForResult(intent, 1);  


@Override  
protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;  
    if (resultCode == RESULT_OK) &#123;  
        Uri uri = data.getData();  
        ContentResolver cr = this.getContentResolver();  
        try &#123;  
            Bitmap bitmap = BitmapFactory.decodeStream(cr.openInputStream(uri));  
            ImageView imageView = (ImageView) findViewById(R.id.iv01);  
            /* 将Bitmap设定到ImageView */  
            imageView.setImageBitmap(bitmap);  
        &#125; catch (FileNotFoundException e) &#123;  
            Log.e(&quot;Exception&quot;, e.getMessage(),e);  
        &#125;  
    &#125;  
    super.onActivityResult(requestCode, resultCode, data);  
&#125;
</code></pre>
<h3 id="9、notifyDataSetChanged-刷新Adaper"><a href="#9、notifyDataSetChanged-刷新Adaper" class="headerlink" title="9、notifyDataSetChanged() 刷新Adaper."></a>9、notifyDataSetChanged() 刷新Adaper.</h3><h3 id="10、ListView-的优化"><a href="#10、ListView-的优化" class="headerlink" title="10、ListView 的优化"></a>10、ListView 的优化</h3><p>主要方法：  </p>
<ol>
<li>ListView设置固定高度，  </li>
<li>convertView判空，  </li>
<li>SetTag：convertView.setTag(viewHolder)，  </li>
<li>内部类ViewHolder，  </li>
<li>分页加载  </li>
</ol>
<h3 id="11、R文件编译报错-amp-找不到ID报错"><a href="#11、R文件编译报错-amp-找不到ID报错" class="headerlink" title="11、R文件编译报错 &amp; 找不到ID报错"></a>11、R文件编译报错 &amp; 找不到ID报错</h3><p>R文件的编译原理：当资源文件或id命名中其中一个文件的命名不满足规范时，R文件整体就不会再编译。  </p>
<h3 id="12、列表里的CheckBox"><a href="#12、列表里的CheckBox" class="headerlink" title="12、列表里的CheckBox"></a>12、列表里的CheckBox</h3><p><img src="http://img.shedoor.net/AndroidGu/4.jpeg"><br>注意: Spinner：如果item中有能够获得焦点的控件(例如CheckBox),则在item获得点击事件之后会继续传递给能够获得焦点的控件.<br>想让item在被点击后Spinner收回去,需要在布局(例如LinearLayout)中加上属性后代是否可以获得焦点：  </p>
<pre><code>android:descendantFocusability=&quot;blocksDescendants&quot;//阻止后代获得焦点  
</code></pre>
<h3 id="13、获取xml资源文件中定义的数组"><a href="#13、获取xml资源文件中定义的数组" class="headerlink" title="13、获取xml资源文件中定义的数组"></a>13、获取xml资源文件中定义的数组</h3><pre><code>getResources().getStringArray(R.array.city)  
</code></pre>
<h3 id="14、安卓默认字体大小："><a href="#14、安卓默认字体大小：" class="headerlink" title="14、安卓默认字体大小："></a>14、安卓默认字体大小：</h3><p><img src="http://img.shedoor.net/AndroidGu/1.jpeg"></p>
<h3 id="15、java-字符串split有很多坑"><a href="#15、java-字符串split有很多坑" class="headerlink" title="15、java 字符串split有很多坑"></a>15、java 字符串split有很多坑</h3><p>Java代码</p>
<pre><code>System.out.println(&quot;:ab:cd:ef::&quot;.split(&quot;:&quot;).length);//末尾分隔符全部忽略    
System.out.println(&quot;:ab:cd:ef::&quot;.split(&quot;:&quot;,-1).length);//不忽略任何一个分隔符    
System.out.println(StringUtils.split(&quot;:ab:cd:ef::&quot;,&quot;:&quot;).length);//最前面的和末尾的分隔符全部都忽略,apache commons    
System.out.println(StringUtils.splitPreserveAllTokens(&quot;:ab:cd:ef::&quot;,&quot;:&quot;).length);//不忽略任何一个分隔符 apache commons     
输出：    
4    
6    
3    
6    
</code></pre>
<blockquote>
<p>看了下jdk里String类的**public String[] split(String regex,int limit)**方法，感觉平时不太会用这方法，以为在用正则表达式来拆分时候，如果匹配到的字符是最后一个字符时，会拆分出两个空字符串，<br>例如”o”split(“o”,5) or “o”split(“o”,-2)时候 结果是”” “” 也就是下图中红框里的内容，所以平时一般都用split(String regex) 方法，其实也就等同于split(String regex，0)方法，把结尾的空字符串丢弃！   </p>
</blockquote>
<p><img src="http://img.shedoor.net/AndroidGu/2.jpg">  </p>
<h3 id="16、Android-Studio-的全局变量和强转的快捷键"><a href="#16、Android-Studio-的全局变量和强转的快捷键" class="headerlink" title="16、Android Studio 的全局变量和强转的快捷键"></a>16、Android Studio 的全局变量和强转的快捷键</h3><ul>
<li>Findviewbyid(R.id.XXX).cast(强转转换) 强转后点击回车回到行尾    </li>
<li>.field 全局变量  </li>
<li>.var 局部变量</li>
</ul>
<h3 id="17、TextView添加滚动条"><a href="#17、TextView添加滚动条" class="headerlink" title="17、TextView添加滚动条"></a>17、TextView添加滚动条</h3><p><img src="http://img.shedoor.net/AndroidGu/3.jpeg"></p>
<h3 id="18、数组适配器"><a href="#18、数组适配器" class="headerlink" title="18、数组适配器"></a>18、数组适配器</h3><p><img src="http://img.shedoor.net/AndroidGu/5.jpeg">  </p>
<p>////xListView上滑刷新，下滑加载更多///swapListView侧滑删除/</p>
<h3 id="19、Viewstub"><a href="#19、Viewstub" class="headerlink" title="19、Viewstub"></a>19、Viewstub</h3><p>只能inflatay一次。不然会报错。</p>
<h3 id="20、补间动画的旋转的圆心计算方法"><a href="#20、补间动画的旋转的圆心计算方法" class="headerlink" title="20、补间动画的旋转的圆心计算方法"></a>20、补间动画的旋转的圆心计算方法</h3><p>以图片的左上角为坐标（0,0），分别计算出pivotX和pivotY的数值：50%是图片本身大小的一半，50%p是父窗体宽高的一半长度。然后在图片的左上角的基础上加上这两个数组  </p>
<p><img src="http://img.shedoor.net/AndroidGu/6.jpeg">  </p>
<p>位移也是同样的计算方式</p>
<h3 id="21、插件"><a href="#21、插件" class="headerlink" title="21、插件"></a>21、插件</h3><p>ButterKnife   Gosn    android.selector.generat  </p>
<h3 id="22、margin-amp-padding"><a href="#22、margin-amp-padding" class="headerlink" title="22、margin &amp; padding"></a>22、margin &amp; padding</h3><p>android 中的控件的margin 和 padding 都是不会影响控件的设置宽高。（这点和网页设计是不一样的）</p>
<h3 id="23、R文件出错。"><a href="#23、R文件出错。" class="headerlink" title="23、R文件出错。"></a>23、R文件出错。</h3><p>当布局或id报找不到的错时，可能就是R文件出错。    </p>
<ul>
<li>一种可能是你导入了命名不规范的资源文件，导致R文件不能自动编译了。  </li>
<li>一种可能是你导入了import android.R系统的R文件导致报错  </li>
</ul>
<h3 id="24、ListView的多类型item"><a href="#24、ListView的多类型item" class="headerlink" title="24、ListView的多类型item"></a>24、ListView的多类型item</h3><p>自定义ListView中，如果item采用多种类型的布局。那么在getItemType中的下标一定要从0开始。不然会报下标越界异常。  </p>
<h3 id="25、java怎么在一个字符串里截取一个正则表达式字段"><a href="#25、java怎么在一个字符串里截取一个正则表达式字段" class="headerlink" title="25、java怎么在一个字符串里截取一个正则表达式字段"></a>25、java怎么在一个字符串里截取一个正则表达式字段</h3><pre><code>public static void main(String[] args) &#123;
    String str = &quot;&lt;div&gt;&lt;h3 ..&gt;dsijiswer*dfhjgf&lt;/h3&gt;&lt;/div&gt;&lt;table&gt;&lt;h3&gt;sdsd&lt;/h3&gt;&lt;/table&gt;&quot;;
    Pattern p = Pattern.compile(&quot;&lt;h3.*?/h3&gt;&quot;);
    Matcher m = p.matcher(str);
    while (m.find()) &#123;
        System.out.println(m.group());
    &#125;
&#125;
</code></pre>
<h3 id="26、事件机制：分发-消费-电梯机制：向上分发-，向下消费"><a href="#26、事件机制：分发-消费-电梯机制：向上分发-，向下消费" class="headerlink" title="26、事件机制：分发 消费  电梯机制：向上分发 ，向下消费"></a>26、事件机制：分发 消费  电梯机制：向上分发 ，向下消费</h3><h3 id="27、LinearLayout内部子控件之间的间隔-设置为等同的"><a href="#27、LinearLayout内部子控件之间的间隔-设置为等同的" class="headerlink" title="27、LinearLayout内部子控件之间的间隔 设置为等同的"></a>27、LinearLayout内部子控件之间的间隔 设置为等同的</h3><p>在drawer文件夹下创建一个shape的图形文件</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:shape=&quot;rectangle&quot; &gt;
    &lt;size android:width=&quot;15dp&quot; /&gt;
    &lt;solid android:color=&quot;@android:color/transparent&quot; /&gt;
&lt;/shape&gt;  
</code></pre>
<p>在linearLayout里设置属性divider为上图形，同时设置showdivider属性</p>
<h3 id="28、TextView-上设置的图片-设置图片大小的方法："><a href="#28、TextView-上设置的图片-设置图片大小的方法：" class="headerlink" title="28、TextView 上设置的图片  设置图片大小的方法："></a>28、TextView 上设置的图片  设置图片大小的方法：</h3><pre><code>txtZQD = (TextView) findViewById(R.id.txtZQD);  
Drawable[] drawable = txtZQD.getCompoundDrawables();  //获取它前后左右的图片
// 数组下表0~3,依次是:左上右下  
drawable[1].setBounds(100, 0, 200, 200);  
txtZQD.setCompoundDrawables(drawable[0], drawable[1], drawable[2],drawable[3]);  
</code></pre>
<h3 id="29、android中内部存储和外部存储的理解和路径获取"><a href="#29、android中内部存储和外部存储的理解和路径获取" class="headerlink" title="29、android中内部存储和外部存储的理解和路径获取"></a>29、android中内部存储和外部存储的理解和路径获取</h3><p><img src="http://img.shedoor.net/AndroidGu/7.png">  </p>
<h3 id="30、自定义组合控件"><a href="#30、自定义组合控件" class="headerlink" title="30、自定义组合控件"></a>30、自定义组合控件</h3><p>在加载布局的时候要用 <strong>View.inflate(context,R.layout.img_share,this)</strong>;<br>或者 <strong>LayoutInflater.from(context).inflate(R.layout.img_share,this)</strong>;<br>不能用 <strong>LayoutInflater.from(context).inflate(R.layout.img_share,null)</strong>;这样加载不上。</p>
<h3 id="31、foreground-前景色生效"><a href="#31、foreground-前景色生效" class="headerlink" title="31、foreground 前景色生效"></a>31、foreground 前景色生效</h3><p><img src="http://img.shedoor.net/AndroidGu/8.png"></p>
<h3 id="32、添加第三方依赖报错"><a href="#32、添加第三方依赖报错" class="headerlink" title="32、添加第三方依赖报错"></a>32、添加第三方依赖报错</h3><p><img src="http://img.shedoor.net/AndroidGu/9.png"></p>
<p>配置错误原因：1、导包有误。2、少导包。3、重复导包。</p>
<h3 id="33、布局里的ListView-GridView抢占焦点"><a href="#33、布局里的ListView-GridView抢占焦点" class="headerlink" title="33、布局里的ListView|GridView抢占焦点"></a>33、布局里的ListView|GridView抢占焦点</h3><p>Scrollview里嵌套Gridview，Gridview抢焦点问题(显示布局的时候老是先从Gridview的第一个item显示)  </p>
<blockquote>
<p>解决方法：在获取inflate view之后，代码给GridView.setFocusable(false)就可以了  </p>
</blockquote>
<p>这里的listview的item里嵌套了横向滑动的scrollview的gridview，  </p>
<blockquote>
<p>同样的问题，同样的解决方案：在listview的adapter中在加载完item之后对gridview设置setFocusable(false)。<br>这里需要注意的是，是在抢焦点的列表的父容器建立之后就对列表设置取消焦点。  </p>
</blockquote>
<p>例如：<br><strong>在ListView中嵌套GridView中：</strong>  </p>
<pre><code>convertView = LayoutInflater.from(mContext).inflate(R.layout.item_listview_home, null);
viewHolder = new ViewHolder(convertView);
viewHolder.mGridIilh.setFocusable(false);  
</code></pre>
<p><strong>在fragment布局中存在列表抢占焦点：</strong>  </p>
<pre><code>@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;
    View view = inflater.inflate(R.layout.fragment_cheapsale, null);
    ButterKnife.inject(this, view);
    mGridFragmentCheapsale.setFocusable(false);  
</code></pre>
<p><strong>在Activity布局中存在列表抢占焦点：</strong>  </p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) &#123;
super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_sale);
    ButterKnife.inject(this);
    mListviewHome.setFocusable(false);
</code></pre>
<h3 id="34、列表抢占焦点问题"><a href="#34、列表抢占焦点问题" class="headerlink" title="34、列表抢占焦点问题"></a>34、列表抢占焦点问题</h3><p>在gridview和listview初始化数据时自动调用或者我们显示调用notifyDataSetChanged的时候第一个item会被选中并会抢焦点。<br>android4.4在调用notifyDataSetChanged的时候注释掉了判断touchmode的代码，导致一调用notifyDataSetChanged就模拟用户点击了gridview。<br>我们继承gridview或者listview重写里面的isInTouchMode方法：  </p>
<pre><code>[java] view plaincopy
/**
 * 屏蔽android4.4 setAdapter时View抢焦点的BUG
 */  
@Override  
public boolean isInTouchMode() &#123;  
    if(19 == Build.VERSION.SDK_INT)&#123;  
        return !(hasFocus() &amp;&amp; !super.isInTouchMode());  
    &#125;else&#123;  
        return super.isInTouchMode();  
</code></pre>
<h3 id="35、去除Listview滚动背景变黑，item点击默认背景"><a href="#35、去除Listview滚动背景变黑，item点击默认背景" class="headerlink" title="35、去除Listview滚动背景变黑，item点击默认背景"></a>35、去除Listview滚动背景变黑，item点击默认背景</h3><p>listview默认背景和系统窗口一样是透明的，如果给listview加上背景图片，或者背景颜色时，滚动时listview会黑掉，因为滚动时，列表里面的view重绘用的依旧是系统默认的透明色，颜色值为#FF191919<br>解决办法：  </p>
<ul>
<li>调用listview的setCacheColorHint(0)，颜色值设置为0</li>
<li>设置xml文件中listView的属性  </li>
<li>*Android:cacheColorHint=”#00000000”**，滚动时，重绘View的时候就不会有背景颜色。  </li>
<li><em>android:listSelector=”#00000000”</em>*<br>进行上面的设置之后，ListView点击item时就没有任何现象了</li>
</ul>
<h3 id="36-开启Android系统程序设置页面"><a href="#36-开启Android系统程序设置页面" class="headerlink" title="36. 开启Android系统程序设置页面"></a>36. 开启Android系统程序设置页面</h3><pre><code>Intent intent = new Intent();
intent.setClassName(&quot;com.android.settings&quot;,&quot;com.android.settings.ManageApplications&quot;);
intent.setAction(&quot;android.intent.action.MAIN&quot;);
try &#123;
    startActivity(intent);
&#125; catch (Exception e) &#123;
    e.printStackTrace();
&#125;  
</code></pre>
<h3 id="37、禁止EditText自动获取布局焦点"><a href="#37、禁止EditText自动获取布局焦点" class="headerlink" title="37、禁止EditText自动获取布局焦点"></a>37、禁止EditText自动获取布局焦点</h3><p>解决之道：在EditText的父级控件中找一个，设置成  </p>
<pre><code>android:focusable=&quot;true&quot;  
android:focusableInTouchMode=&quot;true&quot;  
</code></pre>
<p>这样，就把EditText默认的行为截断了！</p>
<h3 id="38、RadioButton设置默认选中"><a href="#38、RadioButton设置默认选中" class="headerlink" title="38、RadioButton设置默认选中"></a>38、RadioButton设置默认选中</h3><p>如果RadioGroup中设置默认选中一个RadioButton后,在选择时会选中两个的问题<br><strong>解决方法：</strong><br>不需要设置RadioButton的默认选中, 这样会使RadioButton一直处于选中状态.<br>我们应该给RadioGroup设置选中的RadioButton,<br>也就是说把<strong>radioButton.setCheck(true);</strong><br>更改为<strong>radioGroup.check(radioButton.getId());</strong></p>
<h3 id="39、实现ImageView宽度填满屏幕，高度自适应"><a href="#39、实现ImageView宽度填满屏幕，高度自适应" class="headerlink" title="39、实现ImageView宽度填满屏幕，高度自适应"></a>39、实现ImageView宽度填满屏幕，高度自适应</h3><p><strong>1、自定义ImageView重写View的onMeasure方法</strong>  </p>
<pre><code>public class ResizableImageView extends ImageView &#123;  

    public ResizableImageView(Context context) &#123;  
        super(context);  
    &#125;  

    public ResizableImageView(Context context, AttributeSet attrs) &#123;  
        super(context, attrs);  
    &#125;  

    @Override  
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)&#123;  
        Drawable d = getDrawable();  

        if(d!=null)&#123;  
            // ceil not round - avoid thin vertical gaps along the left/right edges  
            int width = MeasureSpec.getSize(widthMeasureSpec);  
            //高度根据使得图片的宽度充满屏幕计算而得  
            int height = (int) Math.ceil((float) width * (float) d.getIntrinsicHeight() / (float) d.getIntrinsicWidth());  
            setMeasuredDimension(width, height);  
        &#125;else&#123;  
            super.onMeasure(widthMeasureSpec, heightMeasureSpec);  
        &#125;  
    &#125;  

&#125;  
</code></pre>
<p><strong>2、设置ImageView的属性</strong>  </p>
<pre><code>//宽度填满屏幕
android:layout_width=”match_parent”
android:scaleType=”fitXY”
android:layout_height=”wrap_content”
//保持比例，一定要设置
android:adjustViewBounds=”true”
</code></pre>
<h3 id="40、Glide加载网络图片填充到39中的ImageView中"><a href="#40、Glide加载网络图片填充到39中的ImageView中" class="headerlink" title="40、Glide加载网络图片填充到39中的ImageView中"></a>40、Glide加载网络图片填充到39中的ImageView中</h3><p>因为Glide加载图片的规则是根据imageview的大小调整图片。但是ImageView的大小为ImageView宽度填满屏幕，高度自适应的时候，Glide加载的图片就会显示不出来，为此我们选择了一种迂回的方式加载：先请求图片为bitmap，这个时候图片就有一定的尺寸了，再设置到ImageView中就可以自适应了：  </p>
<pre><code>Glide.with(GraphicDetailsFragment.this)
                    .load((new StringBuffer(Const.URL_HEAD).append(mStringList.get(position))).toString())
                    .asBitmap()
                    .into(new SimpleTarget&lt;Bitmap&gt;() &#123;
                        @Override
                        public void onResourceReady(Bitmap resource, GlideAnimation&lt;? super Bitmap&gt; glideAnimation) &#123;
                            viewHolder.mImageView.setImageBitmap(resource);
                        &#125;
                    &#125;);
</code></pre>
<blockquote>
<p>大大小小的坑，无处不在，防不胜防。后续会继续更新这篇博文的。<br>本博客是作者<a href="http://ocnyang.com/">(OCN.Yang)</a>原创<br>转载请标明原地址：<a href=""></a></p>
</blockquote>
]]></content>
      <categories>
        <category>原创</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>原创</tag>
        <tag>Android的那些坑</tag>
      </tags>
  </entry>
  <entry>
    <title>Android教学大纲</title>
    <url>/2016/08/09/AndroidStudy1/</url>
    <content><![CDATA[<h2 id="一、Android学习进度规划："><a href="#一、Android学习进度规划：" class="headerlink" title="一、Android学习进度规划："></a>一、Android学习进度规划：</h2><h3 id="第1周：【UI基础】"><a href="#第1周：【UI基础】" class="headerlink" title="第1周：【UI基础】"></a>第1周：【UI基础】</h3><ul>
<li>第1天： Android环境搭建</li>
<li>第2天： 常用UI布局及主要控件</li>
<li>第3天： 常用UI控件及事件处理</li>
<li>第4天： UI高级控件及Android资源</li>
<li>第5天： Ａctivity生命周期</li>
</ul>
<span id="more"></span>

<blockquote>
<p>【知识点】</p>
</blockquote>
<ol>
<li>Android环境搭建及工程目录介绍（前期使用Eclipse，版本：SDK21及以上版本，四周后逐渐接触Android Studio）</li>
<li>常用UI布局及主要控件</li>
</ol>
<ul>
<li>LinearLayout、RelativeLayout常用属性【重点讲解】</li>
<li>FrameLayout、GridLayout常用属性</li>
<li>TextView、EditText、Button、ImageView、Toast的基本用法</li>
</ul>
<ol start="3">
<li>表单三大UI控件及相应控件的事件处理及部分特殊drawable资源（selector、shape）</li>
</ol>
<ul>
<li>RadioButton及RadioGroup的用法：【重点】单选、监听事件、利用selector实现选中与否、改变默认单选button的显示效果、修改topDrawable</li>
<li>CheckBox的多选效果及监听。利用selector及shape修改多选框的显示效果</li>
</ul>
<ol start="4">
<li>Spinner、AutoCompleteTextView、ScrollView及适配器简介、数组资源</li>
</ol>
<ul>
<li>Spinner的用法</li>
<li>ArrayAdapter适配器的基本用法</li>
<li>数组资源String Array</li>
<li>AutoCompleteTextView、ScrollView的基本用法</li>
<li>ProgressBar、SeekBar、RatingBar的基本用法及美化</li>
</ul>
<ol start="5">
<li>Ａctivity生命周期</li>
</ol>
<h3 id="第2周："><a href="#第2周：" class="headerlink" title="第2周："></a>第2周：</h3><ul>
<li>第6天： Activity管理及Intent七大属性</li>
<li>第7天： AsyncTask异步任务</li>
<li>第8天： ListView基本用法</li>
<li>第9天： ListView分页及优化</li>
<li>第10天： 图文混排+GridView</li>
</ul>
<blockquote>
<p>【知识点】</p>
</blockquote>
<ol>
<li>Activity页面跳转、生命周期及Intent七大属性</li>
<li>AsyncTask异步任务</li>
<li>ListView基本用法及适配器</li>
<li>ListView分页及优化 + item多种布局的ListView</li>
<li>GridView图文混排</li>
</ol>
<h3 id="第3周："><a href="#第3周：" class="headerlink" title="第3周："></a>第3周：</h3><ul>
<li>第11天： Menu+Dialog+Toast</li>
<li>第12天： Fragment</li>
<li>第13天： SharedPreferences、SDCard及网络存储 + HttpURLConnection实现文件上传</li>
<li>第14天： SQLite数据库 + WebView</li>
<li>第15天： ContentProvider之ContentResolver</li>
</ul>
<blockquote>
<p>【知识点】</p>
</blockquote>
<ol>
<li>Menu（选项菜单、上下文菜单、PopupWindow自定义菜单）+Dialog+Toast</li>
<li>Fragment基本用法、生命周期、Fragment间传值</li>
<li>SharedPreferences、内部文件存储及外部文件存储SDCard</li>
<li>SQLite数据库 + WebView</li>
<li>ContentProvider之ContentResolver</li>
</ol>
<h3 id="第4周："><a href="#第4周：" class="headerlink" title="第4周："></a>第4周：</h3><ul>
<li>第16天： 自定义ContentProvider</li>
<li>第17天： Loader异步装载</li>
<li>第18天： Handler与多线程</li>
<li>第19天： ActionBar + LruCache + Bitmap二次采样</li>
<li>第20天： ViewPager</li>
</ul>
<blockquote>
<p>【知识点】</p>
</blockquote>
<ol>
<li>自定义ContentProvider</li>
<li>Loader异步装载器（CursorLoader及AsyncTaskLoader）</li>
<li>Handler与多线程及源码分析</li>
<li>ActionBar + 图片缓存（图片三层缓存策略、LruCache、Bitmap二次采样生成缩略图）</li>
<li>ViewPager（制作欢迎引导页及加载网络图片的ViewPager及自动播放的ViewPager）</li>
</ol>
<h3 id="第5周："><a href="#第5周：" class="headerlink" title="第5周："></a>第5周：</h3><ul>
<li>第21天： TAB书签导航</li>
<li>第22天： BroadcastReceiver + Notification</li>
<li>第23天： Service1</li>
<li>第24天： Service2</li>
<li>第25天： 百度地图1</li>
</ul>
<blockquote>
<p>【知识点】</p>
</blockquote>
<ol>
<li>TAB书签导航制作</li>
</ol>
<ul>
<li>FragmentTabHost制作TAB书签导航</li>
<li>Fragment + RadioGroup制作TAB书签导航  </li>
<li>Fragment + ViewPager  +  RadioGroup制作TAB书签导航</li>
<li>Fragment + 带滑动导航条的ViewPager 制作TAB书签导航</li>
<li>Fragment + ViewPager +  HorizontalScrollView自定义滑动导航条</li>
<li>Fragment + ActionBar制作TAB书签导航</li>
<li>Fragment + ActionBar + ViewPager制作TAB书签导航</li>
</ul>
<ol start="2">
<li>BroadcastReceiver + 自定义广播 + Notification</li>
<li>Service（一）（服务的概念及分类、被启动服务和被绑定服务实现音乐播放的用法）</li>
<li>Service（二）（IntentService的用法及DownloadManager实现大文件下载）</li>
<li>Service（三）（远程服务：AIDL及Messenger）</li>
</ol>
<h3 id="第6周："><a href="#第6周：" class="headerlink" title="第6周："></a>第6周：</h3><ul>
<li>第26天： 百度地图 2</li>
<li>第27天： 动画资源 + 样式、主题及drawable资源</li>
<li>第28天： 屏幕适配</li>
<li>第29天： 自定义View(上)</li>
<li>第30天： 自定义View(下)</li>
</ul>
<blockquote>
<p>【知识点】</p>
</blockquote>
<ol>
<li>百度地图基本用法</li>
<li>动画资源（帧动画、补间动画、属性动画基本用法）</li>
<li>屏幕适配及UI美化（样式、主题及特殊的drawable资源：selector、shape、level-list、layer-list等）</li>
<li>自定义View(继承于EditText、ListView)</li>
<li>自定义View(继承于View、继承于ViewGroup)</li>
</ol>
<h3 id="第8周："><a href="#第8周：" class="headerlink" title="第8周："></a>第8周：</h3><ul>
<li>第36天： Volley框架</li>
<li>第37天： UIL框架</li>
<li>第38天：  xUtils框架</li>
<li>第39天：SlidingMenu及DrawerLayout + PullToRefresh等其他第三方技术</li>
<li>第40天： 事件分发及消费机制</li>
</ul>
<blockquote>
<p>【知识点】</p>
</blockquote>
<ol>
<li>Volley框架</li>
<li>UIL（Universal-Image-Loader）框架</li>
<li>xUtils框架(ViewUtils \ HttpUtils \ BitmapUtils \ DBUtils)</li>
<li>PullToRefresh（下拉刷新）+ 瀑布流及常用第三方菜单技术：SlidingMenu（侧滑菜单）、DrawerLayout （抽屉）、ResideMenu（驻留菜单）、SatelliteMenu（卫星菜单）</li>
<li>事件分发及消费机制 （TouchEvent）</li>
</ol>
<h3 id="第9周："><a href="#第9周：" class="headerlink" title="第9周："></a>第9周：</h3><ul>
<li>第41天：Gesture手势及 SurfaceView</li>
<li>第42天：播放器及摄像头</li>
<li>第43天： RecyclerView、CardView</li>
<li>第44天：传感器、WiFi及蓝牙通讯</li>
<li>第45天：ShareSDK一键分享及第三方登录 + 第三方支付 + JPush推送</li>
</ul>
<blockquote>
<p>【知识点】</p>
</blockquote>
<ol>
<li>Gesture手势 + SurfaceView</li>
<li>播放器及摄像头(音乐播放、视频播放VideoView、摄像头)</li>
<li>RecyclerView、CardView</li>
<li>传感器、水印、QRCode二维码</li>
<li>WiFi及蓝牙通讯、ShareSDK一键分享及第三方登录 + Alipay第三方支付 + JPush推送</li>
</ol>
<h2 id="二、常用框架技术"><a href="#二、常用框架技术" class="headerlink" title="二、常用框架技术"></a>二、常用框架技术</h2><ol>
<li>网络访问框架</li>
</ol>
<ul>
<li>okHttp框架、</li>
<li>Retrofit（网络访问）</li>
<li>AsyncHttpClient(【了解】)</li>
<li>Volley框架 （StringRequest、JsonObjectRequest、JsonArrayRequest、ImageRequest、NetworkImageView）</li>
</ul>
<ol start="2">
<li>反转注入框架</li>
</ol>
<ul>
<li>ButterKnife、  </li>
<li>Android Annotations</li>
<li>xUtils框架(ViewUtils \ HttpUtils \ BitmapUtils \ DBUtils)</li>
</ul>
<ol start="3">
<li>图片异步加载框架</li>
</ol>
<ul>
<li>Picasso、</li>
<li>Fresco、</li>
<li>Glide、</li>
<li>UIL（Universal-Image-Loader）框架</li>
</ul>
<ol start="4">
<li>数据库ORM</li>
</ol>
<ul>
<li>ORMLite、</li>
<li>GreenDao、</li>
<li>ActiveAndroid</li>
</ul>
<h2 id="三、考核内容"><a href="#三、考核内容" class="headerlink" title="三、考核内容"></a>三、考核内容</h2><h3 id="必选："><a href="#必选：" class="headerlink" title="必选："></a>必选：</h3><ol>
<li>ListView、GridView、ScrollView、WebView</li>
<li>assets及各种资源（selector、raw、string、color、dimens、style、array，必须采用软编码编程风格）</li>
<li>动画资源（帧动画、补间动画）</li>
<li>上下文菜单、PopupWindow、Dialog</li>
<li>数据存储：SharedPreferences、内部文件存储、SD卡存储、SQLite数据库操作</li>
<li>ContentResolver</li>
<li>CursorLoader异步装载</li>
<li>Handler与多线程或AsyncTask</li>
<li>图片缓存</li>
<li>屏幕自适应、版本自适应</li>
<li>自定义View（至少三个）</li>
<li>TAB导航（ViewPager、Fragment）</li>
<li>广播、服务、通知</li>
<li>DrawerLayout、SlidingMenu或其他第三方菜单</li>
<li>PullToRefresh</li>
</ol>
<h3 id="项目阶段必选："><a href="#项目阶段必选：" class="headerlink" title="项目阶段必选："></a>项目阶段必选：</h3><ol start="16">
<li>TouchEvent及手势</li>
<li>Volley、xUtils、UIL框架或其他类似网络访问及异步加载图片的框架</li>
<li>瀑布流</li>
<li>混淆打包</li>
</ol>
<h3 id="可选："><a href="#可选：" class="headerlink" title="可选："></a>可选：</h3><ol>
<li>SurfaceView</li>
<li>音乐播放器或视频播放（自定义MediaController）</li>
<li>二维码扫描及生成</li>
<li>RecyclerView、CardView</li>
<li>传感器</li>
<li>ShareSDK一键分享及第三方登录</li>
<li>JPush或其他推送技术</li>
<li>Alipay或其他支付技术</li>
<li>WiFi或蓝牙通讯</li>
<li>文件加密及解密</li>
<li>地图</li>
</ol>
]]></content>
      <categories>
        <category>Android教程系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android教程系列</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义 View：用贝塞尔曲线绘制酷炫轮廓背景</title>
    <url>/2017/09/01/ContourView/</url>
    <content><![CDATA[<p><img src="http://img.shedoor.net/github/contourview/reference.png" alt="ContourView">  </p>
<p>在闲逛一个图片社区时看到这张图片，个人对炫酷的东西比较敏感（视觉肤浅），本来想下载一下这个 App 看一下实际效果，可是没找到。心有不甘，于是分析了一下，感觉实现起来不会太难，自己也花点时间实现了效果，发布了一个库。  </p>
<span id="more"></span>

<p><strong>Github地址：</strong><a href="https://github.com/OCNYang/ContourView">https://github.com/OCNYang/ContourView</a>  </p>
<p>今天就借助这个开源控件，来为大家梳理一下自定义 View 的整个流程：  </p>
<ol>
<li>分析需求、功能，确定实现方法；</li>
<li>总结所需的参数属性以满足可定制性，较明确的属性归纳为自定义属性，不适合自定义属性的（比如传入数据，对象等）提供方法来设置；</li>
<li>有时自定义 View 会提供一种或几种默认及内置的样式，（这时可以根据内置的样式种类补充到自定义属性中），同时分析，使用内置样式或用户定制拓展时的流程；</li>
<li>开始根据分析，按流程依次重写： <strong><code>构造函数（获取自定义属性，设置画笔等）</code></strong> –&gt; <strong><code>onMeasure()(测量大小)</code></strong> –&gt; <strong><code>onSizeChanged()(确定大小，一般我们在这里获取大小)</code></strong> –&gt; <strong><code>（onLayout()自定义View，因为没有子控件，这一步是不需要的）</code></strong> –&gt; <strong><code>onDraw()(按照需求和根据属性绘制实际内容)</code></strong> –&gt; <strong><code>其他</code></strong></li>
<li>如果有事件的需求，添加事件相关逻辑。</li>
</ol>
<p>那么现在我们就根据上面这个流程一步步来实现 ContourView。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img src="http://img.shedoor.net/github/contourview/fenxi.png" alt="分析图">  </p>
<p>根据上面的分析，实现的思路大概都有了。那么我们就开始寻找具体实现方法。<br>首先，我们选用三阶贝塞尔曲线，我们都知道三阶曲线的计算公式是：  </p>
<pre><code>path.moveTo(start.x, start.y);
path.cubicTo(control1.x, control1.y, control2.x,control2.y, end.x, end.y);
</code></pre>
<p><img src="http://img.shedoor.net/github/contourview/bse3.gif" alt="三阶贝塞尔曲线">  </p>
<p>也就是说绘制一段曲线，我们需要知道两个锚点的坐标以及两个控制点的坐标，为了保证曲线的弯曲度能够达到理想的状态，控制点的坐标也不能是随意取的，这就要求我们必须通过一种计算方法合理的得出控制点的坐标。Google 了一下，发现先驱们已经找到了很多种方法供我们选择。  </p>
<p>最终经过对比我们选用了这样一种方法：  </p>
<p><img src="http://img.shedoor.net/github/contourview/bsejs.png" alt="控制点计算方法">  </p>
<p>这种方法大概的形式如上图，利用锚点集合，连续的4个锚点坐标Pi-1、Pi、Pi+1、Pi+2，通过具体公式来计算出中间两个锚点之间曲线的两个控制点坐标。  </p>
<blockquote>
<p>详细的计算方法介绍请看 ContourView 的 WiKi：<br><strong><a href="https://github.com/OCNYang/ContourView/wiki/B%C3%A9zier-%E6%B1%82%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%E6%8E%A7%E5%88%B6%E7%82%B9">Bézier-求贝塞尔曲线控制点</a></strong>  </p>
</blockquote>
<h2 id="归纳自定义属性"><a href="#归纳自定义属性" class="headerlink" title="归纳自定义属性"></a>归纳自定义属性</h2><p>通过上面的分析，其实我们大概能总结出需要自定义的属性有哪些了。这里不着急，我们先总结一下自定义属性相关的内容和步骤？  </p>
<p><strong>1. 创建自定义属性文件</strong><br>在 res/values/ 下新建 attrs.xml 文件（默认新建项目没有这个文件）。文件内容类似如下：  </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;attr name=&quot;custom_color&quot; format=&quot;color&quot;/&gt;

    &lt;declare-styleable name=&quot;ContourView&quot;&gt;
        &lt;attr name=&quot;shader_color&quot; format=&quot;color&quot;/&gt;
        &lt;attr name=&quot;smoothness&quot; format=&quot;float&quot;/&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;
</code></pre>
<p>其中 attr 和 declare-styleable 节点分别代表的意思如下：  </p>
<p><strong>attr：</strong> 定义了一个属性，属性名为 custom_color 这个是可以随意起的，但是要注意不要和其他控件所冲突， format 所定义的是属性的格式，其中格式又分为好多种，下面会细说，这里定义的是颜色 color。  </p>
<p><strong>declare-styleable：</strong>定义了一个属性组，在里面我们可以单独写 attr 属性，也可以引用直接在 resources 下定义的 attr，其中的区别就是引用的不用写 format。  </p>
<p>需要注意的是，attr 并不依赖与 declare-styleable，declare-styleable 只是方便了 attr 的使用，使属性的使用更加明确。两者在代码中的获取方式并不相同，下面会细说。  </p>
<p>在实际开发中，我们一般是采用 declare-styleable 方式，直接定义一组自己所编写的自定义控件需要用到的属性。  </p>
<p><strong>2. 自定义属性的可以设置哪些属性</strong>  </p>
<p>我们根据需要可以设置的自定义属性的格式一共有一下几种：  </p>
<table>
<thead>
<tr>
<th align="center">format=”格式”</th>
<th>说明</th>
<th>app:myattr=”使用值”</th>
</tr>
</thead>
<tbody><tr>
<td align="center">reference</td>
<td>参考某一资源ID</td>
<td>“@drawable/图片ID”</td>
</tr>
<tr>
<td align="center">color</td>
<td>颜色值</td>
<td>“#FFFFFFFF” or “@color/颜色ID”</td>
</tr>
<tr>
<td align="center">boolean</td>
<td>布尔值</td>
<td>“true” or “false”</td>
</tr>
<tr>
<td align="center">dimension</td>
<td>尺寸值</td>
<td>“0dp”</td>
</tr>
<tr>
<td align="center">float</td>
<td>浮点型</td>
<td>“1.2”</td>
</tr>
<tr>
<td align="center">integer</td>
<td>整型值</td>
<td>“10”</td>
</tr>
<tr>
<td align="center">fraction</td>
<td>百分数值</td>
<td>“50%”</td>
</tr>
<tr>
<td align="center">string</td>
<td>字符串</td>
<td>“OCN.Yang”</td>
</tr>
<tr>
<td align="center">enum</td>
<td>枚举值（详见下）</td>
<td>“自定义类型名称”</td>
</tr>
<tr>
<td align="center">flag</td>
<td>位或运算</td>
<td>“center &#124; bottom”</td>
</tr>
</tbody></table>
<blockquote>
<p>附：<br><strong>enum</strong> 枚举型定义：  </p>
</blockquote>
<pre><code>&lt;attr name=&quot;handsomeBoy&quot;&gt;
    &lt;enum name=&quot;OCNYang&quot; value=&quot;0x01&quot;/&gt;
    &lt;enum name=&quot;TFBOYS&quot; value=&quot;0x10&quot;/&gt;
&lt;/attr&gt;
</code></pre>
<blockquote>
<p>enum 使用：  </p>
</blockquote>
<pre><code>app:handsomeBoy=&quot;OCNYang&quot;
</code></pre>
<blockquote>
<hr>
<p><strong>flag</strong> 定义：  </p>
</blockquote>
<pre><code>&lt;attr name=&quot;gravity&quot;&gt;
    &lt;flag name=&quot;top&quot; value=&quot;0&quot;/&gt;
    &lt;flag name=&quot;center&quot; value=&quot;1&quot;/&gt;
    &lt;flag name=&quot;bottom&quot; value=&quot;2&quot;/&gt;
&lt;/attr&gt;
</code></pre>
<blockquote>
<p>flag 使用：  </p>
</blockquote>
<pre><code>app:gravity=&quot;center|bottom&quot;
</code></pre>
<blockquote>
<hr>
<p><strong>混搭使用</strong></p>
</blockquote>
<pre><code>&lt;attr name=&quot;background&quot; format=&quot;reference|color&quot;/&gt;
</code></pre>
<blockquote>
<p> 这样，你传入资源ID或颜色值都是可以的了。</p>
</blockquote>
<p><strong>3. 获取自定义属性</strong>  </p>
<p>那怎么获取这些自定义的属性呢，只需要在自定义 View 的构造方法（两个参数或两个以上的参数）里通过一下方式就能获取到了：  </p>
<pre><code>public ContourView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;
    super(context, attrs, defStyleAttr);

    TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.ContourView);
    //注意：获取时自定义的属性名有变动，例如：定义名：contour_style -&gt; 获取名：ContourView_contour_style（即：自定义属性组名_属性名）
    mStyle = typedArray.getInt(R.styleable.ContourView_contour_style, STYLE_SAND);
&#125;
</code></pre>
<p>当然获取时，不同格式的属性需要通过 TypedArray 对应的不同的方法获取，那 TypedArray 都有哪些获取方法呢？如下图：  </p>
<p><img src="http://img.shedoor.net/github/contourview/typedArray.png" alt="TypedArray 的方法有哪些">  </p>
<p>通过方法名称，相信你能很轻易的知道，需要哪个对应方法获取了。  </p>
<blockquote>
<p>如果你想更详细的了解每个方法的详细介绍，可以点击下面链接查看：<br><a href="https://developer.android.com/reference/android/content/res/TypedArray.html">https://developer.android.com/reference/android/content/res/TypedArray.html</a><br>另外，比较特殊的 enum 的获取方法：<br>由于 enum 的 value 值只能设置 int 型，所以，获取enum的方式是 <code>getInt()</code>。</p>
</blockquote>
<p>好了，关于自定义属性的介绍大概就是这么多内容了，那么回到原题，我们的 ContourView 需要哪几种 自定义属性呢？其实通过分析模块中我们就基本知道我们需要的属性有哪些了：  </p>
<ul>
<li>内置轮廓样式： enum 类型，内置多少个 enum 就有多少类型；</li>
<li>绘制颜色：纯色绘制时，我们需要一个颜色值，Color 属性</li>
<li>Shader 相关：<ol>
<li>采用哪种 Shader，enum 类型，有RadialGradient、SweepGradient、LinearGradient；</li>
<li>Shader 的颜色，Color 类型，需要两个一个startColor，一个endColor；</li>
<li>Shader 填充的控制，enum 类型，我们提供几种填充的方向，比如左上角到右下角，从上到下，然后我们再通过这个方向和传入的秒点集来动态计算起点和终点的坐标</li>
</ol>
</li>
</ul>
<p>具体如下：  </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;declare-styleable name=&quot;ContourView&quot;&gt;
        &lt;attr name=&quot;shader_mode&quot;&gt;
            &lt;enum name=&quot;RadialGradient&quot; value=&quot;0x01&quot;/&gt;
            &lt;enum name=&quot;SweepGradient&quot; value=&quot;0x02&quot;/&gt;
            &lt;enum name=&quot;LinearGradient&quot; value=&quot;0x03&quot;/&gt;
        &lt;/attr&gt;
        &lt;attr name=&quot;shader_startcolor&quot; format=&quot;color&quot;/&gt;
        &lt;attr name=&quot;shader_endcolor&quot; format=&quot;color&quot;/&gt;
        &lt;attr name=&quot;shader_style&quot;&gt;
            &lt;enum name=&quot;LeftToBottom&quot; value=&quot;0x00&quot;/&gt;
            &lt;enum name=&quot;RightToBottom&quot; value=&quot;0x11&quot;/&gt;
            &lt;enum name=&quot;TopToBottom&quot; value=&quot;0x12&quot;/&gt;
            &lt;enum name=&quot;Center&quot; value=&quot;0x13&quot;/&gt;
        &lt;/attr&gt;
        &lt;attr name=&quot;contour_style&quot;&gt;
            &lt;enum name=&quot;Beach&quot; value=&quot;0x23&quot;/&gt;
            &lt;enum name=&quot;Ripples&quot; value=&quot;0x22&quot;/&gt;
            &lt;enum name=&quot;Clouds&quot; value=&quot;0x21&quot;/&gt;
            &lt;enum name=&quot;Sand&quot; value=&quot;0x00&quot;/&gt;
            &lt;enum name=&quot;Shell&quot; value=&quot;0x25&quot;/&gt;
        &lt;/attr&gt;
        &lt;attr name=&quot;shader_color&quot; format=&quot;color&quot;/&gt;
        &lt;!--弯曲系数，在通过贝塞尔曲线绘制曲线时，来控制弯曲度--&gt;
        &lt;attr name=&quot;smoothness&quot; format=&quot;float&quot;/&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;
</code></pre>
<h2 id="内置样式"><a href="#内置样式" class="headerlink" title="内置样式"></a>内置样式</h2><p>既然自定义 View，那我们一定会为它提供一种或几种内置好的样式呀。这样别人在偷懒不想自己定制样式时，可以也有不错的显示效果呀！<br>通过上面知道，ContourView 的轮廓样式主要是通过给出的锚点集控制的，所有的锚点围成的闭合曲线就是轮廓的大概样式了。<br>所以，这里我们想内置几种样式，就等于内置几个锚点集就行了，这里的我们内置的锚点坐标为了使得不同大小显示效果相同，我们先在 onSizeChanged() 获得了 View 的宽高，然后根据宽高按照百分比来设置坐标。  </p>
<p>设置的内置轮廓有以下几种（丑爆了），只是轮廓，颜色是自己设置的：  </p>
<table>
<thead>
<tr>
<th align="center">样式（contuor_style）</th>
<th align="center">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Sand(默认)</td>
<td align="center"><img src="http://img.shedoor.net/github/contourview/sand.png?imageView2/2/w/400" alt="sand"></td>
</tr>
<tr>
<td align="center">Clouds</td>
<td align="center"><img src="http://img.shedoor.net/github/contourview/clouds.png?imageView2/2/w/400" alt="clouds"></td>
</tr>
<tr>
<td align="center">Beach</td>
<td align="center"><img src="http://img.shedoor.net/github/contourview/beach.png?imageView2/2/w/400" alt="beach"></td>
</tr>
<tr>
<td align="center">Ripples</td>
<td align="center"><img src="http://img.shedoor.net/github/contourview/ripples.png?imageView2/2/w/400" alt="ripples"></td>
</tr>
<tr>
<td align="center">Shell</td>
<td align="center"><img src="http://img.shedoor.net/github/contourview/shell.png?imageView2/2/w/400" alt="shell"></td>
</tr>
</tbody></table>
<h2 id="重写各方法"><a href="#重写各方法" class="headerlink" title="重写各方法"></a>重写各方法</h2><p>关于自定义 View 重写各方法的介绍，网上已经有太多太多，这里就不再啰嗦了。  </p>
<blockquote>
<p>这里推荐一个关于自定义 View 尤其关于绘制方面讲解特别详细的系列博客：<br><a href="https://github.com/GcsSloop/AndroidNote">https://github.com/GcsSloop/AndroidNote</a><br>另外厚脸皮的放上一篇自己的关于讲解“自定义组合控件”的博客地址：<br><a href="http://www.jianshu.com/p/4bbc967214c9">http://www.jianshu.com/p/4bbc967214c9</a>  </p>
</blockquote>
<p>我们知道，在自定义 View 时，必须要有构造函数的，对于4个构造函数，有时可能大家不确定到底该重写哪个，也不知道每个构造函数有什么区别，这里对常用的做法做下说明。  </p>
<pre><code>//在代码中直接 new 一个 Custom View 实例时,会调用第一个构造函数.这个没有任何争议.
public View(Context context);  
//在 xml 布局文件中使用自定义 View 时,会调用第二个构造函数.这个也没有争议.
public View(Context context, AttributeSet attrs);  
//关于这个构造函数的调用，网上真是众说纷纭，我也不说哪种说法正确，下面提供详解
public View(Context context, AttributeSet attrs, int defStyle);
//4个参数的构造函数这里不做考虑
</code></pre>
<p>关于内部这4个构造函数是怎么调用的，这里直接放源码图片，自己一目了然：  </p>
<p><img src="http://img.shedoor.net/github/contourview/myview.png" alt="View 源码">  </p>
<p>大家在自定义 View 时，如果没有特别的需求，只要重写前两个构造函数就可以了，我习惯性的写成下面的形式：  </p>
<pre><code>public class MyView extends View &#123;

    public MyView(Context context) &#123;
        this(context, null);
    &#125;

    public MyView(Context context, AttributeSet attrs) &#123;
        this(context, attrs, 0);
    &#125;

    public MyView(Context context, AttributeSet attrs, int defStyleAttr) &#123;
        super(context, attrs, defStyleAttr);
        //初始化画笔，做一些属性的默认赋值等；
        //获取自定义的属性等；
    &#125;
&#125;
</code></pre>
<p>那，说了这么多还是没有提第3个参数到底是干什么的有什么用呀，这里我就不再为大家详细讲解了，这里找到了一片文章，讲解了第3个参数在什么时候怎么使用，大家可以看一下：  </p>
<p><a href="http://www.cnblogs.com/angeldevil/p/3479431.html">http://www.cnblogs.com/angeldevil/p/3479431.html</a>  </p>
<p>回归到 ContourView，其实 ContourView 内部很简单，只对 onDraw() 进行了重写，毕竟 ContourView 的主要部分就是绘制。绘制的逻辑，就是遍历锚点集，然后利用上面 WiKi 里提到的公式求出各段曲线的控制点，然后用三阶贝塞尔曲线画出路径。当遍历完锚点集时，闭合曲线的轮廓基本上就得到了，然后就用Shader对路径进行绘制就行。  </p>
<p>好了，本次的梳理内容就到这了，感兴趣的可以查看 ContourView 的源码进行分析，同时 ContourView 的这种背景效果还是不错的，需要的时候大家真的可以用到呢!  </p>
<p><strong>ContourView GitHub:<a href="https://github.com/OCNYang/ContourView">https://github.com/OCNYang/ContourView</a></strong>   </p>
<blockquote>
<p>如果大家想看一些高级的自定义 View 的例子可以查看上次开源的 App 的天气模块，其中的天气页面以及天气折线图等等控件都是通过自定义 ViewGroup 或自定义 View 实现的。地址是:<br>Qbox Github:<a href="https://github.com/OCNYang/QBox">https://github.com/OCNYang/QBox</a>  </p>
</blockquote>
]]></content>
      <categories>
        <category>Android 教程系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>自定义 View</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义view详解</title>
    <url>/2016/08/10/CustomView/</url>
    <content><![CDATA[<blockquote>
<p>摘录来源：<a href="http://android.jobbole.com/83835/">伯乐在线专栏作者 - 邵辉|CRR</a>  </p>
</blockquote>
<p>对于我这样一个Android初级开发者来说，自定义View一直是一个遥不可及的东西，每次看到别人做的特别漂亮的控件，自己心里那个痒痒啊，可是又生性懒惰，自己不肯努力去看书，只能望而兴叹，每次做需求用到自定义控件，就直接去Github上找，找到合适的就用，找不到合适的，凑合也用，反正从来没想过要自己来做这样的东西，可是毕业以后到了新公司，为了自己的荣誉，这次不得不硬着头皮自己来了，一个月的紧张开发过后，回头再看，自定义控件也无非那么回事，只要记得几个要领，几乎是手到擒来。</p>
<span id="more"></span>

<h3 id="从继承开始"><a href="#从继承开始" class="headerlink" title="从继承开始"></a>从继承开始</h3><p>懂点面向对象语言知识的都知道：封装，继承和多态，这是面向对象的三个基本特征，所以在自定义View的时候，最简单的方法就是继承现有的View   </p>
<pre><code>public class SketchView extends View&#123;  
    public SketchView(Context context) &#123;
        super(context);
    &#125;
    public SketchView(Context context, AttributeSet attrs) &#123;
        super(context, attrs);
    &#125;



    public SketchView(Context context, AttributeSet attrs, int defStyleAttr) &#123;
        super(context, attrs, defStyleAttr);
    &#125;
&#125;
</code></pre>
<p>通过上面这段代码，我定义了一个SketchView，继承自View对象，并且复写了它的三个构造方法，我主要来分析一下这三个构造方法：  </p>
<ul>
<li><p>第一个构造方法就是我们普通在代码中新建一个view用到的方法，例如  </p>
<pre><code>  SketchView sketchView = new SketchView(this);
</code></pre>
</li>
</ul>
<p>就这样，一个自定义的view就被新建出来了，然后可以根据需求添加到布局里</p>
<ul>
<li><p>第二个构造方法就是我们一般在xml文件里添加一个view  </p>
<pre><code>  &lt;me.shaohui.androidpractise.widget.SketchView

     android:layout_width=&quot;match_parent&quot;

     android:layout_height=&quot;match_parent&quot;

     android:layout_marginRight=&quot;16dp&quot;

     android:layout_marginTop=&quot;16dp&quot; /&gt;
</code></pre>
</li>
</ul>
<ul>
<li>这样，我们就把一个SketchView添加到布局文件里，并且加了一些布局属性，宽高属性以及margin属性，这些属性会存放在第二个构造函数的AttributeSet参数里</li>
</ul>
<ul>
<li>第三个构造函数比第二个构造函数多了一个int型的值，名字叫defStyleAttr，从名称上判断，这是一个关于自定义属性的参数，实际上我们的猜测也是正确的，第三个构造函数不会被系统默认调用，而是需要我们自己去显式调用，比如在第二个构造函数里调用调用第三个函数，并将第三个参数设为0。</li>
</ul>
<blockquote>
<p>关于第三个参数defStyleAttr,其实也可以拿出来说一整篇文章，有想详细了解的读者可以去看下本篇文章最后的第三个参考链接，我在这里只是简单的说一下：defStyleAttr指定的是在Theme style定义的一个attr，它的类型是reference,主要生效在obtainStyledAttributes方法里，obtainStyledAttributes方法有四个参数，第三个参数是defStyleAttr，第四个参数是自己指定的一个style，当且仅当defStyleAttr为0或者在Theme中找不到defStyleAttr指定的属性时，第四个参数才会生效，这些指的都是默认属性，当在xml里面定义的，就以在xml文件里指定的为准，所以优先级大概是：xml&gt;style&gt;defStyleAttr&gt;defStyleRes&gt;Theme指定，当defStyleAttr为0时，就跳过defStyleAttr指定的reference，所以一般用0就能满足一些基本开发。</p>
</blockquote>
<h3 id="Measure-gt-Layout-gt-Draw"><a href="#Measure-gt-Layout-gt-Draw" class="headerlink" title="Measure-&gt;Layout-&gt;Draw"></a>Measure-&gt;Layout-&gt;Draw</h3><p>在学会如何写一个自定义控件之前，了解一个控件的绘制流程是必要的，在Android里，一个view的绘制流程包括：Measure，Layout和Draw，通过onMeasure知道一个view要占界面的大小，然后通过onLayout知道这个控件应该放在哪个位置，最后通过onDraw方法将这个控件绘制出来，然后才能展现在用户面前，下面我将挨个分析一下这三个方法的作用。</p>
<ul>
<li>onMeasure 测量，通过测量知道一个一个view要占的大小，方法参数是两个int型的值，我们都知道，在java中，int型由4个字节（32bit）组成，在MeasureSpce中，用前两位表示mode，用后30位表示size</li>
</ul>
<pre><code>    @Override  
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;

    int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    int widthSize = MeasureSpec.getSize(widthMeasureSpec);
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    int heightSize = MeasureSpec.getSize(heightMeasureSpec);
    int measuredHeight, measuredWidth;
    if (widthMode == MeasureSpec.EXACTLY) &#123;
        measuredWidth = widthSize;
    &#125; else &#123;
        measuredWidth = SIZE;
    &#125;
    if (heightMode == MeasureSpec.EXACTLY) &#123;

        measuredHeight = heightSize;

    &#125; else &#123;

        measuredHeight = SIZE;

    &#125;
    setMeasuredDimension(measuredWidth, measuredHeight);

    &#125;
</code></pre>
<p>MeasureSpce的mode有三种：EXACTLY, AT_MOST，UNSPECIFIED，除却UNSPECIFIED不谈，其他两种mode：当父布局是EXACTLY时，子控件确定大小或者match_parent，mode都是EXACTLY，子控件是wrap_content时，mode为AT_MOST；当父布局是AT_MOST时，子控件确定大小，mode为EXACTLY，子控件wrap_content或者match_parent时，mode为AT_MOST。所以在确定控件大小时，需要判断MeasureSpec的mode，不能直接用MeasureSpec的size。在进行一些逻辑处理以后，调用setMeasureDimension()方法，将测量得到的宽高传进去供layout使用。  </p>
<p><img src="http://img.shedoor.net/myview1.png">  </p>
<blockquote>
<p>需要明白的一点是 ,测量所得的宽高不一定是最后展示的宽高，最后宽高确定是在onLayout方法里，layou（left，top，right，bottom），不过一般都是一样的。</p>
</blockquote>
<ul>
<li>onLayout 实际上，我在自定义SketchView的时候是没有重写onLayout方法的，因为SketchView只是一个单纯的view，它不是一个view容器，没有子view，而onLayout方法里主要是具体摆放子view的位置，水平摆放或者垂直摆放，所以在单纯的自定义view是不需要重写onLayout方法，不过需要注意的一点是，子view的margin属性是否生效就要看parent是否在自身的onLayout方法进行处理，而view得padding属性是在onDraw方法中生效的。</li>
</ul>
<p>其实在onLayout方法里有一个属性我一直关注并且没有弄得很明白，就是第一个参数boolean:changed，标示这个view的大小是否发生改变，后续了解到，会回来补坑。</p>
<ul>
<li>onDraw 终于说到了重头戏，一般自定义控件耗费心思最多的就是这个方法了，需要在这个方法里，用Paint在Canvas上画出你想要的图案，这样一个自定义view才算结束。下面会详细讲如何在画布上画出自己想要的图案。</li>
</ul>
<blockquote>
<p>关于onDraw方法，在补充一句，如果是直接继承的View，那么在重写onDraw的方法是时候完全可以把super.ondraw(canvas)删掉，因为它的默认实现是空。</p>
</blockquote>
<h3 id="得到一个正方形的View"><a href="#得到一个正方形的View" class="headerlink" title="得到一个正方形的View"></a>得到一个正方形的View</h3><p>上一部分主要说了一下，view的绘制流程，从这三个方法中，我们可以知道如何测量一个控件，如何摆放控件的子元素，如何绘制图案，下面我说一下自己通过onMeasure学到的一点小技巧。</p>
<p>在日常开发中，我们偶尔会需要一个正方形的imageView，一般都是通过指定宽高，但是当宽高不确定时，我们就只能寄希望于Android原声支持定义view的比例，但是现实是残酷的，系统好像是没有提供类似属性的，所以我们就只能自己去实现，其实自己写起来也特别的简单，只需要改一个参数就OK了，  </p>
<pre><code>@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;
    super.onMeasure(widthMeasureSpec, widthMeasureSpec);
   &#125;
</code></pre>
<p>不仔细观察是看不出来其中的奥妙的，虽然这里复写了view的onMeasure，但是貌似没有做任何处理，直接调用了super方法，但是仔细观察的话就会发现，在调用super方法的时候，第二个参数变了，本来应该是heightMeasureSpec却换成了widthMeasureSpec，这样view的高度就是view的宽度，一个SquareView就实现了，甚至如果通过自定义属性实现一个自定义比例view。</p>
<h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p>自定义view没有自定义属性怎么得了，要给view支持自定义属性，需要在values/attrs.xml 文件里定义一个name为自己定义view名字的declare-styleable</p>
<pre><code>&lt;resources&gt;

    &lt;declare-styleable name=&quot;SketchView&quot;&gt;
        &lt;attr name=&quot;background_color&quot; format=&quot;color&quot;/&gt;
        &lt;attr name=&quot;size&quot; format=&quot;dimension&quot;/&gt;
    &lt;/declare-styleable&gt;

&lt;/resources&gt;
</code></pre>
<p>这样就可以在xml文件里使用自己定义的属性了</p>
<pre><code>&lt;me.shaohui.androidpractise.widget.SketchView
       xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
       android:layout_width=&quot;match_parent&quot;
       android:layout_height=&quot;match_parent&quot;
       android:layout_marginRight=&quot;16dp&quot;
       android:layout_marginTop=&quot;16dp&quot;
       app:background_color=&quot;@color/colorPrimary&quot;
       app:size=&quot;24dp&quot;/&gt;
</code></pre>
<p>别忘了在前面加上自定义的命名空间，到这来看，增加自定义属性并不算什么，不过要自定义属性生效还是要耗费一些功夫的，这时候前面留下的伏笔：第三个构造方法的defStyleAttr参数就要登场了。</p>
<pre><code>public SketchView(Context context, AttributeSet attrs, int defStyleAttr) &#123;
        super(context, attrs, defStyleAttr);

        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.SketchView, defStyleAttr, R.style.AppTheme);

        custom_size = a.getDimensionPixelSize(R.styleable.SketchView_size, SIZE);
        custon_background = a.getColor(R.styleable.SketchView_background_color, DEFAULT_COLOR);

        a.recycle();
    &#125;
</code></pre>
<p>经过好一番操作，才能把xml定义的属性拿出来，具体取得的值为多少，我在前面已经解释过，就不在这里多说，接下来的操作就是拿着这些属性干你想干的事吧。</p>
<h3 id="实战：一个动态view"><a href="#实战：一个动态view" class="headerlink" title="实战：一个动态view"></a>实战：一个动态view</h3><p>下面将简单介绍一下如何在onDraw(Canvas canvas) 在画布的中心位置画一个自定义颜色的圆，并且通过一个ValueAnimator让这个圆动起来，废话不多说，直接上代码：</p>
<pre><code>    @Override
    protected void onDraw(Canvas canvas) &#123;
        canvas.drawCircle(mWidth/2, mHeight/2, custom_size * scale, mPaint);
    &#125;

    private ValueAnimator mAnimator;
    public void startAnimation() &#123;
        mAnimator = ValueAnimator.ofFloat(1, 2);

        mAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;

            @Override
            public void onAnimationUpdate(ValueAnimator animation) &#123;
                scale = (float) animation.getAnimatedValue();
                postInvalidate();

            &#125;

        &#125;);

        // 重复次数 -1表示无限循环
        mAnimator.setRepeatCount(-1);

        // 重复模式, RESTART: 重新开始 REVERSE:恢复初始状态再开始

        mAnimator.setRepeatMode(ValueAnimator.REVERSE);
        mAnimator.start();

    &#125;
</code></pre>
<p>(只贴了核心代码，完整代码会在文章最后给链接)</p>
<p>可以看到在onDraw()方法里，我调用了canvas的drawCircle方法画了一个圆，圆心的位置是又画布的位置决定的，位于画布的中心，width和height参数是在onLayout()方法里拿到的，在此之前取到的height和width都是不准确的，这点要注意。圆的半径是xml文件中定义的size*scale，而这个scale是通过一个ValueAnimator确定的，变化范围是从1到2，ValueAnimator的值发生改变会赋给scale同时调用postInvalidate()方法，这个方法的作用就是重绘，然后圆的半径就会发生改变，这样刷新就会实现动画的效果。  </p>
<p><img src="http://img.shedoor.net/myview2.gif">  </p>
<h3 id="requstLayout和invidious"><a href="#requstLayout和invidious" class="headerlink" title="requstLayout和invidious"></a>requstLayout和invidious</h3><p>在自定义view时，时常用到刷新view的方法，这时候就会有三个方法供我们选择：requestLayout()、invalidate()、postInvalidate()，其实invalidate和postInvalidate这两个方法作用是一样的，唯一不同的是invalidate用在主线程，而postInvalidate用在异步线程，下面对比一下requestLayout和invalidate的内部实现：</p>
<pre><code>@Override
public void requestLayout() &#123;
    if (!mHandlingLayoutInLayoutRequest) &#123;
        checkThread();
        mLayoutRequested = true;
        scheduleTraversals();
    &#125;
&#125;

void invalidate() &#123;
    mDirty.set(0, 0, mWidth, mHeight);
    if (!mWillDrawSoon) &#123;
        scheduleTraversals();
    &#125;
&#125;
</code></pre>
<p>从代码可以看出，其实这两个方法内部都是调用的scheduleTraversals()方法，不同的是，requestLayout方法将mLayoutRequested标示置为true，scheduleTraversals这个方法以后找机会再细分析，现在只简单说下结论，</p>
<ul>
<li>requestLayout会调用measure和layout 等一系列操作，然后根据布局是否发生改变，surface是否被销毁，来决定是否调用draw，也就是说requestlayout肯定会调用measure和layout，但不一定调用draw，读者可以试着改下我上面写的那个小程序，将postInvalidate改成requestlayout，动画效果就消失了，因为布局没有发生改变。</li>
</ul>
<ul>
<li>invalidate 只会调用draw，而且肯定会调，即使什么都没有发生改变，它也会重新绘制。</li>
</ul>
<p>所以如果有布局需要发生改变，需要调用requestlayout方法，如果只是刷新动画，则只需要调用invalidate方法。</p>
<h3 id="自定义view的状态保存"><a href="#自定义view的状态保存" class="headerlink" title="自定义view的状态保存"></a>自定义view的状态保存</h3><p>自定义view的状态保存和Activity的状态保存是类似的，都是在onSaveInstanceState()保存，然后在onRestoreInstanceState将数据安全取出，之所以在这是还是多说一嘴，主要是怕自己忘，给自己提个醒，也顺便给各位看客叨扰几句，还有一个就是，如果一个view没有id，这个view的状态是不会保存的。</p>
<h3 id="事件处理onTouchEvent"><a href="#事件处理onTouchEvent" class="headerlink" title="事件处理onTouchEvent"></a>事件处理onTouchEvent</h3><p>Android的事件处理太过复杂，我会在以后另起一篇文章来好好聊一下Android里的事件处理。</p>
<h3 id="In-The-End"><a href="#In-The-End" class="headerlink" title="In The End"></a>In The End</h3><p>自定义view其实是一个很重的知识点，里面包含了很多view的知识，不是一篇文章就能聊完的，但我又不习惯连载，有什么话总喜欢一口气说完，所以都写在这一篇文章里了，我这里只是简单的和大家开个头，具体深知里面的细节还是要看很多东西。文章里有什么不对的地方，望各位指出。</p>
<p>源码地址：<a href="https://github.com/shaohui10086/AndroidPractise/blob/master/app/src/main/java/me/shaohui/androidpractise/widget/SketchView.java">Github地址</a></p>
<p>##参考链接</p>
<blockquote>
<ul>
<li><a href="http://ghui.me/post/2015/10/view-measure/">http://ghui.me/post/2015/10/view-measure/</a></li>
<li><a href="http://blog.csdn.net/wzy_1988/article/details/49619773">http://blog.csdn.net/wzy_1988/article/details/49619773</a></li>
<li><a href="http://www.cnblogs.com/angeldevil/p/3479431.html">http://www.cnblogs.com/angeldevil/p/3479431.html</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Android教程系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android教程系列</tag>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title>向日葵公主与驴的爱情故事</title>
    <url>/2017/02/13/DonkeyAndPrincess/</url>
    <content><![CDATA[<p>向日葵公主是在河东岸边遇见驴的。驴是黑色的，但白嘴白肚白蹄。公主想过河去，河西的城堡里有等着娶她的王子。河不算深，但她穿着一身美丽的嫁衣，她怕河水会浸湿她的衣裙。  </p>
<span id="more"></span>

<p>驴说：“想让我驮你过去吗？”<br>“你能保证不弄湿我的衣裙吗？”<br>“不能。”<br>“那就算了，谢谢，”<br>“如果他不来呢？”<br>“那我就多等等。”<br>良久，无人过来，公主独坐岸边，黯然叹息。<br>“不。”公主依然拒绝，但悄然打量着驴。“是你希望我让你驮我过去。”公主回答。<br>“那你希望谁来驮你过去？”<br>“我要嫁的王子。”<br>“我驮你过去，你吻吻我，焉知我不能变成王子？”<br>“你以为你是青蛙王子？”<br>“我是美驴王子。”<br>“驴倒是驴，王子就不必勉强了。”<br>“你为何不想让我帮你渡河？”<br>“我怕你弄湿我的嫁衣。”<br>“我想不会的。”<br>“为什么不会？”<br>“因为现在我想驮你过去。”<br>“哦？我该相信吗？”<br>“你为什么不相信？”<br>“你说的话我不敢随便信。”<br>“我说的话你都不信？”<br>“你说的话我才不信。”<br>“我说的话你真不信？！”<br>“难道我应该信？”<br>“难道你不该信？”<br>“我信我自己的判断。”<br>“好吧，那你慢慢判断吧！”<br>……天色已晚，公主与驴相对无言。凉意袭来，公主拢了拢衣服。<br>驴打破沉默：“冷吗？”<br>“冷。”<br>“让我驮你过河吧，无论我是否弄湿你的衣裙我都会赠你三句爱的箴言。”<br>“那我该怎样报答你？”公主问。<br>“如果你衣裙不湿就带我回家吧。”<br>公主接受了驴的建议。公主骑上了驴背。<br>临行前驴郑重对她说：“记住我背着你时你不能流泪，你的泪会令我不堪重负。”<br>公主说她记得，然后也郑重地对驴说：“记住一定不要弄湿我的衣裙，否则我会立即放弃你的背负。”<br>驴迈步向河中走去。<br>“你以前驮过女孩过河吗？”公主问。<br>“当然。”驴坦然答道。<br>“她们的衣裙湿了吗？”<br>“第一个女孩的没湿，以后的都湿了。”<br>“第一个女孩带你回家了吗？”<br>“没有，否则我不会再遇见别的女孩。”<br>“看来你遇见的女孩很多。”<br>“算上你的话，应该有15、6个了。”<br>公主笑道：“你是第30头想驮我过河的驴。”<br>“呵呵。”驴但笑无语。<br>公主忽然想起驴承诺的爱的箴言，驴答应告诉她第一句：“无论男人还是女人，只有在初恋时爱的是别人，以后恋爱时爱的都是自己。”<br>驴缓步轻行，果然很平稳，公主放心了，搂着驴的脖子，觉得温暖。<br>“喜欢我背你过河吗？”驴问。<br>“喜欢。”公主微笑承认。<br>“我也喜欢这样背着你，希望就这样一直走下去。”驴的声音于温情中透着忧郁，听起来像叹息。<br>风与驴的话语不时吻上公主的面颊，公主含笑悄然入睡。她做了一个公主常做的梦：她吻了驴，然后驴变成了王子，从此王子与公主快乐地生活在一起。当她醒来时看见驴依然缓步轻行，自己的衣裙分毫不湿。芳心窃喜，于是吻了驴——驴能因此变成王子吗？没有。原来童话就是童话，驴不是王子，等着娶她的王子在河西的城堡里。她愣愣地想，一滴泪自目中滴落。泪落在驴身上。似突然被灼伤般，驴猛地扬蹄嘶鸣，激起浪花千丈。公主的衣裙湿了。<br>“为什么？”公主问。<br>“我跟你说过。”驴面无表情。<br>公主也记起了她当初对驴说的话。于是她一言不发，自驴背上下来，独自淌水向对岸走去。驴没做任何挽留或解释，也自转身回去，径直走向河东——那里又有个姑娘在等着谁驮她过河。依稀年轻，依稀美丽，她也有一身好看的嫁衣。<br>“爱情是唯一的，但爱人不是唯一的。”驴忽然说道：“这是第二句箴言。”<br>公主泪落成河，河水冷彻心肺。终于走到了对岸，她美丽的衣裙已经彻底湿透。她无力地在岸边坐下，像只小动物般抱膝蜷缩着黯然哭泣。很是寒冷。<br>一只白兔走到她身边：“公主，下次我陪你渡河。”<br>“谢谢，”公主把白兔搂在怀中：“不必了，现在我只是需要一点温度。”<br>驴已经走回了河东岸边。公主忽然记起还有一句箴言驴没说，于是抬头向河西望去：“请告诉我最后一句箴言，美驴。”<br>驴冷冷看了她最后一眼，说： “我爱我的爱情。 ”然后向那等着渡河的女孩走去。</p>
<hr>
<blockquote>
<p>你看懂了吗？<br>公主，王子，兔子，驴及三句箴言各代表什么意思？  </p>
</blockquote>
<p>这故事其中的含义：<br><strong>公主</strong>：女孩子<br><strong>向日葵城堡里的王子</strong>：女孩子的理想老公<br><strong>不湿衣裙</strong>：代表不受伤害。<br>女人绝不会奢望可以不做任何牺牲来得到未来的老公，恋爱的女人不怕付出，怕的是受伤害和受欺骗。所以故事中女孩和野驴反复协商，一定不能弄湿衣裙，也就是一定要对她好，不能伤害她。<br><strong>驮女孩过河</strong>：恋爱中男方对女方的好<br><strong>把驴带回家</strong>：走向婚姻<br><strong>女孩的吻</strong>：女孩对男人的爱和完全信任。<br>女孩子总觉得，爱他，就可以让他改变。于是总期待自己的伴侣可以为她而改变，但事实上她总是失望。<br><strong>女孩的泪</strong>：伤心，失望，情绪。<br>当女孩认识到，现在的男人无法改变，于是开始变得伤心失望，开始情绪化。<br><strong>驴</strong>：现实中女孩子遇到的男人<br>以前有过很多次恋爱经历（15、16个女孩），已经对感情麻木（总是面无表情，总是叹息），很清楚自己要的是什么，也丧失了真心爱一个人的能力，只是机械的尽自己的职责（驮女孩过河）。他所爱的，只是他自己，还有他的爱情，而不是他的爱人。和女孩子交往已经变成了方程式，对每个女孩子说同样的话做同样的事情。在一段感情开始的时候，都花言巧语欺骗女孩子，说可以变成女孩子理想的模样（“只要你吻我我就变成王子”，其实他自己清楚自己根本变不成王子，但却并不像女孩说明），这种从一开始就信息不等值的关系，维持长久的可能性很小。而在中途，当恋爱遇到了挫折和问题（驴知道了女孩对他的失望和伤心，开始变得暴躁，于是开始伤害女孩，即：驴开始扬蹄嘶鸣，激起浪花千丈。公主的衣裙湿了。）驴也并不采取任何积极措施，而是走向其他年轻漂亮充满幻想的女孩。可见驴的目的只是婚姻，并不是爱某个特定的人。如此一个形象，怎么可能最适合公主？至少可以判断出他一开始就带着欺骗。坦诚是恋爱和婚姻的前提，是双方信任的条件。明明自己是石头，装什么小馅饼。<br><strong>驴这种动物的文化含义</strong>：聪明，残忍，倔强。<br><strong>衣衫尽湿的公主</strong>：受伤过后的女人。<br>很狼狈，很落魄，蜷缩在一个角落独自伤神。这个时候的女人，其实更渴望一个人来爱她。而这个人是谁，都无所谓了。因为这次她只想被爱了。就像公主最后委曲求全的找了兔子，目的只是取暖。<br><strong>兔子</strong>：可能是公主的老公<br>品行特征无法判断，但是在女人不再年轻美丽漂亮时，依旧愿意陪在女人身边；甚至当女人明着告诉他我累了不想爱了，我只需要取暖的时候，依旧给予女人她想要的。能做到这点，看来这只兔子应该不坏。<br><strong>兔子这种动物的文化含义</strong>：温和，顺从，可爱。</p>
<hr>
<p>驴的三句格言：透露着驴子对爱情的理解<br><strong>“ 无论男人还是女人，只有在初恋时爱的是别人，以后恋爱时爱的都是自己。”</strong><br>—–驴子在初恋时也是把女孩放在第一位，宠爱女孩，永远有耐心，不伤害女孩。但可惜驴子的第一个女孩没有和驴子走向婚姻（原因不详），于是驴子对待接下来遇到的每一个女孩，都不如对待第一个女孩那么用心，那么耐心了。驴开始不为女孩而活，开始为自己而活。<br><strong>“爱情是唯一的，但爱人不是唯一的。”</strong><br>——所以驴子和公主有了矛盾时，不伤心也不挽回，因为这个走了，还有下一个。爱人是流动的，爱情是不变的。<br><strong>“我爱我的爱情。”</strong><br> ——驴子很清楚自己想要什么。他爱的是爱情本身，而不是某个女孩。每个女孩在受伤之后，都能通过曾经照顾她又伤害她的男人学到很多。一个不太好的男人，也可以成为女人的学校，让女人变得更实际，更会保护自己。</p>
]]></content>
      <categories>
        <category>还相信爱情</category>
      </categories>
      <tags>
        <tag>遇见</tag>
        <tag>E.Efall</tag>
        <tag>Love</tag>
      </tags>
  </entry>
  <entry>
    <title>Android弹性布局-FlexboxLayout</title>
    <url>/2016/08/24/FlexboxLayoutAbout/</url>
    <content><![CDATA[<h2 id="Flexbox简介"><a href="#Flexbox简介" class="headerlink" title="Flexbox简介"></a>Flexbox简介</h2><p>简单来说 Flexbox 是属于web前端领域CSS的一种布局方案，是2009年W3C提出了一种新的布局方案，可以简便、完整、响应式地实现各种页面布局，并且 React Native 也是使用的 Flex 布局。谷歌将其引入以提高复杂布局的能<br>力。  </p>
<span id="more"></span>

<p><a href="https://github.com/google/flexbox-layout">Github 源码传送门</a></p>
<h2 id="Flexbox的布局和相关名称"><a href="#Flexbox的布局和相关名称" class="headerlink" title="Flexbox的布局和相关名称"></a>Flexbox的布局和相关名称</h2><p><img src="http://img.shedoor.net/flexBoxLayoutAbout/1.png">  </p>
<p>上图模型中包含以下概念</p>
<ol>
<li>flex container 父容器，用来包含子元素，对应于FlexboxLayout类。</li>
<li>flex item 子元素，父容器直接包裹的元素。</li>
<li>main axis 主轴，子元素通过主轴来排列，如上图是从左往右。</li>
<li>corss axis 副轴，垂直于主轴的第二个轴</li>
<li>main start,main end 父容器中主轴开始和结束的边界，子元素从main start往main end的方向排列（如果主轴是水平，起点在左端，main start,main end 用来控制子元素从左向右排列）</li>
<li>cross start,corss end 父容器中副轴开始和结束的边界。子元素从cross start往cross end方向排列(如果主轴是水平的，那么副轴就是垂直的，假设如上图，cross start 在上，cross end 在下，那么子元素就是从上往下排列)  </li>
</ol>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>使用方式很简单，只需要添加以下依赖：</p>
<blockquote>
<p>compile ‘com.google.android:flexbox:0.1.2’  </p>
</blockquote>
<p>Flexbox 布局示例  </p>
<pre><code>&lt;com.google.android.flexbox.FlexboxLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    app:flexWrap=&quot;wrap&quot;
    app:alignItems=&quot;stretch&quot;
    app:alignContent=&quot;stretch&quot; &gt;

    &lt;TextView
        android:id=&quot;@+id/textview1&quot;
        android:layout_width=&quot;120dp&quot;
        android:layout_height=&quot;80dp&quot;
        app:layout_flexBasisPercent=&quot;50%&quot;
        /&gt;

    &lt;TextView
        android:id=&quot;@+id/textview2&quot;
        android:layout_width=&quot;80dp&quot;
        android:layout_height=&quot;80dp&quot;
        app:layout_alignSelf=&quot;center&quot;
        /&gt;

    &lt;TextView
        android:id=&quot;@+id/textview3&quot;
        android:layout_width=&quot;160dp&quot;
        android:layout_height=&quot;80dp&quot;
        app:layout_alignSelf=&quot;flex_end&quot;
        /&gt;
&lt;/com.google.android.flexbox.FlexboxLayout&gt;  
</code></pre>
<p>或者代码</p>
<pre><code>FlexboxLayout flexboxLayout = (FlexboxLayout) findViewById(R.id.flexbox_layout);
flexboxLayout.setFlexDirection(FlexboxLayout.FLEX_DIRECTION_COLUMN);

View view = flexboxLayout.getChildAt(0);
FlexboxLayout.LayoutParams lp = (FlexboxLayout.LayoutParams) view.getLayoutParams();
lp.order = -1;
lp.flexGrow = 2;
view.setLayoutParams(lp);  
</code></pre>
<h2 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h2><h3 id="Contatiner的属性"><a href="#Contatiner的属性" class="headerlink" title="Contatiner的属性"></a>Contatiner的属性</h3><h4 id="flexDirection"><a href="#flexDirection" class="headerlink" title="flexDirection"></a>flexDirection</h4><p>flexDirection 属性决定主轴的方向（即子元素的排列方向）。类似 LinearLayout 的 vertical 和 horizontal。决定主轴和副轴的方向，有以下四个值:  </p>
<ul>
<li>row（默认值）：主轴为水平方向，起点在左端。</li>
<li>row-reverse：主轴为水平方向，起点在右端。</li>
<li>column：主轴为垂直方向，起点在上沿。</li>
<li>column-reverse：主轴为垂直方向，起点在下沿。  </li>
</ul>
<p>而副轴是和主轴垂直的方向，起点相同。  </p>
<h4 id="flexWrap"><a href="#flexWrap" class="headerlink" title="flexWrap"></a>flexWrap</h4><p>控制单行和多行，以及副轴的方向。默认情况下 Flex 跟 LinearLayout 一样，都是不带换行排列的，但是flexWrap属性可以支持换行排列。这个也比 LinearLayout 吊啊有三个值：  </p>
<p><img src="http://img.shedoor.net/flexBoxLayoutAbout/2.png">  </p>
<ul>
<li>nowrap (default) 不换行</li>
<li>wrap 换行</li>
<li>wrap_reverse 副轴方向置反  </li>
</ul>
<h4 id="justifyContent"><a href="#justifyContent" class="headerlink" title="justifyContent"></a>justifyContent</h4><p>justifyContent属性定义了项目在主轴上的对齐方式。  </p>
<ul>
<li>flex-start（default）：左对齐</li>
<li>flex-end：右对齐</li>
<li>center： 居中</li>
<li>space-between：两端对齐，项目之间的间隔都相等。</li>
<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。  </li>
</ul>
<h4 id="alignItems"><a href="#alignItems" class="headerlink" title="alignItems"></a>alignItems</h4><p>控制沿副轴对齐(单行起作用)</p>
<ul>
<li>stretch（default）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
<li>flex-start：交叉轴的起点对齐。</li>
<li>flex-end：交叉轴的终点对齐。</li>
<li>center：交叉轴的中点对齐。</li>
<li>baseline: 项目的第一行文字的基线对齐。</li>
</ul>
<p><img src="http://img.shedoor.net/flexBoxLayoutAbout/3.png"></p>
<h4 id="alignContent"><a href="#alignContent" class="headerlink" title="alignContent"></a>alignContent</h4><p>alignContent属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。  </p>
<ul>
<li>stretch（default）：轴线占满整个交叉轴。</li>
<li>flex-start：与交叉轴的起点对齐。</li>
<li>flex-end：与交叉轴的终点对齐。</li>
<li>center：与交叉轴的中点对齐。</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。  </li>
</ul>
<h3 id="子元素的属性"><a href="#子元素的属性" class="headerlink" title="子元素的属性"></a>子元素的属性</h3><h4 id="layout-order"><a href="#layout-order" class="headerlink" title="layout_order"></a>layout_order</h4><p>控制子元素布局的顺序，默认值为1，顺序为XML中元素的顺序.默认情况下子元素的排列方式按照文档流的顺序依次排序，而order属性可以控制排列的顺序，负值在前，正值灾后，按照从小到大的顺序依次排列。  </p>
<p><img src="http://img.shedoor.net/flexBoxLayoutAbout/4.png"></p>
<h4 id="layout-flexGrow"><a href="#layout-flexGrow" class="headerlink" title="layout_flexGrow"></a>layout_flexGrow</h4><p>layout_flexGrow 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。一张图看懂。跟 LinearLayout 中的weight属性一样。  </p>
<p><img src="http://img.shedoor.net/flexBoxLayoutAbout/5.png"><br>如果所有项目的 layout_flexGrow  属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的 layout_flexGrow  属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。  </p>
<h4 id="layout-flexShrink"><a href="#layout-flexShrink" class="headerlink" title="layout_flexShrink"></a>layout_flexShrink</h4><p>layout_flexShrink  属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。  </p>
<h4 id="layout-alignSelf"><a href="#layout-alignSelf" class="headerlink" title="layout_alignSelf"></a>layout_alignSelf</h4><p>允许单个元素有不一样的对齐方式，会覆盖align-item,除auto外，其他取值都和align-item的含义一致。<br>默认值为auto，表示继承父元素的 alignItems 属性，如果没有父元素，则等同于stretch。  </p>
<ul>
<li>flex_start</li>
<li>flex_end</li>
<li>center</li>
<li>baseline</li>
<li>stretch</li>
</ul>
<h4 id="layout-flexBasisPercent"><a href="#layout-flexBasisPercent" class="headerlink" title="layout_flexBasisPercent"></a>layout_flexBasisPercent</h4><p>只能为百分比的值，只有父元素是MeasureSpec.EXACTLY的模式时才有效。<br>layout_flexBasisPercent 属性定义了在分配多余空间之前，子元素占据的main size主轴空间，浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即子元素的本来大小。  </p>
<h2 id="与传统CSS弹性布局不同之处"><a href="#与传统CSS弹性布局不同之处" class="headerlink" title="与传统CSS弹性布局不同之处"></a>与传统CSS弹性布局不同之处</h2><ol>
<li>没有flex-flow属性 ：因为没必要</li>
<li>没有flex属性：同样没必要</li>
<li>layout_flexBasisPercent 替代了flexBasis。如果子元素宽高确定了，可以指定具体值或百分比，如果是包裹内容，那只能是百分比</li>
<li>不支持min-width和min-height：因为谷歌还没实现  </li>
</ol>
<blockquote>
<p>相关链接：<br><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">https://css-tricks.com/snippets/css/a-guide-to-flexbox/</a><br><a href="https://github.com/google/flexbox-layout/wiki">https://github.com/google/flexbox-layout/wiki</a><br><a href="https://blog.stylingandroid.com/flexboxlayout-part-1/">https://blog.stylingandroid.com/flexboxlayout-part-1/</a></p>
</blockquote>
<blockquote>
<p>文章来源：<br><a href="http://www.jianshu.com/p/6ab9808488f6">简书</a><br><a href="">AndroidDeveloper微信公众号-stormzhang</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android控件</category>
      </categories>
      <tags>
        <tag>Android控件</tag>
        <tag>Android</tag>
        <tag>FlexboxLayout</tag>
      </tags>
  </entry>
  <entry>
    <title>Fragment的标准写法</title>
    <url>/2016/08/18/FragmentCreateWay/</url>
    <content><![CDATA[<p>关于Fragment大家的态度可谓众说纷纭，有人说好，有人说坑。这里就不讨论了，只是着重介绍一下Fragment的一种标准的写法，从使用工厂方法来生成Fragment，到如何写回调接口，在哪里实现回调接口，在哪里注销掉回调接口。  </p>
<span id="more"></span>

<h3 id="标准写法"><a href="#标准写法" class="headerlink" title="标准写法"></a>标准写法</h3><pre><code>/**
 * 一个简单的Fragment子类
 * 含有这个Master_Fragment的Activity必须要去 实现 Master_Fragment.OnFragmentInteractionListener
 * 这个接口来处理Fragment与Activity的互动事件
 * 这里强烈建议使用工厂方法Master_Fragment#newInstance
 * 来创造Master_Fragment的实例.
 */
public class Master_Fragment extends Fragment &#123;
    // 名字根据实际需求进行更改
    private static final String ARG_PARAM1 = &quot;param1&quot;;
    private static final String ARG_PARAM2 = &quot;param2&quot;;

    // 这里的参数只是一个举例可以根据需求更改
    private String mParam1;
    private String mParam2;

    private OnFragmentInteractionListener mListener;

    /**
     * 通过工厂方法来创建Fragment实例
     * 同时给Fragment来提供参数来使用
     *
     * @param param1 参数1.
     * @param param2 参数2.
     * @return Master_Fragment的实例.
     */
    public static Master_Fragment newInstance(String param1, String param2) &#123;
        Master_Fragment fragment = new Master_Fragment();
        Bundle args = new Bundle();
        args.putString(ARG_PARAM1, param1);
        args.putString(ARG_PARAM2, param2);
        fragment.setArguments(args);
        return fragment;
    &#125;

    /**
     * 一般情况下我们选择直接把Bundle传进来
     *
     * @param bundle
     * @return
     */
    public static Master_Fragment newInstance(Bundle bundle) &#123;
        Master_Fragment fragment = new Master_Fragment();
        fragment.setArguments(bundle);
        return fragment;
    &#125;

    public Master_Fragment() &#123;
        // Required empty public constructor
    &#125;

    @Override
    public void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        getArguData();
    &#125;

    /**
     * 获取传进来的值
     */
    private void getArguData() &#123;
        Bundle bundle = getArguments();
        if (bundle != null) &#123;
            mParam1 = bundle.getString(ARG_PARAM1);
            mParam2 = bundle.getString(ARG_PARAM2);
        &#125;
    &#125;

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) &#123;
        return inflater.inflate(R.layout.fragment_master_layout, container, false);
    &#125;

    // TODO: Rename method, update argument and hook method into UI event
    public void onButtonPressed(Uri uri) &#123;
        if (mListener != null) &#123;
            mListener.onFragmentInteraction(uri);
        &#125;
    &#125;

    /**
     * onAttach中连接监听接口 确保Activity支持该接口
     */
    @Override
    public void onAttach(Activity activity) &#123;
        super.onAttach(activity);
        try &#123;
            mListener = (OnFragmentInteractionListener) activity;
        &#125; catch (ClassCastException e) &#123;
            throw new ClassCastException(activity.toString()
                    + &quot; must implement OnFragmentInteractionListener&quot;);
        &#125;
    &#125;

    /**
     * onDetach中注销接口
     */
    @Override
    public void onDetach() &#123;
        super.onDetach();
        mListener = null;
    &#125;

    /**
     * 这个互动接口必须被含有Master_Fragment 的Activity继承
     * 来实现Fragment与Activity直接的互通
     * 更多信息请参考
     * &quot;http://developer.android.com/training/basics/fragments/communicating.html&quot;
     * &gt;Communicating with Other Fragments&lt;/a&gt; .
     */
    public interface OnFragmentInteractionListener &#123;
        // 根据实际需求更改
        public void onFragmentInteraction(Uri uri);
    &#125;
&#125;
</code></pre>
<h3 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h3><ol>
<li>推荐使用newInstance工厂方法来生成Fragment的实例</li>
<li>Activity和Fragment直接的互通使用回调接口完成</li>
<li>onAttach中监听接口，在onDetach中注销接口</li>
</ol>
<p>以上代码为Android Studio自动生成更多信息请参考： <a href="http://developer.android.com/training/basics/fragments/communicating.html">http://developer.android.com/training/basics/fragments/communicating.html</a>  </p>
<blockquote>
<p>摘录来源：<a href="http://blog.csdn.net/dantestones/article/details/46848939">还不走A：Android Fragment的标准写法</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android教程系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android教程系列</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title>获取图片的三种方法（超完整）</title>
    <url>/2016/08/15/GetPhotoThreeMethods/</url>
    <content><![CDATA[<blockquote>
<p>本文导航  </p>
</blockquote>
<ul>
<li>Camera的源码分析  </li>
<li>获取Camera的缩略图  </li>
<li>获取Camera的完整图片  </li>
<li>获取Gallery的图片  </li>
</ul>
<span id="more"></span>

<h2 id="源码部分分析"><a href="#源码部分分析" class="headerlink" title="源码部分分析"></a>源码部分分析</h2><p><a href="https://github.com/android/platform_packages_apps_camera/blob/gingerbread-release/src/com/android/camera/Camera.java#L1127">Camera.java</a></p>
<p>通过源码可以发现，输出的图片有2个分支</p>
<ol>
<li><p>如果你没有指定Intent里面的Extra参数，它就返回一个序列化(putExtra(“data”, bitmap))的Bitmap，从理论上来说，这样的代码写的很烂，属于Magic Number。</p>
</li>
<li><p>如果你指定了Intent里面的Extra参数MediaStore.EXTRA_OUTPUT，拍照后它就直接把bitmap写到了Uri里面了,返回是空</p>
</li>
</ol>
<h2 id="获得拍照的预览图"><a href="#获得拍照的预览图" class="headerlink" title="获得拍照的预览图"></a>获得拍照的预览图</h2><p>使用范围：获得很小的预览图，用于设置头像等地方。<br>返回示例：bitmap = data.getExtras().getParcelable(“data”);</p>
<pre><code>public final static int REQUEST_IMAGE_CAPTURE = 1;

//start
Intent intent = new Intent(android.provider.MediaStore.ACTION_IMAGE_CAPTURE);
startActivityForResult(intent, REQUEST_IMAGE_CAPTURE);

//receive
@Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;
    super.onActivityResult(requestCode, resultCode, data);
    if (resultCode != RESULT_OK) &#123;
      Log.d(TAG, &quot;canceled or other exception!&quot;);
      return;
    &#125;

    if (requestCode == REQUEST_IMAGE_CAPTURE) &#123;
      Log.d(TAG, &quot;REQUEST_IMAGE_CAPTURE&quot;);
      Bitmap bitmap;
      try &#123;
          //&quot;data&quot;这个居然没用常量定义,也是醉了,我们可以发现它直接把bitmap序列化到intent里面了。
        bitmap = data.getExtras().getParcelable(&quot;data&quot;);
        //TODO:do something with bitmap, Do NOT forget call Bitmap.recycler();
        mCameraImageview.setImageBitmap(bitmap);
      &#125; catch (ClassCastException e)&#123;
           //do something with exceptions
        e.printStackTrace();
      &#125;
    &#125;

  &#125;
</code></pre>
<h2 id="获得原始的拍照文件"><a href="#获得原始的拍照文件" class="headerlink" title="获得原始的拍照文件"></a>获得原始的拍照文件</h2><p>使用范围：用于处理大的图片，比如使用滤镜，上传原始图像等操作，注意Uri不要用data私有目录，否则相机是写不进去的。</p>
<p>返回示例:</p>
<pre><code>outputFileUri = file:///storage/sdcard0/JPEG_20150226_221320_-328629202.jpg
</code></pre>
<p>使用方法：</p>
<pre><code>public final static int REQUEST_IMAGE_CAPTURE = 1;
Uri outputFileUri;

//start
  @OnClick(R.id.itemSelectCamera) void itemSelectCamera() &#123;
    File file = FileUtils.createImageFile();
    outputFileUri = Uri.fromFile(file);
    Intent captureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
    captureIntent.putExtra(MediaStore.EXTRA_OUTPUT, outputFileUri);
    startActivityForResult(captureIntent, REQUEST_IMAGE_CAPTURE);
  &#125;

//receive
@Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;
    super.onActivityResult(requestCode, resultCode, data);

    if (resultCode != RESULT_OK) &#123;
      Log.d(TAG, &quot;canceled or other exception!&quot;);
      return;
    &#125;

    if (requestCode == REQUEST_IMAGE_CAPTURE) &#123;
      Log.d(TAG, &quot;REQUEST_IMAGE_CAPTURE&quot;);
      //TODO:Use the Uri
      Intent intent = new Intent(this, ImageFilterActivity.class);
      intent.setData(outputFileUri);
      startActivity(intent);
    &#125;

  &#125;
</code></pre>
<p>关于文件如何创建，目前我找到的就是这个最稳定了，写到SD卡根目录（每个手机位置都不一样，坑太多了），再说一遍，data目录（Context.getXXDir()）是私有目录，其它程序（比如Camera）是写不进去的</p>
<pre><code>public class FileUtils &#123;

  public static File createImageFile() &#123;
    // Create an image file name
    String timeStamp = new SimpleDateFormat(&quot;yyyyMMdd_HHmmss&quot;).format(new Date());
    String imageFileName = &quot;JPEG_&quot; + timeStamp + &quot;_&quot;;
    try &#123;
      File image = File.createTempFile(imageFileName,  /* prefix */
          &quot;.jpg&quot;,         /* suffix */
          Environment.getExternalStorageDirectory()      /* directory */);
      return image;
    &#125; catch (IOException e) &#123;
      //do noting
      return null;
    &#125;
  &#125;
&#125;
</code></pre>
<h2 id="获取Gallery里面的图片"><a href="#获取Gallery里面的图片" class="headerlink" title="获取Gallery里面的图片"></a>获取Gallery里面的图片</h2><p>用途：获取MINETYPE为”image/*”的图片</p>
<p>返回示例 :</p>
<pre><code>content://com.android.providers.media.documents/document/image%3A445
</code></pre>
<p>使用方法：</p>
<pre><code>public final static int REQUEST_IMAGE_SELECT = 2;

@OnClick(R.id.itemSelectGallery) void itemSwitches() &#123;
    Intent intent = new Intent(Intent.ACTION_PICK);
    intent.setType(&quot;image/*&quot;);
    intent.setAction(Intent.ACTION_GET_CONTENT);
    startActivityForResult(intent, REQUEST_IMAGE_SELECT);
  &#125;

@Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;
super.onActivityResult(requestCode, resultCode, data);

    if (resultCode != RESULT_OK) &#123;
      Log.d(TAG, &quot;canceled or other exception!&quot;);
      return;
    &#125;

    if (requestCode == REQUEST_IMAGE_SELECT) &#123;
      Log.d(TAG, &quot;REQUEST_IMAGE_SELECT&quot;);
      //TODO:Use Uri
      Intent intent = new Intent(this, ImageFilterActivity.class);
      intent.setData(data.getData());
      startActivity(intent);
    &#125;
&#125;
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章绝对比stackoverflow上的许多回答都更加完整，我花了很多时间查了很多的方案，最后定下来这三种方法是最好的。  </p>
<blockquote>
<p>摘录来自：<a href="http://www.jianshu.com/p/d4793d32a5fb">简书作者</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android教程系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android教程系列</tag>
      </tags>
  </entry>
  <entry>
    <title>Glide坑遇记</title>
    <url>/2017/03/24/GlideBug/</url>
    <content><![CDATA[<p><img src="http://img.shedoor.net/ocnyang/glide/android-working-with-glide-image-library.jpg" alt="Glide 坑遇记">  </p>
<p>有一段时间没有更新文章了，但登录 <strong><a href="http://www.jianshu.com/u/e61d05cbf47e">简书</a></strong> 发现时不时也有新的点赞和关注，在这里十分感谢大家的认可，也为这段时间的静默表示抱歉。这段时间确实有点忙，自己一直在利用 <strong>一些平台</strong>（这里不说出平台名称了，一来避嫌，二来现在对这些平台提供的数据也没太多好感了） 提供的接口，敲写一个生活工具类的App，一方面是使用 <strong>Retrofit + RxJava + okhttp</strong> 这种比较热门的框架结构熟悉一下，一方面是集体测试一下 GitHub 平时不太使用的热门库。现在这个项目还在开发中，上线后会通知大家，也会在适当的时候把这个项目的源代码开源到 GitHub,同时也会写一些这个项目用到的大家感兴趣的技术的介绍文章。  </p>
<span id="more"></span>

<p>好了，啰嗦的够多了，开始今天的正题…</p>
<p><strong>Glide 的基本使用</strong>可以查看下面这些文章：  </p>
<p><a href="http://ocnyang.com/2016/08/09/GlideAbout/">图片加载库Glide介绍</a><br><a href="http://ocnyang.com/2016/08/17/GlideUse/">Glide图片加载库的使用</a>  </p>
<h2 id="1、Glide-实现-ImageView-宽度填满，高度自适应的效果"><a href="#1、Glide-实现-ImageView-宽度填满，高度自适应的效果" class="headerlink" title="1、Glide 实现 ImageView 宽度填满，高度自适应的效果"></a>1、Glide 实现 ImageView 宽度填满，高度自适应的效果</h2><p>要说这个，就要先说一下大家在平时用到 ImageView 实现宽度填满，高度自适应的方法。</p>
<blockquote>
<p>ImageView 宽度填满，高度自适应常用在：  </p>
<ol>
<li>ListView 列表布局的条目中（RecycleView 同理），比如实现 item 中的图片充满屏幕，高度根据具体图片比例自适应，商品详情中常常用到。  </li>
<li>GridView 网格布局的条目中，假如 item 有两列，想让每一列的 item 中的图片占用屏幕的一半。  </li>
<li>其他使用单独图片也想达到这种效果的场景。</li>
</ol>
</blockquote>
<p>这里提供两种实现方法，也都是大家都知道：  </p>
<p><strong>1、重写 onMeasure 方法</strong>  </p>
<pre><code>public class ResizableImageView extends ImageView &#123;  

    public ResizableImageView(Context context) &#123;  
        super(context);  
    &#125;  

    public ResizableImageView(Context context, AttributeSet attrs) &#123;  
        super(context, attrs);  
    &#125;  

    @Override  
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)&#123;  
        Drawable d = getDrawable();
        if(d!=null)&#123;  
            int width = MeasureSpec.getSize(widthMeasureSpec);  
            //高度根据使得图片的宽度充满屏幕计算而得  
            int height = (int) Math.ceil((float) width * (float) d.getIntrinsicHeight() / (float) d.getIntrinsicWidth());  
            setMeasuredDimension(width, height);  
        &#125;else&#123;  
            super.onMeasure(widthMeasureSpec, heightMeasureSpec);  
        &#125;  
    &#125;  
&#125;  
</code></pre>
<blockquote>
<p>在布局文件 xml 中,ImageView 不用对显示方式进行设置（使用默认就行）。  </p>
</blockquote>
<p><strong>2、设置 ImageView 的属性</strong>  </p>
<pre><code>&lt;ImageView
        android:id=&quot;@+id/iv_ocnyang&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:adjustViewBounds=&quot;true&quot;
        android:scaleType=&quot;fitXY&quot;
        /&gt;
</code></pre>
<blockquote>
<p>fitXY 这种图片的显示方式的效果是：根据 ImageView 设置的大小拉伸图片以填充满空间，（单独设置此属性时）图片会变形。<br>adjustViewBounds 是限制图片在显示时保持原图比例。（和 fitXY 显示方式合用能到达自适应的效果）</p>
</blockquote>
<p>通过这上面两种方式显示图片一般都能够宽度充满高度自适应的效果，可是当你用 Glide 请求显示网络图片的时候，你会很失望的发现上面的设置失效了同时图片也变形了。  </p>
<p>那么这时候是哪里出了问题了呢？（下面只做一个笼统的分析，具体可以看这个链接： <a href="https://github.com/clarkehe/Android/wiki/Coding(7):-Glide%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9">Glide使用及注意的地方</a>）<br>其实如果你熟知 Glide 的话，可能你还记得，Glide 在加载图片的时候，加载的大小会和 ImageView 的大小保持一致。也就是 ImageView 的大小决定了 Glide 加载图片的尺寸。而这里我们的 ImageView 设置的高度是 wrap_content，Glide 就无法准确的加载图片的大小了。  </p>
<p>那这个时候怎么才能保证按原图的比例来自适应高度显示呢？   </p>
<p><strong>这里有两种方式：</strong>  </p>
<ol>
<li>你已经知道图片（或其他方式提前知道）图片的比例，然后在用 Glide 请求图片时限制图片的加载大小，即设置 <strong>override(int width, int height)</strong> 。这时候加载到的图片是原图比例，显示的时候虽然有拉伸/压缩但都会保存原比例的。这种方式适用于你加载的图片大小都比较规范固定的时候。  </li>
<li>当然，你请求的图片源并不一定大小都一致。那这时候就可以使用下面这种方式了。这种方式的原理是，先使用 Glide 把图片的原图请求加载过来，然后再按原图来显示图片。  </li>
</ol>
<pre><code>Glide.with(mContext)
     .load(url)
     .asBitmap()
     .into(new SimpleTarget&lt;Bitmap&gt;() &#123;
          @Override
          public void onResourceReady(Bitmap resource, GlideAnimation&lt;? super Bitmap&gt; glideAnimation) &#123;
                ivOcnyang.setImageBitmap(resource);
          &#125;
      &#125;);
</code></pre>
<blockquote>
<p>这两种方法中，其实更加提倡的是第一种方式，因为这种方式不会造成任何负面的影响。但第二种方式，由于Glide加载图片时是以全分辨率加载的，当加载图片过大且图片很多时，可能造成 OOM。同时第二种方式使用在列表上复用时会造成条目错乱错位。</p>
</blockquote>
<h2 id="2、Glide-加载-Gif-图片的那些坑"><a href="#2、Glide-加载-Gif-图片的那些坑" class="headerlink" title="2、Glide 加载 Gif 图片的那些坑"></a>2、Glide 加载 Gif 图片的那些坑</h2><p>我们知道，对比其他几大图片加载框架，我们更青睐 Glide 有一部分原因就是因为它能显示动态图，毕竟像下面这种图是让我最高兴最无法拒绝的。  </p>
<p><img src="http://img.shedoor.net/ocnyang/glide/timg.gif" alt="每看到星期五，这两个字我就莫名的兴奋">  </p>
<h3 id="2-1、加载-Gif-图片慢或者显示不出来"><a href="#2-1、加载-Gif-图片慢或者显示不出来" class="headerlink" title="2.1、加载 Gif 图片慢或者显示不出来"></a>2.1、加载 Gif 图片慢或者显示不出来</h3><p>这是一个公认的问题了，在 Glide 的 issue 上有人提出过，并且作者也给出了**<a href="">解决方案</a>**。<br>加载 GIF 时需要调用 asGif() 方法，同时设置特别的缓存策略，调用 diskCacheStrategy() 将缓存策略设置为 SOURCE（缓存原图） 或者 NONE（不做缓存）。  </p>
<blockquote>
<p>Glide 在加载 GIF 时不调用 asGif() 方法也是能正常显示动画的。但建议调用 asGif()。  </p>
</blockquote>
<pre><code>if (imgUrl.toUpperCase().endsWith(&quot;.GIF&quot;)) &#123;
            Glide.with(mContext)
                    .load(imgUrl)
                    .asGif()
                    .override(width, height)
                    .placeholder(placeholderImg)
                    .error(errorImg)
                    .dontAnimate() //去掉显示动画
                    .centerCrop()
                    .diskCacheStrategy(DiskCacheStrategy.SOURCE) //DiskCacheStrategy.NONE
                    .into(ivOcnyang);
        &#125; else &#123;
            Glide.with(mContext)
                    .load(imgUrl)
                    .override(width, height)
                    .placeholder(placeholderImg)
                    .error(errorImg)
                    .crossFade()
                    .centerCrop()
                    .into(ivOcnyang);
        &#125;
</code></pre>
<h3 id="2-2、动态GIF图片显示的次数"><a href="#2-2、动态GIF图片显示的次数" class="headerlink" title="2.2、动态GIF图片显示的次数"></a>2.2、动态GIF图片显示的次数</h3><p>可能你有时有需求，需要设置动态图的显示一定次数时停止。  </p>
<pre><code>Glide.with(mContext)
        .load(imgUrl)
        .asGif()
        .override(width,height)
        .placeholder(placeholderImg)
        .error(errorImg)
        .dontAnimate()
        .centerCrop()
        .diskCacheStrategy(DiskCacheStrategy.SOURCE)
        .into(new GlideDrawableImageViewTarget(ivOcnyang, 3));
</code></pre>
<blockquote>
<p>这里的 <code>GlideDrawableImageViewTarget(ImageView view, int maxLoopCount)</code> 的第二个参数 maxLoopCount  就是你要循环的次数。  </p>
</blockquote>
<h3 id="2-3、将-GIF-作为-Bitmap-显示"><a href="#2-3、将-GIF-作为-Bitmap-显示" class="headerlink" title="2.3、将 GIF 作为 Bitmap 显示"></a>2.3、将 GIF 作为 Bitmap 显示</h3><p>如果要显示的图片列表包含多种图像类型, 有图片和 GIF, 全都强制判断 GIF 有时是不可行的. 我们可以将 GIF 先作为 Bitmap 加载第一帧图像. 然后给用户一个提示, 当用户点击时, 再使用 GIF 方式重新加载。  </p>
<pre><code>Glide  
    .with(context)
    .load(gifUrl)
    .asBitmap()
    .into(imageViewGifAsBitmap);
</code></pre>
<h2 id="3、Glide图片和默认图交替过程中-默认图闪烁一下"><a href="#3、Glide图片和默认图交替过程中-默认图闪烁一下" class="headerlink" title="3、Glide图片和默认图交替过程中,默认图闪烁一下"></a>3、Glide图片和默认图交替过程中,默认图闪烁一下</h2><p>这是比较坑的一点，如果占位图要比原图大有时会出现这种问题。其实有时候你会发现占位图和 loading 图的设置有时会造成各种问题，有时可能影响图片显示不正常。  </p>
<p>解决方法：<br>去掉动画：dontAnimate()</p>
<p>有时，使用 CircleImageView 加载图片时显示不正常，有可能是CircleImageView引起的与占位图和显示动画的冲突，解决方法同上，亦或去掉占位图。</p>
<h2 id="4、CenterCrop与Transformer的共存问题"><a href="#4、CenterCrop与Transformer的共存问题" class="headerlink" title="4、CenterCrop与Transformer的共存问题"></a>4、CenterCrop与Transformer的共存问题</h2><p>这个问题的 <a href="https://github.com/bumptech/glide/issues/613">issues 地址</a>。   </p>
<p>这个问题是在网格布局和瀑布流布局中使用 .centerCrop，所以必须要在 ImageView 中去设置 scaleType 为 centerCrop。<br>但是，当你同时给图片设置圆角类 Transformer 时，即在 Glide 加载图片时给 .transform() 配置了一个圆角矩形，如果同时 ImageView 的 scaleType 设置了 centerCrop，那圆角就没有了。  </p>
<p><strong>解决方法，设置两个 Transformer：</strong>  </p>
<pre><code>...
.transform(new CenterCrop(getContext())
          ,new GlideRoundTransform(getContext(), 25))
...
</code></pre>
<p><strong>这里给出圆角 GlideRoundTransform 源代码。</strong>（设置圆形图片，更多方式可以参考这个 <a href="http://stackoverflow.com/questions/25278821/how-to-round-an-image-with-glide-library">How to round an image with Glide library?</a> ）</p>
<pre><code>public class GlideRoundTransform extends BitmapTransformation &#123;

    private static float radius = 0f;

    public GlideRoundTransform(Context context) &#123;
        this(context, 4);
    &#125;

    public GlideRoundTransform(Context context, int dp) &#123;
        super(context);
        this.radius = Resources.getSystem().getDisplayMetrics().density * dp;
    &#125;

    @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123;
        return roundCrop(pool, toTransform);
    &#125;

    private static Bitmap roundCrop(BitmapPool pool, Bitmap source) &#123;
        if (source == null) return null;

        Bitmap result = pool.get(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);
        if (result == null) &#123;
            result = Bitmap.createBitmap(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);
        &#125;

        Canvas canvas = new Canvas(result);
        Paint paint = new Paint();
        paint.setShader(new BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP));
        paint.setAntiAlias(true);
        RectF rectF = new RectF(0f, 0f, source.getWidth(), source.getHeight());
        canvas.drawRoundRect(rectF, radius, radius, paint);
        return result;
    &#125;

    @Override
    public String getId() &#123;
        return getClass().getName() + Math.round(radius);
    &#125;
&#125;
</code></pre>
<h2 id="5、得到类似-You-cannot-start-a-load-for-a-destroyed-activity-这样的异常"><a href="#5、得到类似-You-cannot-start-a-load-for-a-destroyed-activity-这样的异常" class="headerlink" title="5、得到类似 You cannot start a load for a destroyed activity 这样的异常"></a>5、得到类似 <code>You cannot start a load for a destroyed activity</code> 这样的异常</h2><p>解决这个办法只需在使用 Glide 时记住：不要再非主线程里面使用 Glide 加载图片，如果真的使用了，请把 context 参数换成 getApplicationContext。</p>
<h2 id="6、一些使用技巧"><a href="#6、一些使用技巧" class="headerlink" title="6、一些使用技巧"></a>6、一些使用技巧</h2><p><strong>1. 列表预加载</strong><br>如果你想让列表预加载的话，不妨试一下ListPreloader这个类。  </p>
<p><strong>2. 列表滑动时取消请求</strong><br>当列表在滑动的时候，调用 pauseRequests() 取消请求，滑动停止时，调用 resumeRequests() 恢复请求。  </p>
<p><code>Glide.with(context).resumeRequests()</code><br><code>Glide.with(context).pauseRequests()</code></p>
<p><strong>3. 清除所有加载请求</strong><br>当你想清除掉所有的图片加载请求时，可以使用 Glide.clear() 这个方法。</p>
<p><strong>4. Glide特效转换库</strong><br><a href="https://github.com/wasabeef/glide-transformations">glide-transformations</a> 一个基于Glide的transformation库，拥有裁剪，着色，模糊，滤镜等多种转换效果。  </p>
<p><strong>5. Palette 库</strong><br><a href="https://github.com/florent37/GlidePalette">GlidePalette</a> 一个在Glide加载时很方便使用Palette的库。</p>
<blockquote>
<p>参考来源：<br><a href="http://blog.csdn.net/easion_zms/article/details/50263409">http://blog.csdn.net/easion_zms/article/details/50263409</a><br><a href="http://www.jianshu.com/p/4a3177b57949">http://www.jianshu.com/p/4a3177b57949</a><br><a href="http://answerzhao.github.io/2016/10/16/issues%20in%20using%20Glide/">http://answerzhao.github.io/2016/10/16/issues%20in%20using%20Glide/</a><br><a href="http://blog.csdn.net/s569646547/article/details/54090034">http://blog.csdn.net/s569646547/article/details/54090034</a>  </p>
</blockquote>
]]></content>
      <categories>
        <category>第三方框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Glide</tag>
        <tag>图片加载</tag>
        <tag>第三方框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Gson使用指南（一）</title>
    <url>/2016/10/11/Gson_Guide1/</url>
    <content><![CDATA[<blockquote>
<p>原文链接：<a href="http://www.jianshu.com/p/e740196225a4">http://www.jianshu.com/p/e740196225a4</a>  </p>
</blockquote>
<p>JSON (<a href="http://json.org/json-zh.html">官网</a>) 是一种文本形式的数据交换格式，它比XML更轻量、比二进制容易阅读和编写，调式也更加方便。其重要性不言而喻。解析和生成的方式很多，Java中最常用的类库有：JSON-Java、Gson、Jackson、FastJson等。  </p>
<span id="more"></span>

<p><strong>该系列其它文章</strong><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide1/">Gson使用指南（一）</a><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide2/">Gson使用指南（二）</a><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide3/">Gson使用指南（三）</a><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide4/">Gson使用指南（四）</a>  </p>
<blockquote>
<p>注：此系列基于Gson 2.4。</p>
</blockquote>
<p><strong>本篇文章的主要内容：</strong></p>
<ul>
<li>Gson的基本用法</li>
<li>属性重命名 @SerializedName 注解的使用</li>
<li>Gson中使用泛型  </li>
</ul>
<h2 id="一、Gson的基本用法"><a href="#一、Gson的基本用法" class="headerlink" title="一、Gson的基本用法"></a>一、Gson的基本用法</h2><p>Gson提供了fromJson() 和toJson() 两个直接用于解析和生成的方法，前者实现反序列化，后者实现了序列化。同时每个方法都提供了重载方法，我常用的总共有5个。  </p>
<h3 id="基本数据类型的解析"><a href="#基本数据类型的解析" class="headerlink" title="基本数据类型的解析"></a>基本数据类型的解析</h3><pre><code>Gson gson = new Gson();
int i = gson.fromJson(&quot;100&quot;, int.class);              //100
double d = gson.fromJson(&quot;\&quot;99.99\&quot;&quot;, double.class);  //99.99
boolean b = gson.fromJson(&quot;true&quot;, boolean.class);     // true
String str = gson.fromJson(&quot;String&quot;, String.class);   // String  
</code></pre>
<blockquote>
<p>注：不知道你是否注意到了第2、3行有什么不一样没</p>
</blockquote>
<h3 id="基本数据类型的生成"><a href="#基本数据类型的生成" class="headerlink" title="基本数据类型的生成"></a>基本数据类型的生成</h3><pre><code>Gson gson = new Gson();
String jsonNumber = gson.toJson(100);       // 100
String jsonBoolean = gson.toJson(false);    // false
String jsonString = gson.toJson(&quot;String&quot;); //&quot;String&quot;  
</code></pre>
<h3 id="POJO类的生成与解析"><a href="#POJO类的生成与解析" class="headerlink" title="POJO类的生成与解析"></a>POJO类的生成与解析</h3><pre><code>public class User &#123;
    //省略其它
    public String name;
    public int age;
    public String emailAddress;
&#125;  
</code></pre>
<p>生成JSON：</p>
<pre><code>Gson gson = new Gson();
User user = new User(&quot;怪盗kidou&quot;,24);
String jsonObject = gson.toJson(user); // &#123;&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24&#125;  
</code></pre>
<p>解析JSON：</p>
<pre><code>Gson gson = new Gson();
String jsonString = &quot;&#123;\&quot;name\&quot;:\&quot;怪盗kidou\&quot;,\&quot;age\&quot;:24&#125;&quot;;
User user = gson.fromJson(jsonString, User.class);  
</code></pre>
<h2 id="二、属性重命名-SerializedName-注解的使用"><a href="#二、属性重命名-SerializedName-注解的使用" class="headerlink" title="二、属性重命名 @SerializedName 注解的使用"></a>二、属性重命名 @SerializedName 注解的使用</h2><p>从上面POJO的生成与解析可以看出json的字段和值是的名称和类型是一一对应的，但也有一定容错机制(如第一个例子第3行将字符串的99.99转成double型，你可别告诉我都是字符串啊)，但有时候也会出现一些不和谐的情况，如：<br>期望的json格式</p>
<pre><code>&#123;&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;emailAddress&quot;:&quot;ikidou@example.com&quot;&#125;  
</code></pre>
<p>实际</p>
<pre><code>&#123;&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;email_address&quot;:&quot;ikidou@example.com&quot;&#125;  
</code></pre>
<p>这对于使用PHP作为后台开发语言时很常见的情况，php和js在命名时一般采用下划线风格，而Java中一般采用的驼峰法，让后台的哥们改吧 前端和后台都不爽，但要自己使用下划线风格时我会感到不适应，怎么办?难到没有两全齐美的方法么?  </p>
<p>我们知道Gson在序列化和反序列化时需要使用反射，说到反射就不得不想到注解,一般各类库都将注解放到annotations包下，打开源码在com.google.gson包下果然有一个annotations，里面有一个SerializedName的注解类，这应该就是我们要找的。  </p>
<p>那么对于json中email_address这个属性对应POJO的属性则变成：  </p>
<pre><code>@SerializedName(&quot;email_address&quot;)
public String emailAddress;  
</code></pre>
<p>这样的话，很好的保留了前端、后台、Android/java各自的命名习惯。  </p>
<p>你以为这样就完了么?  </p>
<p>如果接中设计不严谨或者其它地方可以重用该类，其它字段都一样，就emailAddress 字段不一样，比如有下面三种情况那怎么?重新写一个?   </p>
<pre><code>&#123;&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;emailAddress&quot;:&quot;ikidou@example.com&quot;&#125;
&#123;&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;email_address&quot;:&quot;ikidou@example.com&quot;&#125;
&#123;&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;email&quot;:&quot;ikidou@example.com&quot;&#125;  
</code></pre>
<h3 id="为POJO字段提供备选属性名"><a href="#为POJO字段提供备选属性名" class="headerlink" title="为POJO字段提供备选属性名"></a>为POJO字段提供备选属性名</h3><p>SerializedName注解提供了两个属性，上面用到了其中一个，别外还有一个属性alternate，接收一个String数组。  </p>
<blockquote>
<p>注：alternate需要2.4版本</p>
</blockquote>
<pre><code>@SerializedName(value = &quot;emailAddress&quot;, alternate = &#123;&quot;email&quot;, &quot;email_address&quot;&#125;)
public String emailAddress;  
</code></pre>
<p>当上面的三个属性(email_address、email、emailAddress)都中出现任意一个时均可以得到正确的结果。  </p>
<blockquote>
<p>注：当多种情况同时出时，以最后一个出现的值为准。  </p>
</blockquote>
<pre><code>Gson gson = new Gson();
String json = &quot;&#123;\&quot;name\&quot;:\&quot;怪盗kidou\&quot;,\&quot;age\&quot;:24,\&quot;emailAddress\&quot;:\&quot;ikidou_1@example.com\&quot;,\&quot;email\&quot;:\&quot;ikidou_2@example.com\&quot;,\&quot;email_address\&quot;:\&quot;ikidou_3@example.com\&quot;&#125;&quot;;
User user = gson.fromJson(json, User.class);
System.out.println(user.emailAddress); // ikidou_3@example.com  
</code></pre>
<h2 id="三、Gson中使用泛型"><a href="#三、Gson中使用泛型" class="headerlink" title="三、Gson中使用泛型"></a>三、Gson中使用泛型</h2><p>上面了解的JSON中的Number、boolean、Object和String，现在说一下Array。  </p>
<p>例：JSON字符串数组</p>
<pre><code>[&quot;Android&quot;,&quot;Java&quot;,&quot;PHP&quot;]  
</code></pre>
<p>当我们要通过Gson解析这个json时，一般有两种方式：使用数组，使用List。而List对于增删都是比较方便的，所以实际使用是还是List比较多。</p>
<p>数组比较简单</p>
<pre><code>Gson gson = new Gson();
String jsonArray = &quot;[\&quot;Android\&quot;,\&quot;Java\&quot;,\&quot;PHP\&quot;]&quot;;
String[] strings = gson.fromJson(jsonArray, String[].class);  
</code></pre>
<p>但对于List将上面的代码中的 String[].class 直接改为 List<String>.class 是行不通的。对于Java来说List<String> 和List<User> 这俩个的字节码文件只一个那就是List.class，这是Java泛型使用时要注意的问题 泛型擦除。</p>
<p>为了解决的上面的问题，Gson为我们提供了TypeToken来实现对泛型的支持，所以当我们希望使用将以上的数据解析为List<String>时需要这样写。</p>
<pre><code>Gson gson = new Gson();
String jsonArray = &quot;[\&quot;Android\&quot;,\&quot;Java\&quot;,\&quot;PHP\&quot;]&quot;;
String[] strings = gson.fromJson(jsonArray, String[].class);
List&lt;String&gt; stringList = gson.fromJson(jsonArray, new TypeToken&lt;List&lt;String&gt;&gt;() &#123;&#125;.getType());  
</code></pre>
<blockquote>
<p>注：TypeToken的构造方法是protected修饰的,所以上面才会写成new TypeToken&lt;List<String>&gt;() {}.getType() 而不是  new TypeToken&lt;List<String>&gt;().getType()</p>
</blockquote>
<h3 id="泛型解析对接口POJO的设计影响"><a href="#泛型解析对接口POJO的设计影响" class="headerlink" title="泛型解析对接口POJO的设计影响"></a>泛型解析对接口POJO的设计影响</h3><p>泛型的引入可以减少无关的代码，如我现在所在公司接口返回的数据分为两类：</p>
<pre><code>&#123;&quot;code&quot;:&quot;0&quot;,&quot;message&quot;:&quot;success&quot;,&quot;data&quot;:&#123;&#125;&#125;  

&#123;&quot;code&quot;:&quot;0&quot;,&quot;message&quot;:&quot;success&quot;,&quot;data&quot;:[]&#125;  
</code></pre>
<p>我们真正需要的data所包含的数据，而code只使用一次，message则几乎不用。如果Gson不支持泛型或不知道Gson支持泛型的同学一定会这么定义POJO。</p>
<pre><code>public class UserResponse &#123;
    public int code;
    public String message;
    public User data;
&#125;  
</code></pre>
<p>当其它接口的时候又重新定义一个XXResponse将data的类型改成XX，很明显code，和message被重复定义了多次，通过泛型的话我们可以将code和message字段抽取到一个Result的类中，这样我们只需要编写data字段所对应的POJO即可，更专注于我们的业务逻辑。如：</p>
<pre><code>public class Result&lt;T&gt; &#123;
    public int code;
    public String message;
    public T data;
&#125;  
</code></pre>
<p>那么对于data字段是User时则可以写为 Result<User> ,当是个列表的时候为 Result&lt;List<User>&gt;，其它同理。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文主要通过代码向各位读者讲解了Gson的基本用法，以后还会更新更多更高级的用法，如果你还不熟悉 <strong>注解</strong>和<strong>泛型</strong> 那么你要多多努力啦。</p>
<p>如果你有其它的想了解的内容(不限于Gson)请给我留言评论，水平有限，欢迎拍砖。</p>
<h2 id="4月6日补充"><a href="#4月6日补充" class="headerlink" title="4月6日补充"></a>4月6日补充</h2><p>有说看不懂Result那段怎么个简化法，下面给个两个完整的例子，User和List<User> 。</p>
<p>没有引入泛型之前时写法：</p>
<pre><code>public class UserResult &#123;
    public int code;
    public String message;
    public User data;
&#125;
//=========
public class UserListResult &#123;
    public int code;
    public String message;
    public List&lt;User&gt; data;
&#125;
//=========
String json = &quot;&#123;..........&#125;&quot;;
Gson gson = new Gson();
UserResult userResult = gson.fromJson(json,UserResult.class);
User user = userResult.data;

UserListResult userListResult = gson.fromJson(json,UserListResult.class);
List&lt;User&gt; users = userListResult.data;  
</code></pre>
<p>上面有两个类UserResult和UserListResult，有两个字段重复，一两个接口就算了，如果有上百个怎么办?不得累死?所以引入泛型。</p>
<pre><code>//不再重复定义Result类
Type userType = new TypeToken&lt;Result&lt;User&gt;&gt;()&#123;&#125;.getType();
Result&lt;User&gt; userResult = gson.fromJson(json,userType);
User user = userResult.data;

Type userListType = new TypeToken&lt;Result&lt;List&lt;User&gt;&gt;&gt;()&#123;&#125;.getType();
Result&lt;List&lt;User&gt;&gt; userListResult = gson.fromJson(json,userListType);
List&lt;User&gt; users = userListResult.data;  
</code></pre>
<p>看出区别了么?引入了泛型之后虽然要多写一句话用于获取泛型信息，但是返回值类型很直观，也少定义了很多无关类。</p>
]]></content>
      <categories>
        <category>第三方框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>第三方框架</tag>
        <tag>Gson</tag>
      </tags>
  </entry>
  <entry>
    <title>Gson使用指南（二）</title>
    <url>/2016/10/11/Gson_Guide2/</url>
    <content><![CDATA[<p><strong>本次的主要内容：</strong></p>
<ul>
<li>Gson的流式反序列化</li>
<li>Gson的流式序列化</li>
<li>　使用GsonBuilder导出null值、格式化输出、日期时间及其它小功能　　</li>
</ul>
<span id="more"></span>

<blockquote>
<p>原文地址：<a href="http://www.jianshu.com/p/c88260adaf5e">http://www.jianshu.com/p/c88260adaf5e</a>  </p>
</blockquote>
<p><strong>该系列其它文章</strong><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide1/">Gson使用指南（一）</a><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide2/">Gson使用指南（二）</a><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide3/">Gson使用指南（三）</a><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide4/">Gson使用指南（四）</a>  </p>
<blockquote>
<p>注：此系列基于Gson 2.4。</p>
</blockquote>
<p>上一篇文章 <a href="http://ocnyang.com/2016/10/11/Gson_Guide1/">Gson使用指南（一）</a> 我们了解了Gson的基础用法，这次我们继续深入了解Gson的使用方法。</p>
<h2 id="一、Gson的流式反序列化"><a href="#一、Gson的流式反序列化" class="headerlink" title="一、Gson的流式反序列化"></a>一、Gson的流式反序列化</h2><h3 id="自动方式"><a href="#自动方式" class="headerlink" title="自动方式"></a>自动方式</h3><blockquote>
<p>Gson提供了fromJson()和toJson() 两个直接用于解析和生成的方法，前者实现反序列化，后者实现了序列化。同时每个方法都提供了重载方法，我常用的总共有5个。  </p>
</blockquote>
<p>这是我在上一篇文章开头说的，但我到最后也一直没有是哪5个，这次我给列出来之后，你就知道这次讲的是哪个了。</p>
<pre><code>Gson.toJson(Object);
Gson.fromJson(Reader,Class);
Gson.fromJson(String,Class);
Gson.fromJson(Reader,Type);
Gson.fromJson(String,Type);  
</code></pre>
<p>好了，本节结束！</p>
<h3 id="手动方式"><a href="#手动方式" class="headerlink" title="手动方式"></a>手动方式</h3><p>手动的方式就是使用stream包下的JsonReader类来手动实现反序列化，和Android中使用pull解析XML是比较类似的。</p>
<pre><code>String json = &quot;&#123;\&quot;name\&quot;:\&quot;怪盗kidou\&quot;,\&quot;age\&quot;:\&quot;24\&quot;&#125;&quot;;
User user = new User();
JsonReader reader = new JsonReader(new StringReader(json));
reader.beginObject(); // throws IOException
while (reader.hasNext()) &#123;
    String s = reader.nextName();
    switch (s) &#123;
        case &quot;name&quot;:
            user.name = reader.nextString();
            break;
        case &quot;age&quot;:
            user.age = reader.nextInt(); //自动转换
            break;
        case &quot;email&quot;:
            user.email = reader.nextString();
            break;
    &#125;
&#125;
reader.endObject(); // throws IOException
System.out.println(user.name);  // 怪盗kidou
System.out.println(user.age);   // 24
System.out.println(user.email); // ikidou@example.com  
</code></pre>
<p>其实自动方式最终都是通过JsonReader来实现的，如果第一个参数是String类型，那么Gson会创建一个StringReader转换成流操作。</p>
<p><img src="http://img.shedoor.net/gson/gson_guide2_1.png" alt="Gson流式解析">  </p>
<h2 id="二、Gson的流式序列化"><a href="#二、Gson的流式序列化" class="headerlink" title="二、Gson的流式序列化"></a>二、Gson的流式序列化</h2><h3 id="自动方式-1"><a href="#自动方式-1" class="headerlink" title="自动方式"></a>自动方式</h3><p><img src="http://img.shedoor.net/gson/gson_guide2_2.png" alt="Gson.toJson方法列表">  </p>
<p>所以啊，学会利用IDE的自动完成是多么重要这下知道了吧！<br>可以看出用红框选中的部分就是我们要找的东西。  </p>
<p>提示：OutputStream和Writer都实现了Appendable接口。  </p>
<pre><code>Gson gson = new Gson();
User user = new User(&quot;怪盗kidou&quot;,24,&quot;ikidou@example.com&quot;);
gson.toJson(user,System.out); // 写到控制台  
</code></pre>
<h3 id="手动方式-1"><a href="#手动方式-1" class="headerlink" title="手动方式"></a>手动方式</h3><pre><code>JsonWriter writer = new JsonWriter(new OutputStreamWriter(System.out));
writer.beginObject() // throws IOException
        .name(&quot;name&quot;).value(&quot;怪盗kidou&quot;)
        .name(&quot;age&quot;).value(24)
        .name(&quot;email&quot;).nullValue() //演示null
        .endObject(); // throws IOException
writer.flush(); // throws IOException
//&#123;&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;email&quot;:null&#125;  
</code></pre>
<p>提示：除了beginObject、endObject还有beginArray和endArray，两者可以相互嵌套，注意配对即可。beginArray后不可以调用name方法，同样beginObject后在调用value之前必须要调用name方法。</p>
<h2 id="三、-使用GsonBuilder导出null值、格式化输出、日期时间"><a href="#三、-使用GsonBuilder导出null值、格式化输出、日期时间" class="headerlink" title="三、 使用GsonBuilder导出null值、格式化输出、日期时间"></a>三、 使用GsonBuilder导出null值、格式化输出、日期时间</h2><p>一般情况下Gson类提供的 API已经能满足大部分的使用场景，但我们需要更多更特殊、更强大的功能时，这时候就引入一个新的类 GsonBuilder。</p>
<p>GsonBuilder从名上也能知道是用于构建Gson实例的一个类，要想改变Gson默认的设置必须使用该类配置Gson。</p>
<h3 id="GsonBuilder用法"><a href="#GsonBuilder用法" class="headerlink" title="GsonBuilder用法"></a>GsonBuilder用法</h3><pre><code>Gson gson = new GsonBuilder()
               //各种配置
               .create(); //生成配置好的Gson  
</code></pre>
<p>Gson在默认情况下是不动导出值null的键的，如：</p>
<pre><code>public class User &#123;
    //省略其它
    public String name;
    public int age;
    public String email;
&#125;
Gson gson = new Gson();
User user = new User(&quot;怪盗kidou&quot;,24);
System.out.println(gson.toJson(user)); //&#123;&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24&#125;  
</code></pre>
<p>可以看出，email字段是没有在json中出现的，当我们在调试是、需要导出完整的json串时或API接中要求没有值必须用Null时，就会比较有用。</p>
<p>使用方法：</p>
<pre><code>Gson gson = new GsonBuilder()
        .serializeNulls()
        .create();
User user = new User(&quot;怪盗kidou&quot;, 24);
System.out.println(gson.toJson(user)); //&#123;&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;email&quot;:null&#125;  
</code></pre>
<h3 id="格式化输出、日期时间及其它："><a href="#格式化输出、日期时间及其它：" class="headerlink" title="格式化输出、日期时间及其它："></a>格式化输出、日期时间及其它：</h3><p>这些都比较简单就不一一分开写了。</p>
<pre><code>Gson gson = new GsonBuilder()
        //序列化null
        .serializeNulls()
        // 设置日期时间格式，另有2个重载方法
        // 在序列化和反序化时均生效
        .setDateFormat(&quot;yyyy-MM-dd&quot;)
        // 禁此序列化内部类
        .disableInnerClassSerialization()
        //生成不可执行的Json（多了 )]&#125;&#39; 这4个字符）
        .generateNonExecutableJson()
        //禁止转义html标签
        .disableHtmlEscaping()
        //格式化输出
        .setPrettyPrinting()
        .create();  
</code></pre>
<p>注意：内部类(Inner Class)和嵌套类(Nested Class)的区别</p>
<p>这次文章就到这里，欢迎提问互动，如有不对的地方请指正。</p>
<h2 id="下篇文章内容提要"><a href="#下篇文章内容提要" class="headerlink" title="下篇文章内容提要"></a>下篇文章内容提要</h2><ul>
<li><p>字段过滤的几种方法  </p>
<ul>
<li>基于@Expose注解</li>
<li>基于访问修饰符</li>
<li>基于版本</li>
<li>自定义规则  </li>
</ul>
</li>
<li><p>POJO与JSON的字段映射规则</p>
</li>
</ul>
]]></content>
      <categories>
        <category>第三方框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>第三方框架</tag>
        <tag>Gson</tag>
      </tags>
  </entry>
  <entry>
    <title>Gson使用指南（三）</title>
    <url>/2016/10/11/Gson_Guide3/</url>
    <content><![CDATA[<p><strong>本次的主要内容：</strong></p>
<ul>
<li>字段过滤的几种方法<ul>
<li>基于@Expose注解</li>
<li>基于版本</li>
<li>基于访问修饰符</li>
<li>基于策略（作者最常用）</li>
</ul>
</li>
<li>POJO与JSON的字段映射规则  </li>
</ul>
<span id="more"></span>


<blockquote>
<p>原文地址：<a href="http://www.jianshu.com/p/0e40a52c0063">http://www.jianshu.com/p/0e40a52c0063</a>  </p>
</blockquote>
<p><strong>该系列其它文章</strong><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide1/">Gson使用指南（一）</a><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide2/">Gson使用指南（二）</a><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide3/">Gson使用指南（三）</a><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide4/">Gson使用指南（四）</a>  </p>
<blockquote>
<p>注：此系列基于Gson 2.4。</p>
</blockquote>
<h2 id="一、字段过滤的几种方法"><a href="#一、字段过滤的几种方法" class="headerlink" title="一、字段过滤的几种方法"></a>一、字段过滤的几种方法</h2><p>字段过滤Gson中比较常用的技巧，特别是在Android中，在处理业务逻辑时可能需要在设置的POJO中加入一些字段，但显然在序列化的过程中是不需要的，并且如果序列化还可能带来一个问题就是 <strong>循环引用</strong> ，那么在用Gson序列化之前为不防止这样的事件情发生，你不得不作另外的处理。</p>
<p>以一个商品分类Category 为例。</p>
<pre><code>&#123;
  &quot;id&quot;: 1,
  &quot;name&quot;: &quot;电脑&quot;,
  &quot;children&quot;: [
    &#123;
      &quot;id&quot;: 100,
      &quot;name&quot;: &quot;笔记本&quot;
    &#125;,
    &#123;
      &quot;id&quot;: 101,
      &quot;name&quot;: &quot;台式机&quot;
    &#125;
  ]
&#125;  
</code></pre>
<p>一个大分类，可以有很多小分类，那么显然我们在设计Category类时Category本身既可以是大分类，也可以是小分类。</p>
<pre><code>public class Category &#123;
    public int id;
    public String name;
    public List&lt;Category&gt; children;
&#125;  
</code></pre>
<p>但是为了处理业务，我们还需要在子分类中保存父分类，最终会变成下面的情况</p>
<pre><code>public class Category &#123;
    public int id;
    public String name;
    public List&lt;Category&gt; children;
    //因业务需要增加，但并不需要序列化
    public Category parent;
&#125;  
</code></pre>
<p>但是上面的parent字段是因业务需要增加的，那么在序列化是并不需要，所以在序列化时就必须将其排除，那么在Gson中如何排除符合条件的字段呢?下面提供4种方法，大家可根据需要自行选择合适的方式。</p>
<h3 id="基于-Expose注解"><a href="#基于-Expose注解" class="headerlink" title="基于@Expose注解"></a>基于@Expose注解</h3><p>@Expose提供了两个属性，且都有默认值，开发者可以根据需要设置不同的值。</p>
<p><img src="http://img.shedoor.net/gson/gson_guide3_1.png" alt="@Expose">  </p>
<p>@Expose 注解从名字上就可以看出是暴露的意思，所以该注解是用于对处暴露字段的。可是我们以前用Gson的时候也没有@Expose 注解还是不正确的序列化为JSON了么?是的，所以该注解在使用new Gson() 时是不会发生作用。毕竟最常用的API要最简单，所以该注解必须和GsonBuilder配合使用。</p>
<p>使用方法： 简单说来就是需要导出的字段上加上@Expose 注解，不导出的字段不加。注意是不导出的不加。</p>
<pre><code>@Expose //
@Expose(deserialize = true,serialize = true) //序列化和反序列化都都生效
@Expose(deserialize = true,serialize = false) //反序列化时生效
@Expose(deserialize = false,serialize = true) //序列化时生效
@Expose(deserialize = false,serialize = false) // 和不写一样  
</code></pre>
<blockquote>
<p>注：根据上面的图片可以得出，所有值为true的属性都是可以不写的。</p>
</blockquote>
<p>拿上面的例子来说就是</p>
<pre><code>public class Category &#123;
    @Expose public int id;
    @Expose public String name;
    @Expose public List&lt;Category&gt; children;
    //不需要序列化,所以不加 @Expose 注解，
    //等价于 @Expose(deserialize = false,serialize = false)
    public Category parent;
&#125;  
</code></pre>
<p>在使用Gson时也不能只是简单的new Gson()了。</p>
<pre><code>Gson gson = new GsonBuilder()
        .excludeFieldsWithoutExposeAnnotation()
        .create();
gson.toJson(category);  
</code></pre>
<h3 id="基于版本"><a href="#基于版本" class="headerlink" title="基于版本"></a>基于版本</h3><p>Gson在对基于版本的字段导出提供了两个注解 @Since 和 @Until,和GsonBuilder.setVersion(Double)配合使用。@Since 和 @Until都接收一个Double值。</p>
<p><img src="http://img.shedoor.net/gson/gson_guide3_2.png" alt="Since和Until注解">   </p>
<p>使用方法：当前版本(GsonBuilder中设置的版本) 大于等于Since的值时该字段导出，小于Until的值时该该字段导出。</p>
<pre><code>class SinceUntilSample &#123;
    @Since(4)
    public String since;
    @Until(5)
    public String until;
&#125;

public void sineUtilTest(double version)&#123;
        SinceUntilSample sinceUntilSample = new SinceUntilSample();
        sinceUntilSample.since = &quot;since&quot;;
        sinceUntilSample.until = &quot;until&quot;;
        Gson gson = new GsonBuilder().setVersion(version).create();
        System.out.println(gson.toJson(sinceUntilSample));
&#125;
//当version &lt;4时，结果：&#123;&quot;until&quot;:&quot;until&quot;&#125;
//当version &gt;=4 &amp;&amp; version &lt;5时，结果：&#123;&quot;since&quot;:&quot;since&quot;,&quot;until&quot;:&quot;until&quot;&#125;
//当version &gt;=5时，结果：&#123;&quot;since&quot;:&quot;since&quot;&#125;  
</code></pre>
<blockquote>
<p>注：当一个字段被同时注解时，需两者同时满足条件。</p>
</blockquote>
<h3 id="基于访问修饰符"><a href="#基于访问修饰符" class="headerlink" title="基于访问修饰符"></a>基于访问修饰符</h3><p>什么是修饰符? public、static 、final、private、protected 这些就是，所以这种方式也是比较特殊的。<br>使用方式：</p>
<pre><code>class ModifierSample &#123;
    final String finalField = &quot;final&quot;;
    static String staticField = &quot;static&quot;;
    public String publicField = &quot;public&quot;;
    protected String protectedField = &quot;protected&quot;;
    String defaultField = &quot;default&quot;;
    private String privateField = &quot;private&quot;;
&#125;  
</code></pre>
<p>使用GsonBuilder.excludeFieldsWithModifiers构建gson,支持int形的可变参数，值由java.lang.reflect.Modifier提供，下面的程序排除了privateField 、 finalField 和staticField 三个字段。</p>
<pre><code>ModifierSample modifierSample = new ModifierSample();
Gson gson = new GsonBuilder()
        .excludeFieldsWithModifiers(Modifier.FINAL, Modifier.STATIC, Modifier.PRIVATE)
        .create();
System.out.println(gson.toJson(modifierSample));
// 结果：&#123;&quot;publicField&quot;:&quot;public&quot;,&quot;protectedField&quot;:&quot;protected&quot;,&quot;defaultField&quot;:&quot;default&quot;&#125;  
</code></pre>
<p>到此为止，Gson提供的所有注解就还有一个@JsonAdapter没有介绍了，而@JsonAdapter将和TypeAdapter将作为该系列第4篇也是最后一篇文章的主要内容。</p>
<h3 id="基于策略（自定义规则）"><a href="#基于策略（自定义规则）" class="headerlink" title="基于策略（自定义规则）"></a>基于策略（自定义规则）</h3><p>上面介绍的了3种排除字段的方法，说实话我除了@Expose以外，其它的都是只在Demo用上过，用得最多的就是马上要介绍的自定义规则，好处是功能强大、灵活，缺点是相比其它3种方法稍麻烦一点，但也仅仅只是想对其它3种稍麻烦一点而已。</p>
<p>基于策略是利用Gson提供的ExclusionStrategy接口，同样需要使用GsonBuilder,相关API 2个，分别是addSerializationExclusionStrategy 和addDeserializationExclusionStrategy 分别针对序列化和反序化时。这里以序列化为例。</p>
<p>例如：</p>
<pre><code>Gson gson = new GsonBuilder()
        .addSerializationExclusionStrategy(new ExclusionStrategy() &#123;
            @Override
            public boolean shouldSkipField(FieldAttributes f) &#123;
                // 这里作判断，决定要不要排除该字段,return true为排除
                if (&quot;finalField&quot;.equals(f.getName())) return true; //按字段名排除
                Expose expose = f.getAnnotation(Expose.class);
                if (expose != null &amp;&amp; expose.deserialize() == false) return true; //按注解排除
                return false;
            &#125;
            @Override
            public boolean shouldSkipClass(Class&lt;?&gt; clazz) &#123;
                // 直接排除某个类 ，return true为排除
                return (clazz == int.class || clazz == Integer.class);
            &#125;
        &#125;)
        .create();  
</code></pre>
<p>有没有很强大?</p>
<h2 id="二、-POJO与JSON的字段映射规则"><a href="#二、-POJO与JSON的字段映射规则" class="headerlink" title="二、 POJO与JSON的字段映射规则"></a>二、 POJO与JSON的字段映射规则</h2><p>之前在<strong>Gson使用指南（二）</strong> 属性重命名时 介绍了@SerializedName这个注解的使用，本节的内容与上一次差不多的，但既然叫 <strong>映射规则</strong> 那么说的自然是有规律的情况。<br>还是之前User的例子，已经去除所有注解：</p>
<pre><code>User user = new User(&quot;怪盗kidou&quot;, 24);
user.emailAddress = &quot;ikidou@example.com&quot;;  
</code></pre>
<p>GsonBuilder提供了FieldNamingStrategy接口和setFieldNamingPolicy和setFieldNamingStrategy 两个方法。</p>
<h3 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h3><p>GsonBuilder.setFieldNamingPolicy 方法与Gson提供的另一个枚举类FieldNamingPolicy配合使用，该枚举类提供了5种实现方式分别为：</p>
<p><img src="http://img.shedoor.net/gson/gson_guide3_3.png">  </p>
<h3 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h3><p>GsonBuilder.setFieldNamingStrategy 方法需要与Gson提供的FieldNamingStrategy接口配合使用，用于实现将POJO的字段与JSON的字段相对应。上面的FieldNamingPolicy实际上也实现了FieldNamingStrategy接口，也就是说FieldNamingPolicy也可以使用setFieldNamingStrategy方法。</p>
<p>用法：</p>
<pre><code>Gson gson = new GsonBuilder()
        .setFieldNamingStrategy(new FieldNamingStrategy() &#123;
            @Override
            public String translateName(Field f) &#123;
                //实现自己的规则
                return null;
            &#125;
        &#125;)
        .create();  
</code></pre>
<p>注意： @SerializedName注解拥有最高优先级，在加有@SerializedName注解的字段上FieldNamingStrategy不生效！</p>
<p>本文完</p>
<h2 id="下期预告（本系列最终篇）："><a href="#下期预告（本系列最终篇）：" class="headerlink" title="下期预告（本系列最终篇）："></a>下期预告（本系列最终篇）：</h2><ul>
<li>无所不能的TypeAdapter</li>
</ul>
]]></content>
      <categories>
        <category>第三方框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>第三方框架</tag>
        <tag>Gson</tag>
      </tags>
  </entry>
  <entry>
    <title>Gson使用指南（四）</title>
    <url>/2016/10/11/Gson_Guide4/</url>
    <content><![CDATA[<p><strong>本次的主要内容：</strong></p>
<ul>
<li>TypeAdapter</li>
<li>JsonSerializer与JsonDeserializer</li>
<li>TypeAdapterFactory</li>
<li>@JsonAdapter注解</li>
<li>TypeAdapter与 JsonSerializer、JsonDeserializer对比</li>
<li>TypeAdapter实例</li>
<li>结语  </li>
</ul>
<span id="more"></span>


<blockquote>
<p>原文地址：<a href="http://www.jianshu.com/p/3108f1e44155">http://www.jianshu.com/p/3108f1e44155</a>  </p>
</blockquote>
<p><strong>该系列其它文章</strong><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide1/">Gson使用指南（一）</a><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide2/">Gson使用指南（二）</a><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide3/">Gson使用指南（三）</a><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide4/">Gson使用指南（四）</a>  </p>
<blockquote>
<p>注：此系列基于Gson 2.4。</p>
</blockquote>
<h2 id="一、TypeAdapter"><a href="#一、TypeAdapter" class="headerlink" title="一、TypeAdapter"></a>一、TypeAdapter</h2><p><code>TypeAdapter</code> 是Gson自2.0（源码注释上说的是2.1）开始版本提供的一个抽象类，用于接管某种类型的序列化和反序列化过程，包含两个注要方法 <code>write(JsonWriter,T)</code> 和 <code>read(JsonReader)</code> 其它的方法都是final方法并最终调用这两个抽象方法。</p>
<pre><code>public abstract class TypeAdapter&lt;T&gt; &#123;
    public abstract void write(JsonWriter out, T value) throws IOException;
    public abstract T read(JsonReader in) throws IOException;
    //其它final 方法就不贴出来了，包括`toJson`、`toJsonTree`、`toJson`和`nullSafe`方法。
&#125;  
</code></pre>
<blockquote>
<p>注意：TypeAdapter 以及 JsonSerializer 和 JsonDeserializer 都需要与 GsonBuilder.registerTypeAdapter 示或GsonBuilder.registerTypeHierarchyAdapter配合使用，下面将不再重复说明。</p>
</blockquote>
<p>使用示例：</p>
<pre><code>User user = new User(&quot;怪盗kidou&quot;, 24);
user.emailAddress = &quot;ikidou@example.com&quot;;
Gson gson = new GsonBuilder()
        //为User注册TypeAdapter
        .registerTypeAdapter(User.class, new UserTypeAdapter())
        .create();
System.out.println(gson.toJson(user));  
</code></pre>
<p>UserTypeAdapter的定义：</p>
<pre><code>public class UserTypeAdapter extends TypeAdapter&lt;User&gt; &#123;

    @Override
    public void write(JsonWriter out, User value) throws IOException &#123;
        out.beginObject();
        out.name(&quot;name&quot;).value(value.name);
        out.name(&quot;age&quot;).value(value.age);
        out.name(&quot;email&quot;).value(value.email);
        out.endObject();
    &#125;

    @Override
    public User read(JsonReader in) throws IOException &#123;
        User user = new User();
        in.beginObject();
        while (in.hasNext()) &#123;
            switch (in.nextName()) &#123;
                case &quot;name&quot;:
                    user.name = in.nextString();
                    break;
                case &quot;age&quot;:
                    user.age = in.nextInt();
                    break;
                case &quot;email&quot;:
                case &quot;email_address&quot;:
                case &quot;emailAddress&quot;:
                    user.email = in.nextString();
                    break;
            &#125;
        &#125;
        in.endObject();
        return user;
    &#125;
&#125;  
</code></pre>
<p>当我们为User.class 注册了 TypeAdapter之后，只要是操作User.class 那些之前介绍的@SerializedName 、FieldNamingStrategy、Since、Until、Expos通通都黯然失色，失去了效果，只会调用我们实现的UserTypeAdapter.write(JsonWriter, User) 方法，我想怎么写就怎么写。</p>
<p>再说一个场景，在该系列的第一篇文章就说到了Gson有一定的容错机制，比如将字符串 “24” 转成int 的24,但如果有些情况下给你返了个空字符串怎么办（有人给我评论问到这个问题）?虽然这是服务器端的问题，但这里我们只是做一个示范。</p>
<p>int型会出错是吧，根据我们上面介绍的，我注册一个TypeAdapter 把 序列化和反序列化的过程接管不就行了?</p>
<pre><code>Gson gson = new GsonBuilder()
        .registerTypeAdapter(Integer.class, new TypeAdapter&lt;Integer&gt;() &#123;
            @Override
            public void write(JsonWriter out, Integer value) throws IOException &#123;
                out.value(String.valueOf(value));
            &#125;
            @Override
            public Integer read(JsonReader in) throws IOException &#123;
                try &#123;
                    return Integer.parseInt(in.nextString());
                &#125; catch (NumberFormatException e) &#123;
                    return -1;
                &#125;
            &#125;
        &#125;)
        .create();
System.out.println(gson.toJson(100)); // 结果：&quot;100&quot;
System.out.println(gson.fromJson(&quot;\&quot;\&quot;&quot;,Integer.class)); // 结果：-1  
</code></pre>
<blockquote>
<p>注：测试空串的时候一定是”&quot;&quot;“而不是””，””代表的是没有json串，”&quot;&quot;“才代表json里的””。</p>
</blockquote>
<p>你说这一接管就要管两样好麻烦呀，我明明只想管序列化（或反列化）的过程的，另一个过程我并不关心，难道没有其它更简单的方法么? 当然有！就是接下来要介绍的 JsonSerializer与JsonDeserializer。</p>
<h2 id="二、JsonSerializer与JsonDeserializer"><a href="#二、JsonSerializer与JsonDeserializer" class="headerlink" title="二、JsonSerializer与JsonDeserializer"></a>二、JsonSerializer与JsonDeserializer</h2><p>JsonSerializer 和JsonDeserializer 不用像TypeAdapter一样，必须要实现序列化和反序列化的过程，你可以据需要选择，如只接管序列化的过程就用 JsonSerializer ，只接管反序列化的过程就用 JsonDeserializer ，如上面的需求可以用下面的代码。</p>
<pre><code>Gson gson = new GsonBuilder()
        .registerTypeAdapter(Integer.class, new JsonDeserializer&lt;Integer&gt;() &#123;
            @Override
            public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException &#123;
                try &#123;
                    return json.getAsInt();
                &#125; catch (NumberFormatException e) &#123;
                    return -1;
                &#125;
            &#125;
        &#125;)
        .create();
System.out.println(gson.toJson(100)); //结果：100
System.out.println(gson.fromJson(&quot;\&quot;\&quot;&quot;, Integer.class)); //结果-1  
</code></pre>
<p>下面是所有数字都转成序列化为字符串的例子</p>
<pre><code>JsonSerializer&lt;Number&gt; numberJsonSerializer = new JsonSerializer&lt;Number&gt;() &#123;
    @Override
    public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context) &#123;
        return new JsonPrimitive(String.valueOf(src));
    &#125;
&#125;;
Gson gson = new GsonBuilder()
        .registerTypeAdapter(Integer.class, numberJsonSerializer)
        .registerTypeAdapter(Long.class, numberJsonSerializer)
        .registerTypeAdapter(Float.class, numberJsonSerializer)
        .registerTypeAdapter(Double.class, numberJsonSerializer)
        .create();
System.out.println(gson.toJson(100.0f));//结果：&quot;100.0&quot;  
</code></pre>
<blockquote>
<p>注：registerTypeAdapter必须使用包装类型，所以int.class,long.class,float.class和double.class是行不通的。同时不能使用父类来替上面的子类型，这也是为什么要分别注册而不直接使用Number.class的原因。</p>
</blockquote>
<p>上面特别说明了registerTypeAdapter不行，那就是有其它方法可行咯?当然！换成registerTypeHierarchyAdapter 就可以使用Number.class而不用一个一个的当独注册啦！</p>
<h3 id="registerTypeAdapter与registerTypeHierarchyAdapter的区别："><a href="#registerTypeAdapter与registerTypeHierarchyAdapter的区别：" class="headerlink" title="registerTypeAdapter与registerTypeHierarchyAdapter的区别："></a>registerTypeAdapter与registerTypeHierarchyAdapter的区别：</h3><p><img src="http://img.shedoor.net/gson/gson_guide4_1.png"></p>
<p>注：如果一个被序列化的对象本身就带有泛型，且注册了相应的TypeAdapter，那么必须调用Gson.toJson(Object,Type)，明确告诉Gson对象的类型。</p>
<pre><code>Type type = new TypeToken&lt;List&lt;User&gt;&gt;() &#123;&#125;.getType();
TypeAdapter typeAdapter = new TypeAdapter&lt;List&lt;User&gt;&gt;() &#123;
   //略
&#125;;
Gson gson = new GsonBuilder()
        .registerTypeAdapter(type, typeAdapter)
        .create();
List&lt;User&gt; list = new ArrayList&lt;&gt;();
list.add(new User(&quot;a&quot;,11));
list.add(new User(&quot;b&quot;,22));
//注意，多了个type参数
String result = gson.toJson(list, type);  
</code></pre>
<h2 id="三、TypeAdapterFactory"><a href="#三、TypeAdapterFactory" class="headerlink" title="三、TypeAdapterFactory"></a>三、TypeAdapterFactory</h2><p>TypeAdapterFactory,见名知意，用于创建TypeAdapter的工厂类，通过对比Type，确定有没有对应的TypeAdapter，没有就返回null，与GsonBuilder.registerTypeAdapterFactory配合使用。</p>
<pre><code>Gson gson = new GsonBuilder()
    .registerTypeAdapterFactory(new TypeAdapterFactory() &#123;
        @Override
        public &lt;T&gt; TypeAdapter&lt;T&gt; create(Gson gson, TypeToken&lt;T&gt; type) &#123;
            return null;
        &#125;
    &#125;)
    .create();  
</code></pre>
<h2 id="四、-JsonAdapter注解"><a href="#四、-JsonAdapter注解" class="headerlink" title="四、@JsonAdapter注解"></a>四、@JsonAdapter注解</h2><p>JsonAdapter相较之前介绍的SerializedName 、FieldNamingStrategy、Since、Until、Expos这几个注解都是比较特殊的，其它的几个都是用在POJO的字段上，而这一个是用在POJO类上的，接收一个参数，且必须是TypeAdpater，JsonSerializer或JsonDeserializer这三个其中之一。</p>
<p>上面说JsonSerializer和JsonDeserializer都要配合GsonBuilder.registerTypeAdapter使用，但每次使用都要注册也太麻烦了，JsonAdapter就是为了解决这个痛点的。</p>
<p>使用方法（以User为例）：</p>
<pre><code>@JsonAdapter(UserTypeAdapter.class) //加在类上
public class User &#123;
    public User() &#123;
    &#125;
    public User(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;
    public User(String name, int age, String email) &#123;
        this.name = name;
        this.age = age;
        this.email = email;
    &#125;
    public String name;
    public int age;
    @SerializedName(value = &quot;emailAddress&quot;)
    public String email;
&#125;  
</code></pre>
<p>使用时不用再使用 GsonBuilder去注册UserTypeAdapter了。<br>注：@JsonAdapter 仅支持 TypeAdapter或TypeAdapterFactory</p>
<pre><code>Gson gson = new Gson();
User user = new User(&quot;怪盗kidou&quot;, 24, &quot;ikidou@example.com&quot;);
System.out.println(gson.toJson(user));
//结果：&#123;&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;email&quot;:&quot;ikidou@example.com&quot;&#125;
//为区别结果，特意把email字段与@SerializedName注解中设置的不一样  
</code></pre>
<p>注意：JsonAdapter的优先级比GsonBuilder.registerTypeAdapter的优先级更高。</p>
<h2 id="五、TypeAdapter与-JsonSerializer、JsonDeserializer对比"><a href="#五、TypeAdapter与-JsonSerializer、JsonDeserializer对比" class="headerlink" title="五、TypeAdapter与 JsonSerializer、JsonDeserializer对比"></a>五、TypeAdapter与 JsonSerializer、JsonDeserializer对比</h2><p><img src="http://img.shedoor.net/gson/gson_guide4_2.png"></p>
<h2 id="六、TypeAdapter实例"><a href="#六、TypeAdapter实例" class="headerlink" title="六、TypeAdapter实例"></a>六、TypeAdapter实例</h2><p>注：这里的TypeAdapter泛指TypeAdapter、JsonSerializer和JsonDeserializer。<br>这里的TypeAdapter 上面讲了一个自动将 字符串形式的数值转换成int型时可能出现 空字符串的问题，下面介绍一个其它读者的需求：</p>
<blockquote>
<p>服务器返回的数据中data字段类型不固定，比如请求成功data是一个List,不成功的时候是String类型，这样前端在使用泛型解析的时候，怎么去处理呢？  </p>
</blockquote>
<p>其实这个问题的原因主要由服务器端造成的，接口设计时没有没有保证数据的一致性，正确的数据返回姿势：<strong>同一个接口任何情况下不得改变返回类型，要么就不要返，要么就返空值，如<code>null、[],&#123;&#125;。</code></strong></p>
<p>但这里还是给出解决方案：<br><strong>方案一：</strong></p>
<pre><code>Gson gson = new GsonBuilder().registerTypeHierarchyAdapter(List.class, new JsonDeserializer&lt;List&lt;?&gt;&gt;() &#123;
    @Override
    public List&lt;?&gt; deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException &#123;
        if (json.isJsonArray())&#123;
            //这里要自己负责解析了
            Gson newGson = new Gson();
            return newGson.fromJson(json,typeOfT);
        &#125;else &#123;
            //和接口类型不符，返回空List
            return Collections.EMPTY_LIST;
        &#125;
    &#125;
&#125;).create();  
</code></pre>
<p><strong>方案二：</strong></p>
<pre><code> Gson gson = new GsonBuilder().registerTypeHierarchyAdapter(List.class, new JsonDeserializer&lt;List&lt;?&gt;&gt;() &#123;
    @Override
    public List&lt;?&gt; deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException &#123;
        if (json.isJsonArray()) &#123;
            JsonArray array = json.getAsJsonArray();
            Type itemType = ((ParameterizedType) typeOfT).getActualTypeArguments()[0];
            List list = new ArrayList&lt;&gt;();
            for (int i = 0; i &lt; array.size(); i++) &#123;
                JsonElement element = array.get(i);
                Object item = context.deserialize(element, itemType);
                list.add(item);
            &#125;
            return list;
        &#125; else &#123;
            //和接口类型不符，返回空List
            return Collections.EMPTY_LIST;
        &#125;
    &#125;
&#125;).create();  
</code></pre>
<p>要注意的点：</p>
<ul>
<li>必须使用registerTypeHierarchyAdapter方法，不然对List的子类无效，但如果POJO中都是使用List，那么可以使用registerTypeAdapter。</li>
<li>对于是数组的情况，需要创建一个新的Gson，不可以直接使用context,不然gson又会调我们自定义的JsonDeserializer造成递归调用，方案二没有重新创建Gson，那么就需要提取出List<E>中E的类型，然后分别反序列化适合为E手动注册了TypeAdaper的情况。</li>
<li>从效率上推荐方案二，免去重新实例化Gson和注册其它TypeAdapter的过程。  </li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Gson系列总算是完成了，感觉写得越来越差了，我怕我写得太啰嗦，也不能总是大片大片的贴代码，所以可能有的地方写得并不详细，排版也不美观，但都些都不重点，重点是Gson里我们能用上的都一一介绍一遍，只要你确确实实把我这几篇文章上的内容都学会的话，以后Gson上的任何问题都不再是问题，当然可能很多内容对于实际的开发中用的并不多，但下次有什么疑难杂症就难不倒你了。</p>
<p>本系列不提供Demo源码，最重要的是自己实验。</p>
<p>写一篇文章还是要花不少时间和精力，要写示例、调式、组织语言、码字等等，加上关注的人在慢慢的增加的同时既给了我动力也给我不少压力，如有纰漏或者更好的例子都可以和我交流。</p>
]]></content>
      <categories>
        <category>第三方框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>第三方框架</tag>
        <tag>Gson</tag>
      </tags>
  </entry>
  <entry>
    <title>我不等伞，也不等雨停</title>
    <url>/2016/11/24/INWaitRainStopWithoutU/</url>
    <content><![CDATA[<p><img src="http://img.shedoor.net/ocnyang/forloneliness.jpg" alt="长夜漫漫，愿你有人爱。">  </p>
<span id="more"></span>

<h2 id="（一）"><a href="#（一）" class="headerlink" title="（一）"></a>（一）</h2><p>漂流瓶里收到了一条“奇怪”的消息是这么说的：说来也不容易，你会收着我的瓶子，或许因为网络，咫尺天涯，或者因为网络，万里非途；无论我们各自身处何方，但这一刻，我们或许有相似的地方。太过熟悉的人，只能够做知己，初次邂逅的人，会是一眼万年。我会被你扔在海里，但你，依旧会是我的远方。</p>
<p>说实话，当看到的时候，还是有那么一份真诚的感动涌上心头的，能够被一个陌生人当作远方，并且被“告白”，确确实实称的上是一种缘分。</p>
<p>但是细细品来，我却尝到了落寞，化不开的悲伤流露字里行间。我相信这不是一个陌生人应该说出来的话。</p>
<p>我当即就给了一份回复，希望能给这个来自远方的问候一些温暖：<em>我相信这个世界上一定会有一个你爱的人，他会穿过汹涌的人潮，笔直的走过田野、乡间和繁华的城市，然后拿着一颗用力跳动的心脏，捧着满腔的热血和沉甸甸的爱，走向你，抓紧你，去交换你的真心，他一定会找到你的，你一定要等下去啊！</em></p>
<h2 id="（二）"><a href="#（二）" class="headerlink" title="（二）"></a>（二）</h2><p><strong>百无一用是深情，不屑一顾最相思。</strong></p>
<p>在爱情面前，哪怕没有经历过的我，也很佩服那么一种人：只要知道了一段感情不适合，再难过也狠下心的说不见，再不舍也能假装洒脱的大步向前，再留恋也能勇敢的不回头。</p>
<p>哪怕转身的一瞬间很孤单，但是你真的不知道你的背影有多么的好看！</p>
<p>当然佩服归佩服，羡慕归羡慕，我还是知道，再百毒不侵的内心，往往也会被一句简单的安慰打败；再刀枪不入的伪装，也常常在懂你的面前投降；再怎么坚强的面容，也往往会有痛哭的时候。</p>
<p>而且我还知道，这个世界上可能最难过的事情不是你遇而不见，而是你已经遇见了，得到了，却是又匆忙的失去，然后在你的心上便是一道疤。它一直跟随着你，它让你什么时候疼，就什么时候疼，那可能会成为一直好不了的伤。</p>
<p>你希望着自己的棱角被时间磨平，希望会拔掉身上的刺，希望会学着对讨厌的人微笑，变得波澜不惊，希望变得不动声色。</p>
<p>可能么？</p>
<h2 id="（三）"><a href="#（三）" class="headerlink" title="（三）"></a>（三）</h2><p><strong>愿有岁月可回首，且以深情共白头？</strong></p>
<p>有人说要感谢前任让你成长，是他（她）让你变得更好。</p>
<p>可我总觉得不是这样。那些痛不欲生撕心裂肺的日子，都是你咬着牙一天天熬过来的啊。创伤这种东西永远都只是创伤，它只会演化为消磨力量的腐蚀剂。从创伤里得到成长，怎能和在无忧无虑的日子里享受阳光，在该有担当的日子里勇气十足的上阵相比呢？</p>
<p><em>凭什么要谢别人？！你得谢谢自己。</em></p>
<p>而且要知道，但凡死缠烂打的人，大都不是真的深爱你，那只是在跟自己赛跑，跟自己别扭过不去。真正爱你的人，是做不到死缠烂打，因为自尊不允许。我一直深信，爱就是把最好的一切给予对方，包括尊严。</p>
<p>哪怕有多多少少浅浅淡淡的转身，那都是旁人看不懂的情深。</p>
<p>如果说很多人在我们的生命中都经历着三个阶段：重要，很重要，不重要。也许你并不愿承认，但是事实上这件事最经不住内心拷问。</p>
<p>在时间的淘洗下，多少信誓旦旦都渐次苍白？人世的沧桑就在这里：我们总是在誓言那边纯粹，却在现实这边很崩溃。</p>
<p>失望积累的太多，再多的爱也会碎落满地，无论怎样还是会觉得无能为力，离开的不一定在意，但有些人也许只适合留在回忆里。</p>
<p>终究你会觉得人生是一场盛大的相遇，我也曾想义无反顾的等你，可是对不起。</p>
<h2 id="（四）"><a href="#（四）" class="headerlink" title="（四）"></a>（四）</h2><p><strong>你以为说了分手就能不见面；你以为说了再见就能不想念。</strong></p>
<p>我们迫不及待的想要和喜欢的人携手相伴一生；迫不及待的想要参与对方的生活，可结果往往是，越是爱你的人，越没那么爱你。</p>
<p>所以你总是在意别人的感受，宁愿自己受委屈，也不想别人不开心。</p>
<p>对方一失落，你就紧张；对方一道歉，你就心软，甚至觉得对方无所谓的生气都是在计较于自己的某件事情。</p>
<p>你傻傻的背着别人的快乐，有时候僵在原地喘不过气，但我知道，你的敏感是因为善良。</p>
<p>我希望善良的你最后不会吃亏，会有更多人用力的爱你，去作为回报。</p>
<p>很累的时候，就去听几首歌放空吧；很烦的时候，就去楼下跑步吧；很焦虑的时候，就去洗把脸清醒下。</p>
<p>爱的人爱不到，就先爱自己；等待的人还没来，就想做自己喜欢的事。</p>
<p>你就是一本书，何必非要当别人的书签。难过一会就行了，时间如此宝贵，哪能都浪费在难过上。</p>
<h2 id="（五）"><a href="#（五）" class="headerlink" title="（五）"></a>（五）</h2><p><strong>白茶轻欢无别事，我在等风也在等你。</strong></p>
<p>你若爱，生活哪里都可以爱；你若恨，生活哪里都可以恨；你若感恩，处处可感恩；你若成长，事事皆可成长。</p>
<p>长大之后，我们要明白，不是世界选择了你，是你选择了这个世界。</p>
<p>既然无处可躲，不如傻乐；既然无处可逃，不如喜悦；既然没有净土，不如静心；既然没有如愿，不如释然吧。</p>
<p>但我唯愿有佳人陪你走，我独拥浊风烈酒。</p>
<p><em>愿漂泊的人都有酒喝，愿孤独的人都会唱歌。敬你一杯酒，从此朝前走，往事不回头，未来不将就。</em></p>
<p>我干杯，你随意。</p>
<p>因为我不等伞，也不等雨停。</p>
<blockquote>
<p>摘录<br><a href="http://www.jianshu.com/p/0714150f4544#">文／小五是个好少年（简书作者）</a></p>
</blockquote>
]]></content>
      <categories>
        <category>还相信爱情</category>
      </categories>
      <tags>
        <tag>遇见</tag>
        <tag>Love</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 图标自适应：用 TextView 来显示图片 &amp; 生成自己的字体库</title>
    <url>/2016/12/06/IconFont/</url>
    <content><![CDATA[<p>今天我们来介绍一种用TextView代替并显示图片，以达到App优化及图标自适应的效果。当然，我们先来看一下效果：  </p>
<p><img src="http://img.shedoor.net/ocnyang/iconfont/iconfont_.png" alt="这些真的只是TextView文本">  </p>
<span id="more"></span>

<blockquote>
<p>如果你看到上面这张图片，第一反映你可能认为都是用ImageView去显示的，那你就错了，这些全都是用TextView实现的（当然更不可能是给 TextView 设置了背景图）。  </p>
</blockquote>
<p>平时我们在开发中，图片可谓是处处可见且必不可少的一部分，为了想尽办法让图片达到适配的效果我们可能需要：<br>根据不同分辨率来提供多套图，暂且不说这种方式是否麻烦，正常情况下我们切的三套或更多套图有时候总在有些机型上的效果不尽人意。<br>可能这时候你想到了用 <code>.9图片</code>，这时候且不说你们家 UI 妹子会不会单独的为我们 Android 端提供  <code>.9图片</code> （姑且相信你们家UI会制作<code>.9</code>），但是 <code>.9图片</code> 是有一定的局限性的，它只能是图片部分区域拉伸。  </p>
<p><a href="http://ocnyang.com/">这篇文章</a>也并不是去介绍如何去做图片的适配，而是介绍一种利用字体库的方式，我们用 TextView 的形式去显示图片，而且我们还可以正常的使用 <code>android:textSize</code> 属性来随意设置图片的大小！   </p>
<blockquote>
<p>其实这里通过 TextView 来显示图片的方式，我更愿意更准确的说成是通过 <strong>TextView 来显示图标</strong>，因为这里的图片不是真正意义上的大图而是相当于可以随意拉伸的矢量图。当然，如果你愿意你也可以用这种方式来显示图片。  </p>
</blockquote>
<p>啰嗦这么多，你的大刀是不是早就饥渴难耐了？其实这种方式很容易就能实现，只是通过给 TextView 设置一种字体，不要着急，马上开始。  </p>
<h2 id="为TextView设置字体"><a href="#为TextView设置字体" class="headerlink" title="为TextView设置字体"></a>为TextView设置字体</h2><p>大家都知道，在 android 中，我们如果要更换字体，除了要引入我们需要的字体库外，还需要给我们的 TextView 去手动设置使用的字体，如何去设置呢？其实很简单。</p>
<pre><code>textView.setTypeface(Typeface tf);  
</code></pre>
<p>尽管就这么一行代码，但是，在我们项目中肯定会存在大量的TextView，难道我们要一个个的去动手设置吗？想想这也是一件很头疼的事，下面就介绍一种方便的方法，一行代码解决字体设置的问题。  </p>
<p><strong>方法一：工具类 &amp; 递归遍历</strong>  </p>
<blockquote>
<p>在看代码之前，先来看看思路，其实思路很简单，我们提供一个根布局，写一个方法去递归遍历整个根布局，如果发现是textView，则设置字体。思路很简单，相信代码也很简单，就是一个递归方法。  </p>
</blockquote>
<pre><code>public class FontHelper &#123;
    public static final String DEF_FONT = &quot;fonts/ocnyangfont.ttf&quot;;

    public static final void injectFont(View rootView) &#123;
        injectFont(rootView, Typeface.createFromAsset(rootView.getContext().getAssets(),
                DEF_FONT));
    &#125;

    private static void injectFont(View rootView, Typeface typeface) &#123;
        if (rootView instanceof ViewGroup) &#123;
            ViewGroup viewGroup = (ViewGroup) rootView;
            int childViewCount = viewGroup.getChildCount();
            for (int i = 0; i &lt; childViewCount; i++) &#123;
                injectFont(viewGroup.getChildAt(i), typeface);
            &#125;
        &#125; else if (rootView instanceof TextView) &#123;
            ((TextView) rootView).setTypeface(typeface);
        &#125;
    &#125;
&#125;
</code></pre>
<p>定义了一个工具类，这个类提供两个静态方法，但是核心都是  </p>
<pre><code>public static final void injectFont(View rootView, Typeface tf)
</code></pre>
<blockquote>
<p>这个方法中，首先我们去判断我们给的rootView是不是ViewGroup，如果是ViewGroup，则遍历他的所有子view，然后递归去调用这个方法，直到全部完成，如果发现某个view是TextView，则我们调用setTypeface方法来设置字体。<br>ok，从这个工具类中我们还可以看到，我们的字体是放在assets/fonts目录下的。</p>
</blockquote>
<p>最后是在activity中使用字体库，正式利用了上面的工具类，所以我们的代码将会很简单。  </p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) &#123;
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    FontHelper.injectFont(findViewById(android.R.id.content));
&#125;
</code></pre>
<p>仅仅一行代码，<code>FontHelper.injectFont(findViewById(android.R.id.content));</code><br>我们就完成了给所有TextView设置字体的工作。</p>
<p><strong>方法二：LayoutInflate</strong>  </p>
<p>现在对 LayoutInflateFactory 的用法还不太熟悉的，可以先去看一下鸿洋的这篇博文：<a href="http://blog.csdn.net/lmj623565791/article/details/51503977">探究 LayoutInflate setFactory</a>。  </p>
<p>我们编写一个自定义的LayoutInflaterFactory：  </p>
<pre><code>public class IconFontLayoutFactory implements LayoutInflaterFactory &#123;

    private static Typeface sTypeface;
    private AppCompatDelegate mAppCompatDelegate;

    public IconFontLayoutFactory(Context context,
                                 AppCompatDelegate appCompatDelegate) &#123;
        if (sTypeface == null) &#123;
            sTypeface = Typeface.createFromAsset(context.getAssets(),
                    &quot;fonts/ocnyangfont.ttf&quot;);
        &#125;
        mAppCompatDelegate = appCompatDelegate;
    &#125;

    @Override
    public View onCreateView(View parent, String name, Context context,
                             AttributeSet attrs) &#123;
        View view = mAppCompatDelegate.createView(parent, name, context, attrs);
        if (view instanceof TextView) &#123;
            ((TextView) view).setTypeface(sTypeface);
        &#125;
        return view;
    &#125;
&#125;
</code></pre>
<p>字体文件我们还是放在 <code>assets/fonts</code> 目录下。  </p>
<p>然后你可以在你的BaseActivity的onCreate中，调用如下代码：  </p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) &#123;

        LayoutInflaterCompat.setFactory(getLayoutInflater(),
                new IconFontLayoutFactory(this,getDelegate()));

        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
&#125;
</code></pre>
<blockquote>
<p>注意一定要在super.onCreate前调用即可。  </p>
</blockquote>
<p>该方式可以在TextView及其子类对象创建完成时，就可以为其调用setTypeFace，非常的高效。<br>而对于字体库的加载，如果有需要，你甚至可以采用懒加载的方式，在SplashActivity中对其初始化。  </p>
<blockquote>
<p>这里提供是两种全局设置的方式。<br>有时候我们只是需要给部分 TextView 设置，这时候大家可以选择手动单独给特定的 TextView 设置，也可以通过自定义 View 的方案来实现（<strong>在构造方法中去设置 TypeFace</strong>，我个人也比较提倡这种方式，使用上相对灵活，也很简单这里就啰嗦了，详细代码可以到这里下载 <a href="https://github.com/OCNYang/FontTest">本文源码</a> 内查看）。  </p>
</blockquote>
<p>那上面这些只是如何设置字体的方法，可能你也早就知道了，字体是字体，也不是图片呀，大兄弟莫慌，下面就给你如何介绍一种酷炫的字体库和制作自己独特的图片字体库的方法。  </p>
<h2 id="fontawesome-字体库的使用"><a href="#fontawesome-字体库的使用" class="headerlink" title="fontawesome 字体库的使用"></a>fontawesome 字体库的使用</h2><p>在开始使用之前，我们我们需要到<br><strong><a href="https://github.com/FortAwesome/Font-Awesome/">https://github.com/FortAwesome/Font-Awesome/</a></strong><br>下载这个字体库（不想麻烦，本文 <a href="https://github.com/OCNYang/FontTest">源代码</a> 也包含有）。下载下来以后，你会看到有很多目录和文件，没关系，我们只需要一个文件-fontawesome-webfont.ttf，这个文件位于/fonts/目录下。将这个ttf文件copy到你项目的assets目录下，按照惯例或者说是共识，我们可能是将它放到assets/fonts这个目录下(注意，没有这个目录的话，创建它！)。  </p>
<p>ok， 准备工作都做好了，那我们就开始使用它吧，看我的xml布局文件：  </p>
<pre><code>&lt;LinearLayout
    //...
    &gt;

    &lt;TextView
        android:id=&quot;@+id/text1&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_margin=&quot;10dp&quot;
        android:textSize=&quot;58sp&quot;
        android:textColor=&quot;#ff995533&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;&amp;#xe60d;&quot;/&gt;

    &lt;TextView
        android:id=&quot;@+id/text2&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_margin=&quot;10dp&quot;
        android:textSize=&quot;118sp&quot;
        android:textColor=&quot;#ff9ff533&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;&amp;#xe615;&quot;/&gt;

    //...

&lt;/LinearLayout&gt;
</code></pre>
<p>看到这个布局文件，我们看到和平时没什么区别，给出了textSize或者textColor属性，不用想这些肯定去控制了我们需要显示的图片的大小和颜色！  </p>
<p>细心的你会发现这些 TextView 文本好奇怪。其实这些文本对应的就是相对于的图片。可是，现在我们又遇到了一个问题，我们怎么知道哪写文本代表了什么图片呢？下面给出一个网址，通过这个网址，大家可以看到实体文本和他对应的图片的一个对照表。  </p>
<p><a href="http://fortawesome.github.io/Font-Awesome/cheatsheet/">http://fortawesome.github.io/Font-Awesome/cheatsheet/</a>  </p>
<blockquote>
<p>本文 <a href="https://github.com/OCNYang/FontTest">源码</a> 内我们提供了一个 <code>string.xml</code> 文件的图片字符对照表,可以直接在项目中使用。<br>你也可以在根据自己的需要在上面 <code>string.xml</code> 文件里 <code>Ctrl + F</code> 检索出对应的编码放到自己的字符串文件里或直接使用。   </p>
</blockquote>
<p>哦，对了，不知道大家有没有发现，这里我们无意中解决了一个图片大小的问题，因为我们可以任意改变一个文本的大小，所以，就不需要提供多套图去适配不同的屏幕了。  </p>
<p>这是你可能还是有疑问，<code>Font-Awesome 库</code> 内提供的图标虽然很全很美观，但是不一定能满足我们所有的需要啊！那现在就教大家如何制作属于自己的字体库。  </p>
<h2 id="制作属于自己的图片字体库"><a href="#制作属于自己的图片字体库" class="headerlink" title="制作属于自己的图片字体库"></a>制作属于自己的图片字体库</h2><p>在自己动手制作图片字体库之前，当然要先查找一些自己喜欢的漂亮的图标了，下面开启干货福利模式。  </p>
<h3 id="图标干货"><a href="#图标干货" class="headerlink" title="图标干货"></a>图标干货</h3><p>对于使用，最主要就是找到一些靠谱的素材站点了</p>
<p><a href="http://www.iconfont.cn/">http://www.iconfont.cn/</a><br><a href="https://icomoon.io/app/#/select">https://icomoon.io/app/#/select</a><br><a href="https://github.com/mikepenz/Android-Iconics">https://github.com/mikepenz/Android-Iconics</a>  </p>
<p>第一个站点是阿里提供的图标库，基本上可以搜索到需要的任何图标，非常方便，也支持颜色和大小的设置，足够满足我们的需求：</p>
<p><img src="http://img.shedoor.net/ocnyang/iconfont/iconfont.png" alt="阿里 iconfont 图标库">  </p>
<h3 id="自定义图标"><a href="#自定义图标" class="headerlink" title="自定义图标"></a>自定义图标</h3><p>无论上面这些网站提供的图标是多么的全，可能都无法满足贪心的你或者你们家追求完美（矫情）到极致的UI，那么如果App内的图标部分是自己制作的，再混杂着网络上已有的图标能打包到一个字体库么？<br>答案当然是肯定的，我们本来就是要制作属于自己的字体库嘛！比如你就可以依赖 <code>iconfont.com</code> 这个网站，自行上传svg图标，然后就可以自由选择了。  </p>
<blockquote>
<p>关于 iconfont 网站的用法可以参考官方手册(也可以跳过，直接跟着我学习怎么生成自己的字体库)：<br><a href="http://www.iconfont.cn/help/platform.html">http://www.iconfont.cn/help/platform.html</a>  </p>
</blockquote>
<h3 id="按需生成自己的图标字体库"><a href="#按需生成自己的图标字体库" class="headerlink" title="按需生成自己的图标字体库"></a>按需生成自己的图标字体库</h3><p>我们以 iconfont 库为例，教大家<a href="http://ocnyang.com/">生成自己图片字体库的整个流程</a>（下面所有步骤，大家都无需注册账号，就可以直接使用）。  </p>
<p>首先在 iconfont 网站上选择自己要生成到字体库的图标，可以选择网站字体库中选择，也可以在我的图标库中选择自己上传的图标。把这些图标添加到库（即添加到购物车）：  </p>
<p><img src="http://img.shedoor.net/ocnyang/iconfont/iconfont_all.png" alt="选择喜欢的图标">  </p>
<p><img src="http://img.shedoor.net/ocnyang/iconfont/iconfont_setect.png" alt="添加到购物车">  </p>
<p>当你想要生成的字体库的图标选择完成后，在网站右上角点击打开库（购物车），在库里可以看到自己选择的所有图标，确定后点击下载代码：  </p>
<p><img src="http://img.shedoor.net/ocnyang/iconfont/iconfont_cart.png" alt="打开库，下载代码会得到一个压缩包">  </p>
<p><img src="http://img.shedoor.net/ocnyang/iconfont/iconfont_ttf.png" alt="解压缩后，可以看到生成的库">  </p>
<p>在解压后的文件夹中，我们看到许多文件。其中以 <code>.ttf</code> 结尾的文件就是我们生成的自己的字体库，而 3 个 <code>.html</code> 文件对应的是不同平台使用时对应的编码。而我们在 Android 开发中要使用的编码是 <code>demo_unicode.html</code> 文件里对应的 <code>&amp;#xxxxx;</code> 形式的编码。  </p>
<p>细心的你一定会发现，生成的字体库里虽然包含了很多图标，却只有小小的几 KB 的大小，更难能可贵的是无论设置多大的尺寸它依旧能够保存一样的清晰度，当然，你也可以把该方案看成apk瘦身的可选手段之一。</p>
<p>本文Demo源代码下载地址：**<a href="https://github.com/OCNYang/FontTest">https://github.com/OCNYang/FontTest</a>**  </p>
<blockquote>
<p>参考：<br><a href="http://blog.csdn.net/qibin0506/article/details/48675839">亓斌 - FontAwesome-用TextView显示图片</a><br><a href="http://chuansong.me/n/797491851925">鸿洋 - Android IconFont全攻略</a><br><a href="https://code.tutsplus.com/tutorials/how-to-use-fontawesome-in-an-android-app--cms-24167">How to Use FontAwesome in an Android App</a>  </p>
</blockquote>
]]></content>
      <categories>
        <category>Android教程系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android教程系列</tag>
      </tags>
  </entry>
  <entry>
    <title>你真的会写单例吗？</title>
    <url>/2016/10/10/Java_Mode_Singleton/</url>
    <content><![CDATA[<blockquote>
<p><a href="http://blog.csdn.net/wzgiceman/article/details/51809985">摘录来源</a>  </p>
</blockquote>
<h2 id="单例的正确姿势"><a href="#单例的正确姿势" class="headerlink" title="单例的正确姿势"></a>单例的正确姿势</h2><p><a href="http://ocnyang.com/">Java</a>单例模式可能是最简单也是最常用的设计模式，一个完美的单例需要做到哪些事呢？  </p>
<span id="more"></span>

<ol>
<li>单例（这不是废话吗）  </li>
<li>延迟加载</li>
<li>线程安全</li>
<li>没有性能问题</li>
<li>防止序列化产生新对象</li>
<li>防止反射攻击  </li>
</ol>
<p>可以看到，真正要实现一个完美的单例是很复杂的，那么，让我这个司机带大家看一看正确姿势的单例。  </p>
<h2 id="最佳实践单例之枚举"><a href="#最佳实践单例之枚举" class="headerlink" title="最佳实践单例之枚举"></a>最佳实践单例之枚举</h2><p>没错，直接就上最佳实践，就是这么任性  </p>
<p>这货长这样：  </p>
<pre><code>public enum Singleton&#123;  
    INSTANCE;  
&#125;    
</code></pre>
<p>如果你不熟悉枚举，可能会说：这货是啥？！  </p>
<p>这种方式的好处是：  </p>
<ol>
<li>利用的枚举的特性实现单例</li>
<li>由JVM保证线程安全</li>
<li>序列化和反射攻击已经被枚举解决  </li>
</ol>
<p>调用方式为Singleton.INSTANCE, 出自《Effective Java》第二版第三条: 用私有构造器或枚举类型强化Singleton属性。<br>关于单例最佳实践的讨论可以看Stackoverflow：<a href="http://stackoverflow.com/questions/70689/what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java">what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java</a>  </p>
<p>下面将会介绍更为常见的单例模式，但是均未处理反射攻击，如果想了解更多可以看这篇文章：<a href="http://blog.csdn.net/u013256816/article/details/50525335">如何防止单例模式被JAVA反射攻击</a>  </p>
<h2 id="最简单的单例之饿汉式"><a href="#最简单的单例之饿汉式" class="headerlink" title="最简单的单例之饿汉式"></a>最简单的单例之饿汉式</h2><pre><code>public class Singleton &#123;  
    private static final Singleton INSTANCE = new Singleton();  
    // 私有化构造函数  
    private Singleton()&#123;&#125;  

    public static Singleton getInstance()&#123;  
        return INSTANCE;  
    &#125;  
&#125;   
</code></pre>
<p>这种单例的写法最简单，但是缺点是一旦类被加载，单例就会初始化，没有实现懒加载。而且当实现了Serializable接口后，反序列化时单例会被破坏。<br>实现Serializable接口需要重写readResolve，才能保证其反序列化依旧是单例：  </p>
<pre><code>public class Singleton implements Serializable &#123;  
    private static final Singleton INSTANCE = new Singleton();  
    // 私有化构造函数  
    private Singleton()&#123;&#125;  

    public static Singleton getInstance()&#123;  
        return INSTANCE;  
    &#125;  

    /**
     * 如果实现了Serializable, 必须重写这个方法
     */  
    private Object readResolve() throws ObjectStreamException &#123;  
        return INSTANCE;  
    &#125;  
&#125;    
</code></pre>
<p>OK，反序列化要注意的就是这一点，下面的内容中就不再复述了。  </p>
<h2 id="最体现技术的单例之懒汉式"><a href="#最体现技术的单例之懒汉式" class="headerlink" title="最体现技术的单例之懒汉式"></a>最体现技术的单例之懒汉式</h2><p>懒汉式即实现延迟加载的单例，为上述饿汉式的优化形式。而因其仍需要进一步优化，往往成为面试考点，让我们一起来看看坑爹的“懒汉式”<br>懒汉式的最初形式是这样的：  </p>
<pre><code>public class Singleton &#123;  
    private static Singleton INSTANCE;  
    private Singleton ()&#123;&#125;  

    public static Singleton getInstance() &#123;  
     if (INSTANCE == null) &#123;  
         INSTANCE = new Singleton();  
     &#125;  
     return INSTANCE;  
    &#125;  
&#125;   
</code></pre>
<p>这种写法就轻松实现了单例的懒加载，只有调用了getInstance方法才会初始化。但是这样的写法出现了新的问题–线程不安全。当多个线程调用getInstance方法时，可能会创建多个实例，因此需要对其进行同步。  </p>
<p>如何使其线程安全呢？简单，加个synchronized关键字就行了</p>
<pre><code>public static synchronized Singleton getInstance() &#123;  
    if (INSTANCE == null) &#123;  
        INSTANCE = new Singleton();  
    &#125;  
    return INSTANCE;  
&#125;    
</code></pre>
<p>可是…这样又出现了性能问题，简单粗暴的同步整个方法，导致同一时间内只有一个线程能够调用getInstance方法。</p>
<p>因为仅仅需要对初始化部分的代码进行同步，所以再次进行优化：  </p>
<pre><code>public static Singleton getSingleton() &#123;  
    if (INSTANCE == null) &#123;               // 第一次检查  
        synchronized (Singleton.class) &#123;  
            if (INSTANCE == null) &#123;      // 第二次检查  
                INSTANCE = new Singleton();  
            &#125;  
        &#125;  
    &#125;  
    return INSTANCE ;  
&#125;   
</code></pre>
<p>执行两次检测很有必要：当多线程调用时，如果多个线程同时执行完了第一次检查，其中一个进入同步代码块创建了实例，后面的线程因第二次检测不会创建新实例。<br>这段代码看起来很完美，但仍旧存在问题，以下内容引用自黑桃夹克大神的<a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/">如何正确地写出单例模式</a>    </p>
<p>这段代码看起来很完美，很可惜，它是有问题。主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</p>
<ol>
<li>给 instance 分配内存</li>
<li>调用 Singleton 的构造函数来初始化成员变量</li>
<li>将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）  </li>
</ol>
<p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。<br>我们只需要将 instance 变量声明成 volatile 就可以了。  </p>
<pre><code>public class Singleton &#123;  
    private volatile static Singleton INSTANCE; //声明成 volatile  
    private Singleton ()&#123;&#125;  

    public static Singleton getSingleton() &#123;  
        if (INSTANCE == null) &#123;                           
            synchronized (Singleton.class) &#123;  
                if (INSTANCE == null) &#123;         
                    INSTANCE = new Singleton();  
                &#125;  
            &#125;  
        &#125;  
        return INSTANCE;  
    &#125;  

&#125;   
</code></pre>
<p>使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。  </p>
<p>但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。  </p>
<p>至此，这样的懒汉式才是没有问题的懒汉式。</p>
<h2 id="内部类实现单例"><a href="#内部类实现单例" class="headerlink" title="内部类实现单例"></a>内部类实现单例</h2><pre><code>public class Singleton &#123;   
    /**  
     * 类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例没有绑定关系，  
     * 而且只有被调用到才会装载，从而实现了延迟加载  
     */   
    private static class SingletonHolder&#123;   
        /**  
         * 静态初始化器，由JVM来保证线程安全  
         */   
        private static final Singleton instance = new Singleton();   
    &#125;   
    /**  
     * 私有化构造方法  
     */   
    private Singleton()&#123;   
    &#125;   

    public static  Singleton getInstance()&#123;   
        return SingletonHolder.instance;   
    &#125;   
&#125;  
</code></pre>
<p>使用内部类来维护单例的实例，当Singleton被加载时，其内部类并不会被初始化，故可以确保当 Singleton类被载入JVM时，不会初始化单例类。只有 getInstance() 方法调用时，才会初始化 instance。同时，由于实例的建立是时在类加载时完成，故天生对多线程友好，getInstance() 方法也无需使用同步关键字。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>单列模式</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>ListView 特殊属性 &amp; 常见问题</title>
    <url>/2016/08/22/ListViewAttribute/</url>
    <content><![CDATA[<p>这里向大家介绍一些我个人认为比较特别的属性，通过设置这样的属性可以做出更加美观的列表</p>
<span id="more"></span>

<h2 id="一-ListView的一些特殊属性"><a href="#一-ListView的一些特殊属性" class="headerlink" title="一.  ListView的一些特殊属性"></a>一.  ListView的一些特殊属性</h2><h3 id="1-stackFromBottom属性"><a href="#1-stackFromBottom属性" class="headerlink" title="1. stackFromBottom属性"></a>1. stackFromBottom属性</h3><p>**android:stackFromBottom=”true”**。设置该属性后你做好的列表就会显示你列表的最下面，值为true和false</p>
<h3 id="2-transciptMode属性"><a href="#2-transciptMode属性" class="headerlink" title="2. transciptMode属性"></a>2. transciptMode属性</h3><p>需要用ListView或者其它显示大量Items的控件实时跟踪或者查看信息，并且希望最新的条目可以自动滚动到可视范围内。通过设置的控件transcriptMode属性可以将Android平台的控件（支持ScrollBar）自动滑动到最底部。<br><strong>android:transcriptMode=”alwaysScroll”</strong>   </p>
<h3 id="3-cacheColorHint属性"><a href="#3-cacheColorHint属性" class="headerlink" title="3. cacheColorHint属性"></a>3. cacheColorHint属性</h3><p>很多人希望能够改变一下它的背景，使他能够符合整体的UI设计，改变背景背很简单只需要准备一张图片然后指定属性 **android:background=”@drawable/bg”**，不过不要高兴地太早，当你这么做以后，发现背景是变了，但是当你拖动，或者点击list空白位置的时候发现ListItem都变成黑色的了，破坏了整体效果。<br>如果你只是换背景的颜色的话，可以直接指定 <strong>android:cacheColorHint</strong> 为你所要的颜色，如果你是用图片做背景的话，那也只要将android:cacheColorHint指定为透明（#00000000）就可以了</p>
<h3 id="4-divider属性"><a href="#4-divider属性" class="headerlink" title="4. divider属性"></a>4. divider属性</h3><p>该属性作用是每一项之间需要设置一个图片做为间隔，或是去掉item之间的分割线<br><strong>android:divider=”@drawable/list_driver”</strong>  其中  @drawable/list_driver 是一个图片资源，如果不想显示分割线则只要设置为__android:divider=”@drawable/@null”__ 就可以了。<strong>android:dividerHeight=”2dip”</strong> 设置两个item之间的距离</p>
<h3 id="5-headerDividersEnabled属性"><a href="#5-headerDividersEnabled属性" class="headerlink" title="5. headerDividersEnabled属性"></a>5. headerDividersEnabled属性</h3><p>__android:headerDividersEnabled=”false”__设成flase时，此ListView将不会在页眉视图前画分隔符。缺省值为true<br><strong>android:footerDividersEnabled</strong> 设成flase时，此ListView将不会在页脚视图前画分隔符。此属性缺省值为true</p>
<h3 id="6-fadingEdge属性"><a href="#6-fadingEdge属性" class="headerlink" title="6. fadingEdge属性"></a>6. fadingEdge属性</h3><p>上边和下边有黑色的阴影(类似边框的东西)<br><strong>android:fadingEdge=”none”</strong> 设置后没有阴影了~</p>
<h3 id="7-scrollbars属性"><a href="#7-scrollbars属性" class="headerlink" title="7. scrollbars属性"></a>7. scrollbars属性</h3><p>作用是隐藏listView的滚动条，<br>__android:scrollbars=”none”<strong>与__setVerticalScrollBarEnabled(true)</strong>;的效果是一样的，不活动的时候隐藏，活动的时候也隐藏</p>
<h3 id="8-fadeScrollbars属性"><a href="#8-fadeScrollbars属性" class="headerlink" title="8. fadeScrollbars属性"></a>8. fadeScrollbars属性</h3><p><strong>android:fadeScrollbars=”true”</strong>  配置ListView布局的时候，设置这个属性为true就可以实现滚动条的自动隐藏和显示。</p>
<h3 id="9-fastScrollEnabled属性"><a href="#9-fastScrollEnabled属性" class="headerlink" title="9. fastScrollEnabled属性"></a>9. fastScrollEnabled属性</h3><p>很多开发者不知道ListView列表控件的快速滚动滑块是如何启用的，这里告诉大家，辅助滚动滑块只需要一行代码就可以搞定，如果你使用XML布局只需要在ListView节点中加入  <strong>android:fastScrollEnabled=”true”</strong> 这个属性即可，而对于Java代码可以通过__myListView.setFastScrollEnabled(true)__来控制启用，参数false为隐藏。 还有一点就是当你的滚动内容较小，不到当前ListView的3个屏幕高度时则不会出现这个快速滚动滑块，同时该方法仍然是AbsListView的基础方法，可以在ListView或GridView等子类中使用快速滚动辅助。</p>
<h3 id="10-drawSelectorOnTop属性"><a href="#10-drawSelectorOnTop属性" class="headerlink" title="10. drawSelectorOnTop属性"></a>10. drawSelectorOnTop属性</h3><p><strong>android:drawSelectorOnTop=”true”</strong> 点击某一条记录，颜色会显示在最上面，记录上的文字被遮住，所以点击文字不放，文字就看不到<br>__android:drawSelectorOnTop=”false”__点击某条记录不放，颜色会在记录的后面，成为背景色，但是记录内容的文字是可见的</p>
<h3 id="11-listSelector属性"><a href="#11-listSelector属性" class="headerlink" title="11. listSelector属性"></a>11. listSelector属性</h3><p><strong>android:listSelector=”#00000000 “</strong> 改变选中item时的颜色。默认为橙黄底色（依手机系统而定）</p>
<h3 id="12-scrollingCache属性"><a href="#12-scrollingCache属性" class="headerlink" title="12. scrollingCache属性"></a>12. scrollingCache属性</h3><p>__android:scrollingCache=”false”__去除拖动时ListView背景为黑色</p>
<h3 id="13-soundEffectsEnabled属性"><a href="#13-soundEffectsEnabled属性" class="headerlink" title="13. soundEffectsEnabled属性"></a>13. soundEffectsEnabled属性</h3><p><strong>android:soundEffectsEnabled=”false”</strong>  点击和触摸时是否有声音效果,缺省值为true(只有系统设置中开启了触摸提示音才有效)</p>
<h2 id="二-解决ListView-item中含有Button或者Checkable的子类控件点击时冲突"><a href="#二-解决ListView-item中含有Button或者Checkable的子类控件点击时冲突" class="headerlink" title="二.   解决ListView item中含有Button或者Checkable的子类控件点击时冲突"></a>二.   解决ListView item中含有Button或者Checkable的子类控件点击时冲突</h2><p>由于在你自己定义的Item中存在诸如Button或者Checkable的子类控件，此时这些子控件会将焦点获取到，所以常常当点击item时变化的是子控件，item本身的点击没有响应。这时候就可以使用descendantFocusability来解决啦，API描述如下：</p>
<blockquote>
<p>android:descendantFocusability<br>Defines the relationship between the ViewGroup and its descendants when looking for a View to take focus.<br>Must be one of the following constant values.</p>
</blockquote>
<p>该属性是当一个为view获取焦点时，定义viewGroup和其子控件两者之间的关系。<br>属性的值有三种：  </p>
<ul>
<li>__beforeDescendants__：viewgroup会优先其子类控件而获取到焦点</li>
<li>__afterDescendants__：viewgroup只有当其子类控件不需要获取焦点时才获取焦点</li>
<li>__blocksDescendants__：viewgroup会覆盖子类控件而直接获得焦点</li>
</ul>
<p>所以解决办法：</p>
<ol>
<li>在Item布局的根布局加上__android:descendantFocusability=”blocksDescendants”__的属性。</li>
<li>在当前ListView的xml里添加__android:descendantFocusability=”blocksDescendants”__ 在item的xml里的Button添加__android:focusable=”false”__的属性。</li>
</ol>
<h2 id="三-listview的item点击事件会使里面的Button也出现按压的效果"><a href="#三-listview的item点击事件会使里面的Button也出现按压的效果" class="headerlink" title="三.  listview的item点击事件会使里面的Button也出现按压的效果"></a>三.  listview的item点击事件会使里面的Button也出现按压的效果</h2><p>两个方案：  </p>
<ol>
<li>放弃listview的onItemClickedListener()。listview.setOnItemClickedListener(null);</li>
<li>使用自定义的Button，判断他的父控件是否press，如果是就把这个事件消耗掉，不向下传递即可；  </li>
</ol>
<blockquote>
</blockquote>
<pre><code>import android.content.Context;  
import android.util.AttributeSet;  
import android.view.View;  
import android.widget.Button;  

public class CustomButton extends Button &#123;  
    public CustomButton(Context context) &#123;  
        super(context);  
    &#125;  

    public CustomButton(Context context, AttributeSet attrs) &#123;  
        super(context, attrs);  
    &#125;  

    public CustomButton(Context context, AttributeSet attrs, int defStyle) &#123;  
        super(context, attrs, defStyle);  
    &#125;  

    @Override  
    public void setPressed(boolean pressed) &#123;  
        if (pressed &amp;&amp; getParent() instanceof View &amp;&amp; ((View) getParent()).isPressed()) &#123;  
            return;  
        &#125;  
        super.setPressed(pressed);  
    &#125;  

&#125;  
</code></pre>
<blockquote>
<p>参考来源：<br><a href="">“一勤天下无难事” 博客</a><br><a href="">CSDN博客</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android控件</category>
      </categories>
      <tags>
        <tag>Android控件</tag>
        <tag>Android</tag>
        <tag>ListView</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Palette抽取Bitmap主色调</title>
    <url>/2016/11/11/Palette/</url>
    <content><![CDATA[<p>一些Support库随着<a href="http://ocnyang.com/">Android Lollipop</a>的发布而诞生了，其中就有Palette。这个库可以让你很轻松地从一幅图中抽取特征颜色，这在你希望界面的颜色风格适应指定图片时非常有用，它还会提供与指定颜色相搭配的字体颜色。  </p>
<span id="more"></span>

<h2 id="关于Palette"><a href="#关于Palette" class="headerlink" title="关于Palette"></a>关于Palette</h2><p>Palette顾名思义调色板， Palette的作用是可以从图像中提取图片的颜色。我们可以把提取的颜色融入到App UI中，可以使UI风格更加美观融洽。有些时候Palette显得非常好用，比如我们可以提取到的突出的色值设置为Toolbar，标题，状态栏的颜色等，可以使我们的整个界面色调统一，效果非常好看。  </p>
<h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><p>你需要在工程下的build.gradle里添加依赖才可以使用Palette，像如下代码所示：  </p>
<pre><code>dependencies &#123;
  compile &#39;com.android.support:palette-v7:21.0.0&#39;
&#125;
</code></pre>
<h3 id="生成Palette"><a href="#生成Palette" class="headerlink" title="生成Palette"></a>生成Palette</h3><p>生成一幅图像的Palette有一下几种方法：  </p>
<pre><code>// Synchronous methods.同步方法--------------------------------
// 这些应该在访问底层图像加载线程时使用。
// 方法1：使用默认16种颜色种类的调色板大小。
Palette p = Palette.generate(bitmap);
// 方法2：允许指定调色板的颜色种类的值，这里为24.
Palette p = Palette.generate(bitmap, 24);


// Asynchronous methods.异步方法--------------------------------
// 这是快速的集成路径，在内部使用AsyncTask等，不一定是最好的方式。
// 方法3：
Palette.generateAsync(bitmap, new Palette.PaletteAsyncListener() &#123;
    @Override
    public void onGenerated(Palette palette) &#123;
       // Here&#39;s your generated palette 这是你生成的调色板
    &#125;
&#125;);
// 方法4：
Palette.generateAsync(bitmap, 24, new Palette.PaletteAsyncListener() &#123;
    @Override
    public void onGenerated(Palette palette) &#123;
       // Here&#39;s your generated palette
    &#125;
&#125;);  
</code></pre>
<blockquote>
<p><strong>同步方法</strong>。由于他们很可能会比较耗时（在分析大图片或者所需颜色较多时），所以它们不应该在主线程中执行。你应该先在别的线程中使用这两个函数进行解析，解析成功之后再使用。<br><strong>异步方法</strong>。有时候你不会在加载图片的线程（非主线程）中使用解析出的颜色，所以Palette提供了异步方法，他们与之前的函数的区别就是需要传入PaletteAsyncListener，提供在图片解析完成后的回调函数。  </p>
</blockquote>
<p><strong>PaletteAsyncListener的实现</strong>是非常简单的（参考下面这几行代码），它只要重写onGenerated就好了。如此一来你就可以在任何需要的时候使用这两个函数创建Palette。</p>
<pre><code>Palette.PaletteAsyncListener listener = new Palette.PaletteAsyncListener() &#123;
  public void onGenerated(Palette palette) &#123;
    // 使用Palette对象，获取解析出的颜色
  &#125;
&#125;
</code></pre>
<h3 id="提取出的颜色"><a href="#提取出的颜色" class="headerlink" title="提取出的颜色"></a>提取出的颜色</h3><p>Palette默认会解析出图像的16种特征颜色种类，但是这六种颜色是你最经常用到的：  </p>
<ul>
<li>vibrant(鲜艳色)</li>
<li>dark vibrant(鲜艳色中的暗色)</li>
<li>light vibrant(鲜艳色中的亮色)</li>
<li>muted(柔和色)</li>
<li>dark muted(柔和色中的暗色)</li>
<li>light muted(柔和色中的亮色)</li>
</ul>
<p>借一张别人的图，给大家一种更直观的感受。  </p>
<p><img src="http://img.shedoor.net/Palette/20150827183303088.png" alt="Palette解析六个主颜色">  </p>
<h3 id="获取提取的颜色"><a href="#获取提取的颜色" class="headerlink" title="获取提取的颜色"></a>获取提取的颜色</h3><p>你获取Palette对象之后，可以通过以下这些内置getter函数直接获取这六个颜色。你需要传入默认颜色防止Palette无法解析到指定颜色种类，返回的类型是24位RGB颜色数值。</p>
<pre><code>Palette palette = Palette.generate(myBitmap);
int vibrant = palette.getVibrantColor(0x000000);
int vibrantLight = palette.getLightVibrantColor(0x000000);
int vibrantDark = palette.getDarkVibrantColor(0x000000);
int muted = palette.getMutedColor(0x000000);
int mutedLight = palette.getLightMutedColor(0x000000);
int mutedDark = palette.getDarkMutedColor(0x000000);

//独特的一种
getDominantColor(int defaultColor)
//返回从调色板中占主导地位的样本的颜色，为RGB包装INT。
</code></pre>
<h3 id="获取Swatch"><a href="#获取Swatch" class="headerlink" title="获取Swatch"></a>获取Swatch</h3><p>你也可以选择先获取Swatch对象，然后再通过Swatch提供的方法获取颜色的相关信息：  </p>
<pre><code>Palette.Swatch s = p.getVibrantSwatch();       //获取到充满活力的这种色调
Palette.Swatch s = p.getDarkVibrantSwatch();    //获取充满活力的黑
Palette.Swatch s = p.getLightVibrantSwatch();   //获取充满活力的亮
Palette.Swatch s = p.getMutedSwatch();           //获取柔和的色调
Palette.Swatch s = p.getDarkMutedSwatch();      //获取柔和的黑
Palette.Swatch s = p.getLightMutedSwatch();    //获取柔和的亮

//独特的一种
getDominantSwatch()
//返回从调色板中占主导地位的样本。
</code></pre>
<blockquote>
<p>注意：<a href="http://ocnyang.com/">getVibrantSwatch()</a>可能会返回一个null值，所以在使用前检查一下是必须的。<code>if (swatch != null) &#123;&#125;</code>  </p>
</blockquote>
<p>Palette解析出的颜色都来自于对应的Swatch，在Swatch里面含有很多关于对应颜色的有用信息。你可以从Swatch中获取RGB颜色值、HSL颜色向量、对应颜色在图像中所占的比例、与对应颜色搭配的标题字体颜色和正文字体颜色（这两个颜色和对应颜色的对比值是处理好的，你不必再去操心）。</p>
<p><strong>swatch对象对应的颜色方法：</strong>  </p>
<pre><code>getPopulation(): 像素的数量
getRgb(): RGB颜色
getHsl(): HSL颜色
getBodyTextColor(): 用于内容正文文本的颜色
getTitleTextColor(): 标题文本的颜色
</code></pre>
<p>Palette只为六种主颜色种类Swatch提供了getter，如果你要使用其他颜色种类的Swatch（一共有16种颜色种类），你需要手动获取它。调用getSwatchs()会返回一个列表，里面有所有获取到的Swatch。</p>
<pre><code>List&lt;Palette.Swatch&gt; swatches = palette.getSwatches();
</code></pre>
<p>这里是一个Palette获取所有Swatch的例子，里面展示了它们分别在图像中所占的比例：</p>
<p><img src="http://img.shedoor.net/Palette/20150827183359416.png">  </p>
<h3 id="关于颜色种类的值size"><a href="#关于颜色种类的值size" class="headerlink" title="关于颜色种类的值size"></a>关于颜色种类的值size</h3><p>在上面生成Palette的时候，你可能注意到了可以设置Palette的size。size越大，花费的时间越长，而越小，可以选择的色彩也越小。最佳的选择是根据image的用途：  </p>
<ul>
<li>头像之类的，size最好在24-32之间；  </li>
<li>风景大图之类的，size差不多在8-16；  </li>
<li>默认是16.  </li>
</ul>
<h2 id="Palette实例"><a href="#Palette实例" class="headerlink" title="Palette实例"></a>Palette实例</h2><p>Palette经常用于和ViewPager，Fragment搭配使用，当我们的Pager切换时伴随着Fragment的变化，而Fragment里的内容一般是不同的，所以每个Fragment里的一般视觉效果也是不同的，所以我们可以用Palette来去提取Fragment中的主色调，把这个主色调用于整体的UI风格。</p>
<p><img src="http://img.shedoor.net/Palette/tmpdir__16_6_28_18_41_09.gif" alt="效果图">  </p>
<p>这个例子可以参考这篇博客：<a href="http://www.jianshu.com/p/9fcf316031ba">http://www.jianshu.com/p/9fcf316031ba</a><br>Demo的地址：<a href="https://github.com/loonggg/MaterialDesignDemo">https://github.com/loonggg/MaterialDesignDemo</a>  </p>
<p>另外一个例子：  </p>
<p><img src="http://img.shedoor.net/Palette/cd389848270623564.png"> <img src="http://img.shedoor.net/Palette/cd389848270623565.png">  </p>
<p>详情参考这篇博客：<a href="http://www.itdadao.com/articles/c15a485862p0.html">http://www.itdadao.com/articles/c15a485862p0.html</a><br>Demo下载地址：<a href="http://download.csdn.net/detail/breeze_wf/9273313">http://download.csdn.net/detail/breeze_wf/9273313</a>  </p>
<blockquote>
<p>关于更多Palette的详细用法，可以查看<a href="https://developer.android.com/reference/android/support/v7/graphics/Palette.html">官方API文档</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>Android教程系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Palette</tag>
      </tags>
  </entry>
  <entry>
    <title>小秋魔盒</title>
    <url>/2017/04/09/QBox/</url>
    <content><![CDATA[<p><img src="http://img.shedoor.net/qbox/qbox.png"></p>
<p>愿，做你世界里的太阳，带来温暖  </p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="http://www.jianshu.com/p/3442a0b2eee1">简书:http://www.jianshu.com/p/3442a0b2eee1</a>  </p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>应大家的喜爱，现在已将源码在 Github 上开源，欢迎大家来 Star 和 Fork。<br><a href="https://github.com/OCNYang/QBox">Github</a>  </p>
<!-- more -->

<h2 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h2><p>自己在开发过程中，肯定有很多地方欠缺考虑，同时肯定也会遗留各种各样的问题。你知道的，作为程序，总会有一些奇葩的bug。  </p>
<p>希望亲爱的你，不要失望，不要放弃我，和我一起努力，塑造一款愈加完美的产品吧。  </p>
<p>请将你的建议或遇到的问题，在本文章下面留言反馈出来。亲爱的，谢谢！</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>E.Efall</tag>
        <tag>QBox</tag>
        <tag>小秋魔盒</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出RxJava（一：基础篇）</title>
    <url>/2016/10/10/RxJavaAbout1_Base/</url>
    <content><![CDATA[<p><a href="https://github.com/ReactiveX/RxJava">RxJava</a>正在<a href="http://ocnyang.com/">Android</a>开发者中变的越来越流行。唯一的问题就是上手不容易，尤其是大部分人之前都是使用命令式编程语言。但是一旦你弄明白了，你就会发现RxJava真是太棒了。<br>这里仅仅是帮助你了解RxJava，整个系列共有四篇文章，希望你看完这四篇文章之后能够了解RxJava背后的思想，并且喜欢上RxJava。</p>
<span id="more"></span>

<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>RxJava最核心的两个东西是Observables（被观察者，事件源）和 Subscribers（观察者）。Observables发出一系列事件，Subscribers处理这些事件。这里的事件可以是任何你感兴趣的东西 （触摸事件，web接口调用返回的数据。。。）  </p>
<p>一个Observable可以发出零个或者多个事件，知道结束或者出错。每发出一个事件，就会调用它的Subscriber的onNext方法，最后调用Subscriber.onNext()或者Subscriber.onError()结束。  </p>
<p>Rxjava的看起来很想设计模式中的观察者模式，但是有一点明显不同，那就是如果一个Observerble没有任何的的Subscriber，那么这个Observable是不会发出任何事件的。  </p>
<h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>创建一个Observable对象很简单，直接调用Observable.create即可</p>
<pre><code>Observable&lt;String&gt; myObservable = Observable.create(
    new Observable.OnSubscribe&lt;String&gt;() &#123;
        @Override
        public void call(Subscriber&lt;? super String&gt; sub) &#123;
            sub.onNext(&quot;Hello, world!&quot;);
            sub.onCompleted();
        &#125;
    &#125;
);  
</code></pre>
<p>这里定义的Observable对象仅仅发出一个Hello World字符串，然后就结束了。接着我们创建一个Subscriber来处理Observable对象发出的字符串。</p>
<pre><code>Subscriber&lt;String&gt; mySubscriber = new Subscriber&lt;String&gt;() &#123;
    @Override
    public void onNext(String s) &#123; System.out.println(s); &#125;

    @Override
    public void onCompleted() &#123; &#125;

    @Override
    public void onError(Throwable e) &#123; &#125;
&#125;;  
</code></pre>
<p>这里subscriber仅仅就是打印observable发出的字符串。通过subscribe函数就可以将我们定义的myObservable对象和mySubscriber对象关联起来，这样就完成了subscriber对observable的订阅。</p>
<pre><code>myObservable.subscribe(mySubscriber);  
</code></pre>
<p>一旦mySubscriber订阅了myObservable，myObservable就是调用mySubscriber对象的onNext和onComplete方法，mySubscriber就会打印出Hello World！</p>
<h3 id="更简洁的代码"><a href="#更简洁的代码" class="headerlink" title="更简洁的代码"></a>更简洁的代码</h3><p>是不是觉得仅仅为了打印一个hello world要写这么多代码太啰嗦？我这里主要是为了展示RxJava背后的原理而采用了这种比较啰嗦的写法，RxJava其实提供了很多便捷的函数来帮助我们减少代码。</p>
<p>首先来看看如何简化Observable对象的创建过程。RxJava内置了很多简化创建Observable对象的函数，比如 Observable.just就是用来创建只发出一个事件就结束的Observable对象，上面创建Observable对象的代码可以简化为一行</p>
<pre><code>Observable&lt;String&gt; myObservable = Observable.just(&quot;Hello, world!&quot;);  
</code></pre>
<p>接下来看看如何简化Subscriber，上面的例子中，我们其实并不关心OnComplete和OnError，我们只需要在onNext的时候做一些处理，这时候就可以使用Action1类。</p>
<pre><code>Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123;
    @Override
    public void call(String s) &#123;
        System.out.println(s);
    &#125;
&#125;;  
</code></pre>
<p>subscribe方法有一个重载版本，接受三个Action1类型的参数，分别对应OnNext，OnComplete， OnError函数。</p>
<pre><code>myObservable.subscribe(onNextAction, onErrorAction, onCompleteAction);  
</code></pre>
<p>这里我们并不关心onError和onComplete，所以只需要第一个参数就可以</p>
<pre><code>myObservable.subscribe(onNextAction);
// Outputs &quot;Hello, world!&quot;  
</code></pre>
<p>上面的代码最终可以写成这样</p>
<pre><code>Observable.just(&quot;Hello, world!&quot;)
    .subscribe(new Action1&lt;String&gt;() &#123;
        @Override
        public void call(String s) &#123;
              System.out.println(s);
        &#125;
    &#125;);  
</code></pre>
<p>使用java8的lambda可以使代码更简洁</p>
<pre><code>Observable.just(&quot;Hello, world!&quot;)
    .subscribe(s -&gt; System.out.println(s));  
</code></pre>
<p>Android开发中，强烈推荐使用<a href="https://github.com/evant/gradle-retrolambda">retrolambda</a>这个gradle插件，这样你就可以在你的代码中使用lambda了。</p>
<h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><p>让我们做一些更有趣的事情吧！<br>比如我想在hello world中加上我的签名，你可能会想到去修改Observable对象：</p>
<pre><code>Observable.just(&quot;Hello, world! -Dan&quot;)
    .subscribe(s -&gt; System.out.println(s));  
</code></pre>
<p>如果你能够改变Observable对象，这当然是可以的，但是如果你不能修改Observable对象呢？比如Observable对象是第三方库提供的？比如我的Observable对象被多个Subscriber订阅，但是我只想在对某个订阅者做修改呢？<br>那么在Subscriber中对事件进行修改怎么样呢？比如下面的代码：</p>
<pre><code>Observable.just(&quot;Hello, world!&quot;)
    .subscribe(s -&gt; System.out.println(s + &quot; -Dan&quot;));  
</code></pre>
<p>这种方式仍然不能让人满意，因为我希望我的Subscribers越轻量越好，因为我有可能会在mainThread中运行subscriber。另外， 根据响应式函数编程的概念，Subscribers更应该做的事情是“响应”，响应Observable发出的事件，而不是去修改。如果我能在某些中间步 骤中对“Hello World！”进行变换是不是很酷？</p>
<h2 id="操作符（Operators）"><a href="#操作符（Operators）" class="headerlink" title="操作符（Operators）"></a>操作符（Operators）</h2><p>操作符就是为了解决对Observable对象的变换的问题，操作符用于在Observable和最终的Subscriber之间修改Observable发出的事件。RxJava提供了很多很有用的操作符。<br>比如map操作符，就是用来把把一个事件转换为另一个事件的。</p>
<pre><code>Observable.just(&quot;Hello, world!&quot;)
  .map(new Func1&lt;String, String&gt;() &#123;
      @Override
      public String call(String s) &#123;
          return s + &quot; -Dan&quot;;
      &#125;
  &#125;)
  .subscribe(s -&gt; System.out.println(s));  
</code></pre>
<p>使用lambda可以简化为</p>
<pre><code>Observable.just(&quot;Hello, world!&quot;)
    .map(s -&gt; s + &quot; -Dan&quot;)
    .subscribe(s -&gt; System.out.println(s));  
</code></pre>
<p>是不是很酷？map()操作符就是用于变换Observable对象的，map操作符返回一个Observable对象，这样就可以实现链式调用，在一个Observable对象上多次使用map操作符，最终将最简洁的数据传递给Subscriber对象。</p>
<h2 id="map操作符进阶"><a href="#map操作符进阶" class="headerlink" title="map操作符进阶"></a>map操作符进阶</h2><p>map操作符更有趣的一点是它不必返回Observable对象返回的类型，你可以使用map操作符返回一个发出新的数据类型的observable对象。<br>比如上面的例子中，subscriber并不关心返回的字符串，而是想要字符串的hash值</p>
<pre><code>Observable.just(&quot;Hello, world!&quot;)
    .map(new Func1&lt;String, Integer&gt;() &#123;
        @Override
        public Integer call(String s) &#123;
            return s.hashCode();
        &#125;
    &#125;)
    .subscribe(i -&gt; System.out.println(Integer.toString(i)));  
</code></pre>
<p>很有趣吧？我们初始的Observable返回的是字符串，最终的Subscriber收到的却是Integer，当然使用lambda可以进一步简化代码：</p>
<pre><code>Observable.just(&quot;Hello, world!&quot;)
    .map(s -&gt; s.hashCode())
    .subscribe(i -&gt; System.out.println(Integer.toString(i)));  
</code></pre>
<p>前面说过，Subscriber做的事情越少越好，我们再增加一个map操作符</p>
<pre><code>Observable.just(&quot;Hello, world!&quot;)
    .map(s -&gt; s.hashCode())
    .map(i -&gt; Integer.toString(i))
    .subscribe(s -&gt; System.out.println(s));  
</code></pre>
<h2 id="不服？"><a href="#不服？" class="headerlink" title="不服？"></a>不服？</h2><p>是不是觉得我们的例子太简单，不足以说服你？你需要明白下面的两点:</p>
<ol>
<li><p>Observable和Subscriber可以做任何事情<br>Observable可以是一个数据库查询，Subscriber用来显示查询结果；Observable可以是屏幕上的点击事件，Subscriber用来响应点击事件；Observable可以是一个网络请求，Subscriber用来显示请求结果。  </p>
</li>
<li><p>Observable和Subscriber是独立于中间的变换过程的。<br>在Observable和Subscriber中间可以增减任何数量的map。整个系统是高度可组合的，操作数据是一个很简单的过程。  </p>
</li>
</ol>
<p>在<a href="http://ocnyang.com/2016/10/10/RxJavaAbout2_Operators/">第二部分</a>中，我将介绍RxJava的另外一些很酷强大的特性，更多的操作符。</p>
<blockquote>
<p>文章摘录地址：<br><a href="http://blog.danlew.net/2014/09/15/grokking-rxjava-part-1/">英文原文</a><br><a href="http://blog.csdn.net/lzyzsd/article/details/41833541">译文原文</a>   </p>
</blockquote>
]]></content>
      <categories>
        <category>RxJava系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>第三方框架</tag>
        <tag>RxJava系列</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出RxJava（二：操作符）</title>
    <url>/2016/10/10/RxJavaAbout2_Operators/</url>
    <content><![CDATA[<p>在<a href="http://ocnyang.com/2016/10/10/RxJavaAbout1_Base/">第一篇blog</a>中， 我介绍了RxJava的一些基础知识，同时也介绍了map()操作符。当然如果你并没有意愿去使用RxJava我一点都不诧异，毕竟才接触了这么点。看完 这篇blog，我相信你肯定想立即在你的项目中使用RxJava了，这篇blog将介绍许多RxJava中的操作符，RxJava的强大性就来自于它所定义的操作符。</p>
<span id="more"></span>

<p>首先先看一个例子：</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>假设我有这样一个方法：<br>这个方法根据输入的字符串返回一个网站的url列表（啊哈，搜索引擎）</p>
<pre><code>Observable&lt;List&lt;String&gt;&gt; query(String text);  
</code></pre>
<p>现在我希望构建一个健壮系统，它可以查询字符串并且显示结果。根据上一篇blog的内容，我们可能会写出下面的代码：  </p>
<pre><code>query(&quot;Hello, world!&quot;)
    .subscribe(urls -&gt; &#123;
        for (String url : urls) &#123;
            System.out.println(url);
        &#125;
    &#125;);  
</code></pre>
<p>这种代码当然是不能容忍的，因为上面的代码使我们丧失了变化数据流的能力。一旦我们想要更改每一个URL，只能在Subscriber中来做。我们竟然没有使用如此酷的map()操作符！！！  </p>
<p>当然，我可以使用map操作符，map的输入是urls列表，处理的时候还是要for each遍历，一样很蛋疼。  </p>
<p>万幸，还有Observable.from()方法，它接收一个集合作为输入，然后每次输出一个元素给subscriber：  </p>
<pre><code>Observable.from(&quot;url1&quot;, &quot;url2&quot;, &quot;url3&quot;)
    .subscribe(url -&gt; System.out.println(url));  
</code></pre>
<p>我们来把这个方法使用到刚才的场景：  </p>
<pre><code>query(&quot;Hello, world!&quot;)
    .subscribe(urls -&gt; &#123;
        Observable.from(urls)
            .subscribe(url -&gt; System.out.println(url));
    &#125;);  
</code></pre>
<p>虽然去掉了for each循环，但是代码依然看起来很乱。多个嵌套的subscription不仅看起来很丑，难以修改，更严重的是它会破坏某些我们现在还没有讲到的RxJava的特性。  </p>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>救星来了,他就是flatMap()。<br>Observable.flatMap()接收一个Observable的输出作为输入，同时输出另外一个Observable。直接看代码：  </p>
<pre><code>query(&quot;Hello, world!&quot;)
    .flatMap(new Func1&lt;List&lt;String&gt;, Observable&lt;String&gt;&gt;() &#123;
        @Override
        public Observable&lt;String&gt; call(List&lt;String&gt; urls) &#123;
            return Observable.from(urls);
        &#125;
    &#125;)
    .subscribe(url -&gt; System.out.println(url));  
</code></pre>
<p>这里我贴出了整个的函数代码，以方便你了解发生了什么，使用lambda可以大大简化代码长度：</p>
<pre><code>query(&quot;Hello, world!&quot;)
    .flatMap(urls -&gt; Observable.from(urls))
    .subscribe(url -&gt; System.out.println(url));  
</code></pre>
<p>flatMap()是不是看起来很奇怪？为什么它要返回另外一个Observable呢？理解flatMap的关键点在于，flatMap输出的新的 Observable正是我们在Subscriber想要接收的。现在Subscriber不再收到List<String>，而是收到一些 列单个的字符串，就像Observable.from()的输出一样。  </p>
<p>这部分也是我当初学RxJava的时候最难理解的部分，一旦我突然领悟了，RxJava的很多疑问也就一并解决了。  </p>
<h2 id="还可以更好"><a href="#还可以更好" class="headerlink" title="还可以更好"></a>还可以更好</h2><p>flatMap()实在不能更赞了，它可以返回任何它想返回的Observable对象。<br>比如下面的方法：  </p>
<pre><code>// 返回网站的标题，如果404了就返回null
Observable&lt;String&gt; getTitle(String URL);  
</code></pre>
<p>接着前面的例子，现在我不想打印URL了，而是要打印收到的每个网站的标题。问题来了，我的方法每次只能传入一个URL，并且返回值不是一个String，而是一个输出String的Observabl对象。使用flatMap()可以简单的解决这个问题。  </p>
<pre><code>query(&quot;Hello, world!&quot;)
    .flatMap(urls -&gt; Observable.from(urls))
    .flatMap(new Func1&lt;String, Observable&lt;String&gt;&gt;() &#123;
        @Override
        public Observable&lt;String&gt; call(String url) &#123;
            return getTitle(url);
        &#125;
    &#125;)
    .subscribe(title -&gt; System.out.println(title));  
</code></pre>
<p>使用lambda:</p>
<pre><code>query(&quot;Hello, world!&quot;)
    .flatMap(urls -&gt; Observable.from(urls))
    .flatMap(url -&gt; getTitle(url))
    .subscribe(title -&gt; System.out.println(title));  
</code></pre>
<p>是不是感觉很不可思议？我竟然能将多个独立的返回Observable对象的方法组合在一起！帅呆了！<br>不止这些，我还将两个API的调用组合到一个链式调用中了。我们可以将任意多个API调用链接起来。大家应该都应该知道同步所有的API调用，然后将所有 API调用的回调结果组合成需要展示的数据是一件多么蛋疼的事情。这里我们成功的避免了callback hell（多层嵌套的回调，导致代码难以阅读维护）。现在所有的逻辑都包装成了这种简单的响应式调用。  </p>
<h2 id="丰富的操作符"><a href="#丰富的操作符" class="headerlink" title="丰富的操作符"></a>丰富的操作符</h2><p>目前为止，我们已经接触了两个操作符，RxJava中还有更多的操作符，那么我们如何使用其他的操作符来改进我们的代码呢？<br>getTitle()返回null如果url不存在。我们不想输出”null”，那么我们可以从返回的title列表中过滤掉null值！  </p>
<pre><code>query(&quot;Hello, world!&quot;)
    .flatMap(urls -&gt; Observable.from(urls))
    .flatMap(url -&gt; getTitle(url))
    .filter(title -&gt; title != null)
    .subscribe(title -&gt; System.out.println(title));  
</code></pre>
<p>filter()输出和输入相同的元素，并且会过滤掉那些不满足检查条件的。  </p>
<p>如果我们只想要最多5个结果：  </p>
<pre><code>query(&quot;Hello, world!&quot;)
    .flatMap(urls -&gt; Observable.from(urls))
    .flatMap(url -&gt; getTitle(url))
    .filter(title -&gt; title != null)
    .take(5)
    .subscribe(title -&gt; System.out.println(title));  
</code></pre>
<p>take()输出最多指定数量的结果。  </p>
<p>如果我们想在打印之前，把每个标题保存到磁盘：  </p>
<pre><code>query(&quot;Hello, world!&quot;)
    .flatMap(urls -&gt; Observable.from(urls))
    .flatMap(url -&gt; getTitle(url))
    .filter(title -&gt; title != null)
    .take(5)
    .doOnNext(title -&gt; saveTitle(title))
    .subscribe(title -&gt; System.out.println(title));  
</code></pre>
<p>doOnNext()允许我们在每次输出一个元素之前做一些额外的事情，比如这里的保存标题。  </p>
<p>看到这里操作数据流是多么简单了么。你可以添加任意多的操作，并且不会搞乱你的代码。  </p>
<p>RxJava包含了大量的操作符。操作符的数量是有点吓人，但是很值得你去挨个看一下，这样你可以知道有哪些操作符可以使用。弄懂这些操作符可能会花一些时间，但是一旦弄懂了，你就完全掌握了RxJava的威力。  </p>
<p>你甚至可以编写自定义的操作符！这篇blog不打算将自定义操作符，如果你想的话，清自行Google吧。  </p>
<h2 id="感觉如何？"><a href="#感觉如何？" class="headerlink" title="感觉如何？"></a>感觉如何？</h2><p>好吧，你是一个怀疑主义者，并且还很难被说服，那为什么你要关心这些操作符呢？  </p>
<p>因为操作符可以让你对数据流做任何操作。  </p>
<p>将一系列的操作符链接起来就可以完成复杂的逻辑。代码被分解成一系列可以组合的片段。这就是响应式函数编程的魅力。用的越多，就会越多的改变你的编程思维。  </p>
<p>另外，RxJava也使我们处理数据的方式变得更简单。在最后一个例子里，我们调用了两个API，对API返回的数据进行了处理，然后保存到磁盘。 但是我们的Subscriber并不知道这些，它只是认为自己在接收一个Observable<String>对象。良好的封装性也带来了编 码的便利！  </p>
<p>在<a href="http://ocnyang.com/2016/10/10/RxJavaAbout3_Response/">第三部分</a>中，我将介绍RxJava的另外一些很酷的特性，比如错误处理和并发，这些特性并不会直接用来处理数据。  </p>
<blockquote>
<p>文章摘录地址：<br>英文原文 <a href="http://blog.danlew.net/2014/09/22/grokking-rxjava-part-2/">Grokking RxJava, Part 2: Operator, Operator</a><br>译文原文 <a href="http://blog.csdn.net/lzyzsd/article/details/44094895">CSDN</a>   </p>
</blockquote>
]]></content>
      <categories>
        <category>RxJava系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>第三方框架</tag>
        <tag>RxJava系列</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出RxJava（三：响应式的好处）</title>
    <url>/2016/10/10/RxJavaAbout3_Response/</url>
    <content><![CDATA[<p>在第一篇中，我介绍了<a href="http://ocnyang.com/2016/10/10/RxJavaAbout1_Base/">RxJava的基础知识</a>。第二篇中，我向你展示了<a href="http://ocnyang.com/2016/10/10/RxJavaAbout2_Operators/">操作符的强大</a>。但是你可能仍然没被说服。这篇里面，我讲向你展示RxJava的其他的一些好处，相信这篇足够让你去使用Rxjava.</p>
<span id="more"></span>

<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>到目前为止，我们都没怎么介绍onComplete()和onError()函数。这两个函数用来通知订阅者，被观察的对象将停止发送数据以及为什么停止（成功的完成或者出错了）。</p>
<p>下面的代码展示了怎么使用这两个函数：  </p>
<pre><code>Observable.just(&quot;Hello, world!&quot;)
    .map(s -&gt; potentialException(s))
    .map(s -&gt; anotherPotentialException(s))
    .subscribe(new Subscriber&lt;String&gt;() &#123;        @Override
        public void onNext(String s) &#123; System.out.println(s); &#125;        @Override
        public void onCompleted() &#123; System.out.println(&quot;Completed!&quot;); &#125;        @Override
        public void onError(Throwable e) &#123; System.out.println(&quot;Ouch!&quot;); &#125;
    &#125;);  
</code></pre>
<p>代码中的potentialException() 和 anotherPotentialException()有可能会抛出异常。每一个Observerable对象在终结的时候都会调用 onCompleted()或者onError()方法，所以Demo中会打印”Completed!”或者”Ouch!”。  </p>
<p>这种模式有以下几个优点：  </p>
<ol>
<li><p>只要有异常发生onError()一定会被调用<br>这极大的简化了错误处理。只需要在一个地方处理错误即可以。  </p>
</li>
<li><p>操作符不需要处理异常<br>将异常处理交给订阅者来做，Observerable的操作符调用链中一旦有一个抛出了异常，就会直接执行onError()方法。  </p>
</li>
<li><p>你能够知道什么时候订阅者已经接收了全部的数据。<br>知道什么时候任务结束能够帮助简化代码的流程。（虽然有可能Observable对象永远不会结束）  </p>
</li>
</ol>
<p>我觉得这种错误处理方式比传统的错误处理更简单。传统的错误处理中，通常是在每个回调中处理错误。这不仅导致了重复的代码，并且意味着每个回调都必须知道如何处理错误，你的回调代码将和调用者紧耦合在一起。  </p>
<p>使用RxJava，Observable对象根本不需要知道如何处理错误！操作符也不需要处理错误状态-一旦发生错误，就会跳过当前和后续的操作符。所有的错误处理都交给订阅者来做。  </p>
<h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><p>假设你编写的<a href="http://ocnyang.com/">Android</a> app需要从网络请求数据（感觉这是必备的了，还有单机么？）。网络请求需要话费较长的时间，因此你打算在另外一个线程中加载数据。为问题来了！  </p>
<p>编写多线程的Android应用程序是很难的，因为你必须确保代码在正确的线程中运行，否则的话可能会导致app崩溃。最常见的就是在非主线程更新UI。  </p>
<p>使用RxJava，你可以使用subscribeOn()指定观察者代码运行的线程，使用observerOn()指定订阅者运行的线程：  </p>
<pre><code>myObservableServices.retrieveImage(url)
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(bitmap -&gt; myImageView.setImageBitmap(bitmap));  
</code></pre>
<p>是不是很简单？任何在我的Subscriber前面执行的代码都是在I/O线程中运行。最后，操作view的代码在主线程中运行.  </p>
<p>最棒的是我可以把subscribeOn()和observerOn()添加到任何Observable对象上。这两个也是操作符！。我不需要关心Observable对象以及它上面有哪些操作符。仅仅运用这两个操作符就可以实现在不同的线程中调度。  </p>
<p>如果使用AsyncTask或者其他类似的，我将不得不仔细设计我的代码，找出需要并发执行的部分。使用RxJava，我可以保持代码不变，仅仅在需要并发的时候调用这两个操作符就可以。  </p>
<h2 id="订阅（Subscriptions）"><a href="#订阅（Subscriptions）" class="headerlink" title="订阅（Subscriptions）"></a>订阅（Subscriptions）</h2><p>当调用Observable.subscribe()，会返回一个Subscription对象。这个对象代表了被观察者和订阅者之间的联系。  </p>
<pre><code>ubscription subscription = Observable.just(&quot;Hello, World!&quot;)
    .subscribe(s -&gt; System.out.println(s));  
</code></pre>
<p>你可以在后面使用这个Subscription对象来操作被观察者和订阅者之间的联系.  </p>
<pre><code>subscription.unsubscribe();
System.out.println(&quot;Unsubscribed=&quot; + subscription.isUnsubscribed());
// Outputs &quot;Unsubscribed=true&quot;  
</code></pre>
<p>RxJava的另外一个好处就是它处理unsubscribing的时候，会停止整个调用链。如果你使用了一串很复杂的操作符，调用unsubscribe将会在他当前执行的地方终止。不需要做任何额外的工作！  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>记住这个系列仅仅是对RxJava的一个入门介绍。RxJava中有更多的我没介绍的功能等你探索（比如backpressure）。当然我也不是所有的代码都使用响应式的方式–仅仅当代码复杂到我想将它分解成简单的逻辑的时候，我才使用响应式代码。  </p>
<p>最初，我的计划是这篇文章作为这个系列的总结，但是我收到许多请求我介绍在Android中使用RxJava，所以你可以继续阅读<a href="http://ocnyang.com/2016/10/10/RxJavaAbout4_RxAndroid/">第四篇</a>了。我希望这个介绍能让你开始使用RxJava。如果你想学到更多，我建议你阅读<a href="https://github.com/ReactiveX/RxJava">RxJava</a>的官方wiki。  </p>
<blockquote>
<p>文章摘录来源：<br><a href="http://blog.danlew.net/2014/09/30/grokking-rxjava-part-3/">英文原文</a><br><a href="http://blog.csdn.net/lzyzsd/article/details/44891933">译文原文</a>  </p>
</blockquote>
]]></content>
      <categories>
        <category>RxJava系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>第三方框架</tag>
        <tag>RxJava系列</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出RxJava（四：在Android中使用响应式编程）</title>
    <url>/2016/10/10/RxJavaAbout4_RxAndroid/</url>
    <content><![CDATA[<p>在第<a href="http://ocnyang.com/2016/10/10/RxJavaAbout1_Base/">1</a>，<a href="http://ocnyang.com/2016/10/10/RxJavaAbout2_Operators/">2</a>，<a href="http://ocnyang.com/2016/10/10/RxJavaAbout3_Response/">3</a>篇中，我大概介绍了RxJava是怎么使用的。下面我会介绍如何在<a href="http://ocnyang.com/">Android</a>中使用RxJava.</p>
<span id="more"></span>

<h2 id="RxAndroid"><a href="#RxAndroid" class="headerlink" title="RxAndroid"></a>RxAndroid</h2><p>RxAndroid是RxJava的一个针对Android平台的扩展。它包含了一些能够简化Android开发的工具。  </p>
<p>首先，AndroidSchedulers提供了针对Android的线程系统的调度器。需要在UI线程中运行某些代码？很简单，只需要使用AndroidSchedulers.mainThread():  </p>
<pre><code>retrofitService.getImage(url)
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(bitmap -&gt; myImageView.setImageBitmap(bitmap));  
</code></pre>
<p>如果你已经创建了自己的Handler，你可以使用HandlerThreadScheduler1将一个调度器链接到你的handler上。  </p>
<p>接着要介绍的就是AndroidObservable，它提供了跟多的功能来配合Android的生命周期。bindActivity()和 bindFragment()方法默认使用AndroidSchedulers.mainThread()来执行观察者代码，这两个方法会在 Activity或者Fragment结束的时候通知被观察者停止发出新的消息。  </p>
<pre><code>AndroidObservable.bindActivity(this, retrofitService.getImage(url))
    .subscribeOn(Schedulers.io())
    .subscribe(bitmap -&gt; myImageView.setImageBitmap(bitmap);  
</code></pre>
<p>我自己也很喜欢AndroidObservable.fromBroadcast()方法，它允许你创建一个类似BroadcastReceiver的Observable对象。下面的例子展示了如何在网络变化的时候被通知到：  </p>
<pre><code>IntentFilter filter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);
AndroidObservable.fromBroadcast(context, filter)
    .subscribe(intent -&gt; handleConnectivityChange(intent));  
</code></pre>
<p>最后要介绍的是ViewObservable,使用它可以给View添加了一些绑定。如果你想在每次点击view的时候都收到一个事件，可以使用 ViewObservable.clicks()，或者你想监听TextView的内容变化，可以使用ViewObservable.text()。  </p>
<pre><code>ViewObservable.clicks(mCardNameEditText, false)
    .subscribe(view -&gt; handleClick(view));  
</code></pre>
<h2 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h2><p>大名鼎鼎的Retrofit库内置了对RxJava的支持。通常调用发可以通过使用一个Callback对象来获取异步的结果：  </p>
<pre><code>@GET(&quot;/user/&#123;id&#125;/photo&quot;)
void getUserPhoto(@Path(&quot;id&quot;) int id, Callback&lt;Photo&gt; cb);  
</code></pre>
<p>使用RxJava，你可以直接返回一个Observable对象。  </p>
<pre><code>@GET(&quot;/user/&#123;id&#125;/photo&quot;)
Observable&lt;Photo&gt; getUserPhoto(@Path(&quot;id&quot;) int id);  
</code></pre>
<p>现在你可以随意使用Observable对象了。你不仅可以获取数据，还可以进行变换。<br>Retrofit对Observable的支持使得它可以很简单的将多个REST请求结合起来。比如我们有一个请求是获取照片的，还有一个请求是获取元数据的，我们就可以将这两个请求并发的发出，并且等待两个结果都返回之后再做处理：  </p>
<pre><code>Observable.zip(
    service.getUserPhoto(id),
    service.getPhotoMetadata(id),
    (photo, metadata) -&gt; createPhotoWithData(photo, metadata))
    .subscribe(photoWithData -&gt; showPhoto(photoWithData));  
</code></pre>
<p>在第二篇里我展示过一个类似的例子（使用flatMap()）。这里我只是想展示以下使用RxJava+Retrofit可以多么简单地组合多个REST请求。  </p>
<h2 id="遗留代码，运行极慢的代码"><a href="#遗留代码，运行极慢的代码" class="headerlink" title="遗留代码，运行极慢的代码"></a>遗留代码，运行极慢的代码</h2><p>Retrofit可以返回Observable对象，但是如果你使用的别的库并不支持这样怎么办？或者说一个内部的内码，你想把他们转换成Observable的？有什么简单的办法没？  </p>
<p>绝大多数时候Observable.just() 和 Observable.from() 能够帮助你从遗留代码中创建 Observable 对象:  </p>
<pre><code>private Object oldMethod() &#123; ... &#125;

public Observable&lt;Object&gt; newMethod() &#123;
    return Observable.just(oldMethod());
&#125;  
</code></pre>
<p>上面的例子中如果oldMethod()足够快是没有什么问题的，但是如果很慢呢？调用oldMethod()将会阻塞住他所在的线程。<br>为了解决这个问题，可以参考我一直使用的方法–使用defer()来包装缓慢的代码：  </p>
<pre><code>private Object slowBlockingMethod() &#123; ... &#125;

public Observable&lt;Object&gt; newMethod() &#123;
    return Observable.defer(() -&gt; Observable.just(slowBlockingMethod()));
&#125;  
</code></pre>
<p>现在，newMethod()的调用不会阻塞了，除非你订阅返回的observable对象。  </p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>我把最难的部分留在了最后。如何处理Activity的生命周期？主要就是两个问题：  </p>
<ol>
<li>在configuration改变（比如转屏）之后继续之前的Subscription。<br>比如你使用Retrofit发出了一个REST请求，接着想在listview中展示结果。如果在网络请求的时候用户旋转了屏幕怎么办？你当然想继续刚才的请求，但是怎么搞？  </li>
<li>Observable持有Context导致的内存泄露<br>这个问题是因为创建subscription的时候，以某种方式持有了context的引用，尤其是当你和view交互的时候，这太容易发生！如果Observable没有及时结束，内存占用就会越来越大。   </li>
</ol>
<p>不幸的是，没有银弹来解决这两个问题，但是这里有一些指导方案你可以参考。</p>
<p><strong>第一个问题的解决方案</strong> 就是使用RxJava内置的缓存机制，这样你就可以对同一个Observable对象执行 unsubscribe/resubscribe，却不用重复运行得到Observable的代码。cache() (或者 replay())会继续执行网络请求（甚至你调用了unsubscribe也不会停止）。这就是说你可以在Activity重新创建的时候从 cache()的返回值中创建一个新的Observable对象。  </p>
<pre><code>Observable&lt;Photo&gt; request = service.getUserPhoto(id).cache();
Subscription sub = request.subscribe(photo -&gt; handleUserPhoto(photo));

// ...When the Activity is being recreated...
sub.unsubscribe();

// ...Once the Activity is recreated...
request.subscribe(photo -&gt; handleUserPhoto(photo));  
</code></pre>
<p>注意，两次sub是使用的同一个缓存的请求。当然在哪里去存储请求的结果还是要你自己来做，和所有其他的生命周期相关的解决方案一延虎，必须在生命周期外的某个地方存储。（retained fragment或者单例等等）。  </p>
<p><strong>第二个问题的解决方案</strong> 就是在生命周期的某个时刻取消订阅。一个很常见的模式就是使用CompositeSubscription来持有所有的Subscriptions，然后在onDestroy()或者onDestroyView()里取消所有的订阅。  </p>
<pre><code>private CompositeSubscription mCompositeSubscription
    = new CompositeSubscription();

private void doSomething() &#123;
    mCompositeSubscription.add(
        AndroidObservable.bindActivity(this, Observable.just(&quot;Hello, World!&quot;))
        .subscribe(s -&gt; System.out.println(s)));
&#125;

@Override
protected void onDestroy() &#123;
    super.onDestroy();

    mCompositeSubscription.unsubscribe();
&#125;  
</code></pre>
<p>你可以在Activity/Fragment的基类里创建一个CompositeSubscription对象，在子类中使用它。  </p>
<p>注意! 一旦你调用了 CompositeSubscription.unsubscribe()，这个CompositeSubscription对象就不可用了, 如果你还想使用CompositeSubscription，就必须在创建一个新的对象了。  </p>
<p>两个问题的解决方案都需要添加额外的代码，如果谁有更好的方案，欢迎告诉我。  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RxJava还是一个很新的项目，RxAndroid更是。RxAndroid目前还在活跃开发中，也没有多少好的例子。可能一年之后我的一些建议就会被看做过时了。</p>
<blockquote>
<p>文章摘录来源：<br>原文链接  <a href="http://blog.danlew.net/2014/10/08/grokking-rxjava-part-4/">http://blog.danlew.net/2014/10/08/grokking-rxjava-part-4/</a><br>译文链接 <a href="http://blog.csdn.net/lzyzsd/article/details/45033611">http://blog.csdn.net/lzyzsd/article/details/45033611</a></p>
</blockquote>
]]></content>
      <categories>
        <category>RxJava系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>第三方框架</tag>
        <tag>RxJava系列</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Android 使用 Support Annotations 注解优化代码</title>
    <url>/2016/12/28/SupportAnnotations/</url>
    <content><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>本片文章讲解怎么使用Support Annotations注解优化代码，比如使用 <strong>android特有的魔术变量注解替代Enum</strong> 等功能。不要看见使用注解就想到反射会影响性能之类，今天我们就来学习一下Android Support Annotations注解来优化我们的代码，增加可读性的同时，也让让更多的错误消灭在萌芽之中。</p>
<span id="more"></span>

<h3 id="Support-Annotations-简介："><a href="#Support-Annotations-简介：" class="headerlink" title="Support Annotations 简介："></a>Support Annotations 简介：</h3><p><code>Android support library</code> 不断地引入新的注解库，它包含很多有用的元注解，你能用它们修饰你的代码，帮助你发现<code>bug</code>。<code>Support library</code> 自己本身也用到了这些注解，所以作为 <code>support library</code> 的用户，<code>Android Studio</code>已经基于这些注解校验了你的代码并且标注其中潜在的问题。</p>
<h3 id="Support-Annotations-如何引入："><a href="#Support-Annotations-如何引入：" class="headerlink" title="Support Annotations 如何引入："></a>Support Annotations 如何引入：</h3><p>注解默认是没有包含的；它被包装成一个独立的库，如果使用了appcompat库，那么 <code>Support Annotations</code> 就会自动引入进来，因为 <code>appcompat</code> 使用了 <code>Support Annotations</code>，如果没有则需要在 <code>build.gradle</code> 中添加如下配置：</p>
<pre><code>dependencies &#123;
    compile &#39;com.android.support:support-annotations:23.4.0&#39;
&#125;
</code></pre>
<blockquote>
<p>如果你已经引入了 <code>appcompat v7</code> 则可能就没有必要再次引用 <code>support-annotations</code> ,因为 <code>appcompat</code> 默认包含了对其引用。</p>
</blockquote>
<h2 id="Support-Annotations分类："><a href="#Support-Annotations分类：" class="headerlink" title="Support Annotations分类："></a>Support Annotations分类：</h2><h3 id="Typedef-注解：IntDef-StringDef-Android特有的魔术变量注解替代Enum"><a href="#Typedef-注解：IntDef-StringDef-Android特有的魔术变量注解替代Enum" class="headerlink" title="Typedef 注解：IntDef / StringDef (Android特有的魔术变量注解替代Enum)"></a>Typedef 注解：IntDef / StringDef (Android特有的魔术变量注解替代Enum)</h3><p>Enum in Android 枚举Enum在java中是一个完整的类. 而枚举中的每一个值在枚举类中都是一个对象. 所以在我们使用时枚举的值将比整数常量消耗更多的内存. 当我们使用枚举在安卓应用中, 如果我们的程序本身内存消耗就比较大,或者是一个游戏的应用程序. 那么我们最好使用常量来替代枚举。可是使用了常量代替后又不能限制取值了。那有什么好的办法呢？   </p>
<p>当然, Android 支持注解库中有一些好用的annotation helper 我们可以使用它们来解决我们之前的问题(在编译代码时期).<br>IntDef和StringDef 是两个魔术变量注解. 使用这个两个来替代之前使用的Enum. 它将帮助我们在编译代码时期像Enum那样选择变量的功能。 @IntDef和”typedef”作用非常类似，你可以创建另外一个注解，然后用@IntDef指定一个你期望的整型常量值列表，最后你就可以用这个定义好的注解修饰你的API了。接下来我们来使用IntDef来替换Enum看一下.</p>
<pre><code>public class MainActivity extends Activity &#123;
    public static final int SUNDAY = 0;
    public static final int MONDAY = 1;
    &#123;...省略部分&#125;

    @IntDef(&#123;SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY&#125;)
    @Retention(RetentionPolicy.SOURCE)
    public @interface WeekDays &#123;
    &#125;

    @WeekDays
    int currentDay = SUNDAY;

    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        setCurrentDay(WEDNESDAY);

        @WeekDays int today = getCurrentDay();
        switch (today) &#123;
            case SUNDAY:
                break;
            case MONDAY:
                break;
            &#123;...省略部分&#125;
            default:
                break;
        &#125;
    &#125;

    /**
     * 参数只能传入在声明范围内的整型，不然编译通不过
     * @param currentDay
     */
    public void setCurrentDay(@WeekDays int currentDay) &#123;
        this.currentDay = currentDay;
    &#125;

    @WeekDays
    public int getCurrentDay() &#123;
        return currentDay;
    &#125;
&#125;
</code></pre>
<blockquote>
<p><strong>说明：</strong>  </p>
</blockquote>
<ol>
<li>声明一些必要的 <code>int</code> 常量  </li>
<li>声明一个注解为 <code>WeekDays</code>  </li>
<li>使用 <code>@IntDef</code> 修饰 <code>WeekDays</code>,参数设置为待枚举的集合  </li>
<li>使用 <code>@Retention(RetentionPolicy.SOURCE)</code> 指定注解仅存在与源码中,不加入到 <code>class</code> 文件中</li>
</ol>
<p>需要在调用时只能传入指定类型，如果传入类型不对，编译不通过。  </p>
<p>我们也可以指定整型值作为标志位，也就是说这些整型值可以使用 ’｜’ 或者 ’&amp;’ 进行与或等操作。如果我们把@Flavour定义为如下标志位：</p>
<pre><code>@IntDef(flag = true, value = &#123;SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY&#125;)
public @interface Flavour &#123;
&#125;
</code></pre>
<p>那么可以如下调用：</p>
<pre><code>setCurrentDay(SUNDAY &amp; WEDNESDAY);
</code></pre>
<blockquote>
<p>@StringDef用法和@IntDef基本差不多，只不过是针对String类型而已。</p>
</blockquote>
<h3 id="Nullness注解"><a href="#Nullness注解" class="headerlink" title="Nullness注解"></a>Nullness注解</h3><p>@Nullable注解可以用来标识特定的参数或者返回值可以为null。</p>
<p><img src="http://img.shedoor.net/ocnyang/supportAnnotations/nullable.png" alt="@Nullable"></p>
<p>@NonNull注解可以用来标识参数不能为null。</p>
<p><img src="http://img.shedoor.net/ocnyang/supportAnnotations/nonnull.png" alt="@NonNull"></p>
<h3 id="Resource-Type-注解"><a href="#Resource-Type-注解" class="headerlink" title="Resource Type 注解"></a>Resource Type 注解</h3><p>资源在Android中作为整型值来传递。这意味着希望获取一个drawable作为参数的代码很容易被传递了一个string类型的资源，因为他们资源id都是整型的，编译器很难区分。Resource Type注解在这种条件下可以提供类型检查，例如：</p>
<p>如果类型指定错误，编译不会通过。</p>
<p><img src="http://img.shedoor.net/ocnyang/supportAnnotations/resourceType.png" alt="Resource Type"></p>
<p>常见的Resource Type注解,使用方式都是指定一个integer的参数、成员变量、或者方法，检查对应的资源类型。</p>
<ul>
<li>AnimatorRes ：animator资源类型</li>
<li>AnimRes：anim资源类型</li>
<li>AnyRes：任意资源类型</li>
<li>ArrayRes：array资源类型</li>
<li>AttrRes：attr资源类型</li>
<li>BoolRes：boolean资源类型</li>
<li>ColorRes：color资源类型</li>
<li>DimenRes：dimen资源类型。</li>
<li>DrawableRes：drawable资源类型。</li>
<li>FractionRes：fraction资源类型</li>
<li>IdRes：id资源类型</li>
<li>IntegerRes：integer资源类型</li>
<li>InterpolatorRes：interpolator资源类型</li>
<li>LayoutRes：layout资源类型</li>
<li>MenuRes：menu资源类型</li>
<li>PluralsRes：plurals资源类型</li>
<li>RawRes：raw资源类型</li>
<li>StringRes：string资源类型</li>
<li>StyleableRes：styleable资源类型</li>
<li>StyleRes：style资源类型</li>
<li>TransitionRes：transition资源类型</li>
<li>XmlRes：xml资源类型  </li>
</ul>
<p>以上基本上包括了所有的资源类型，但是有时需要通过RGB颜色整型来设置颜色值，在这种情况下，你可以使用 <code>@ColorInt</code> 注解，表示你期望的是一个代表颜色的整数值，如果使用不对同样也是编译不通过</p>
<p><img src="http://img.shedoor.net/ocnyang/supportAnnotations/colorint.png" alt="@ColorInt"></p>
<h3 id="Threading-注解"><a href="#Threading-注解" class="headerlink" title="Threading 注解"></a>Threading 注解</h3><p>比如我们在项目中处理比较耗时的操作，需要制定在工作子线程中执行，可以使用Threading 注解，如果没有在制定的线程中执行也是编译不过的</p>
<p><img src="http://img.shedoor.net/ocnyang/supportAnnotations/threading.png" alt="Threading"></p>
<p>几种Threading注解</p>
<ul>
<li>@UiThread UI线程</li>
<li>@MainThread 主线程</li>
<li>@WorkerThread 子线程</li>
<li>@BinderThread  绑定线程  </li>
</ul>
<h3 id="Value-Constraints-注解：-Size-IntRange-FloatRange"><a href="#Value-Constraints-注解：-Size-IntRange-FloatRange" class="headerlink" title="Value Constraints 注解：@Size, @IntRange, @FloatRange"></a>Value Constraints 注解：<code>@Size</code>, <code>@IntRange</code>, <code>@FloatRange</code></h3><p>在实际开发过程中，我们有时可能需要设置一个取值范围，这时我们可以使用取值范围注解来约束。<br>比如我们设置一个百分比，取值范围为0-100，</p>
<p><img src="http://img.shedoor.net/ocnyang/supportAnnotations/intRange.png" alt="@IntRange"></p>
<p>对于数据、集合以及字符串，你可以用@Size注解参数来限定集合的大小(当参数是字符串的时候，可以限定字符串的长度)。</p>
<p>举几个例子</p>
<ul>
<li>集合不能为空: @Size(min=1)</li>
<li>字符串最大只能有23个字符: @Size(max=23)</li>
<li>数组只能有2个元素: @Size(2)</li>
<li>数组的大小必须是2的倍数 (例如图形API中获取位置的x/y坐标数组: @Size(multiple=2)  </li>
</ul>
<h3 id="Permissions-注解-RequiresPermission"><a href="#Permissions-注解-RequiresPermission" class="headerlink" title="Permissions 注解: @RequiresPermission"></a>Permissions 注解: @RequiresPermission</h3><p>有时我们的方法调用需要调用者拥有指定的权限，这时我们可以使用@RequiresPermission注解，</p>
<pre><code>@RequiresPermission(Manifest.permission.SET_WALLPAPER)
public abstract void setWallpaper(Bitmap bitmap) throws IOException;
</code></pre>
<p>除了上面的单一使用方式，官方同时也给出了如下几种使用场景</p>
<p><strong>（1）如果你至少需要权限集合中的一个，你可以使用anyOf属性</strong></p>
<pre><code>@RequiresPermission(anyOf = &#123;
    Manifest.permission.ACCESS_COARSE_LOCATION,
    Manifest.permission.ACCESS_FINE_LOCATION&#125;)
public abstract Location getLastKnownLocation(String provider);
</code></pre>
<p><strong>（2）如果你同时需要多个权限，你可以用allOf属性</strong></p>
<pre><code>@RequiresPermission(allOf = &#123;
    Manifest.permission.READ_HISTORY_BOOKMARKS,
    Manifest.permission.WRITE_HISTORY_BOOKMARKS&#125;)
public static final void updateVisitedHistory(ContentResolver cr, String url, boolean real) ;  
</code></pre>
<p><strong>（3）对于intents的权限，可以直接在定义的intent常量字符串字段上标注权限需求(他们通常都已经被@SdkConstant注解标注过了)</strong></p>
<pre><code>@RequiresPermission(android.Manifest.permission.BLUETOOTH)
public static final String ACTION_REQUEST_DISCOVERABLE =
            &quot;android.bluetooth.adapter.action.REQUEST_DISCOVERABLE&quot;;
</code></pre>
<p><strong>（4）对于content providers的权限，你可能需要单独的标注读和写的权限访问，所以可以用@Read或者@Write标注每一个权限需求</strong></p>
<pre><code>@RequiresPermission.Read(@RequiresPermission(READ_HISTORY_BOOKMARKS))
@RequiresPermission.Write(@RequiresPermission(WRITE_HISTORY_BOOKMARKS))
public static final Uri BOOKMARKS_URI = Uri.parse(&quot;content://browser/bookmarks&quot;);  
</code></pre>
<h3 id="Overriding-Methods-注解-CallSuper"><a href="#Overriding-Methods-注解-CallSuper" class="headerlink" title="Overriding Methods 注解: @CallSuper"></a>Overriding Methods 注解: @CallSuper</h3><p>如果你的API允许使用者重写你的方法，但是呢，你又需要你自己的方法(父方法)在重写的时候也被调用，这时候你可以使用@CallSuper标注</p>
<p>例如：Activity的onCreate函数</p>
<pre><code>@CallSuper
protected void onCreate(@Nullable Bundle savedInstanceState)
</code></pre>
<p>用了这个后，当重写的方法没有调用父方法时，工具就会给予标记提示</p>
<p><img src="http://img.shedoor.net/ocnyang/supportAnnotations/callsuper.png" alt="@CallSuper"></p>
<h3 id="Return-Values注解-CheckResult"><a href="#Return-Values注解-CheckResult" class="headerlink" title="Return Values注解: @CheckResult"></a>Return Values注解: @CheckResult</h3><p>如果你的方法返回一个值，你期望调用者用这个值做些事情，那么你可以使用 <code>@CheckResult</code> 注解标注这个方法。</p>
<p>这个在具体使用中用的比较少，除非特殊情况，比如在项目中对一个数据进行处理，这个处理比较耗时，我们希望调用该函数的调用者在不需要处理结果的时候，提示没有使用，酌情删除调用。</p>
<p><img src="http://img.shedoor.net/ocnyang/supportAnnotations/checkResult.png" alt="@CheckResult"></p>
<h3 id="Keep-注解"><a href="#Keep-注解" class="headerlink" title="Keep 注解"></a>Keep 注解</h3><p>Keep：指出一个方法在被混淆的时候应该被保留。  </p>
<p>在Android编译生成APK的环节,我们通常需要设置minifyEnabled为true实现下面的两个效果:  </p>
<ul>
<li>混淆代码</li>
<li>删除没有用的代码  </li>
</ul>
<p>但是出于某一些目的,我们需要不混淆某部分代码或者不删除某处代码,除了配置复杂的Proguard文件之外,我们还可以使用@Keep注解.</p>
<pre><code>@Keep
public static int getBitmapWidth(Bitmap bitmap) &#123;
    return bitmap.getWidth();
&#125;
</code></pre>
<h3 id="其他注解"><a href="#其他注解" class="headerlink" title="其他注解"></a>其他注解</h3><p>   <strong>VisibleForTesting</strong>：可注解一个类，方法，或变量，表示有更宽松的可见性，这样它能够有更宽泛的可见性，使代码可以被测试。</p>
<h3 id="IntelliJ注解"><a href="#IntelliJ注解" class="headerlink" title="IntelliJ注解"></a>IntelliJ注解</h3><p><code>IntelliJ</code> ，Android Studio 就是基于它开发的， IntelliJ 有一套它自己的注解； IntDef 分析其实重用的是 MagicConstant 分析的代码，IntelliJ null 分析其实用的是一组配置好的 null 注解。如果你执行 Analyze &gt; Infer Nullity…，它会试图找出所有的 null 约束并添加他们。这个检查有时会插入 IntelliJ 注解。你可以通过搜索,替换为 Android 注解库的注解，或者你也可以直接用 IntelliJ 注解。在 build.gradle 里或者通过 Project Structure 对话框的 Dependencies 面板都可以添加如下依赖：</p>
<pre><code>dependencies &#123;
    compile &#39;com.intellij:annotations:12.0&#39;
&#125;
</code></pre>
<h2 id="结尾："><a href="#结尾：" class="headerlink" title="结尾："></a>结尾：</h2><p>经过查阅资料和博客，系统了学习和总结了关于Support Annotations注解的内容，在编码中通过使用Support Annotations可以提高代码可读性，同时可以在类加载时就可以检查一些错误，同时不会对性能有任何影响，因为Support Annotations中的注解的生命周期全部是RetentionPolicy.class。在以后的编码中大家可以尝试用用。  </p>
<blockquote>
<p><strong>参考文章（本编文章大多来自对下面几篇文章的总结）</strong>：  </p>
<p><a href="http://droidyue.com/blog/2016/08/14/android-annnotation/index.html">http://droidyue.com/blog/2016/08/14/android-annnotation/index.html</a><br><a href="http://www.cnblogs.com/whoislcj/p/5677917.html">http://www.cnblogs.com/whoislcj/p/5677917.html</a><br><a href="https://asce1885.gitbooks.io/android-rd-senior-advanced/content/shen_ru_qian_chu_android_support_annotations.html">https://asce1885.gitbooks.io/android-rd-senior-advanced/content/shen_ru_qian_chu_android_support_annotations.html</a><br><a href="https://noobcoderblog.wordpress.com/2015/04/12/java-enum-and-android-intdefstringdef-annotation/">https://noobcoderblog.wordpress.com/2015/04/12/java-enum-and-android-intdefstringdef-annotation/</a><br><a href="http://szysky.com/2016/05/20/Android-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8annotion%E6%9B%BF%E4%BB%A3Enum/">http://szysky.com/2016/05/20/Android-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8annotion%E6%9B%BF%E4%BB%A3Enum/</a><br><a href="http://anupcowkur.com/posts/a-look-at-android-support-annotations/">http://anupcowkur.com/posts/a-look-at-android-support-annotations/</a>  </p>
</blockquote>
]]></content>
      <categories>
        <category>Android教程系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android教程系列</tag>
      </tags>
  </entry>
  <entry>
    <title>结婚的意义</title>
    <url>/2016/12/06/TheMeaningOfMarriage/</url>
    <content><![CDATA[<p><strong>我们终会懂得，人的成长，注定是一场孤独的旅途。我们都要学会，在生命里的那个寒冷的冬天，一个人孤独地过冬。不奢求别人，不依赖别人，自己温暖自己，自己之于自己，自己给自己力量和勇气。我们都一样，要学会承受生命的孤独与无助，挺过去，才能看见美好和繁华。</strong></p>
<span id="more"></span>

<p><img src="http://img.shedoor.net/ocnyang/marriagemean/marriagemeaning%20%281%29.jpg" alt="结婚的意义">  </p>
<p><strong>文/白昂</strong></p>
<p>有个男生，上个月告诉我，他喜欢上了一个不错的女生，找人打听到了她的电话，和她聊了几次，终于鼓起勇气告白。可是女孩巧妙地回避了他，之后他就不再回复，继续忙碌起来，寻找下一个猎物。我问他，你觉得这样，好还是不好？他说，我不知道，我只知道再晚一点，我就找不到对象了。我问，以前那份痴情的执着，怎么没了？他苦笑，因为，长大了。</p>
<p><img src="http://img.shedoor.net/ocnyang/marriagemean/marriagemeaning%20%282%29.jpg">  </p>
<p>不知从何时起，我们失去了等待和爱一个人的能力，然而我们都明白，又有谁愿意停下脚步，来安静地看看你的伤疤，听听你的苦衷，慢慢地了解一个人呢？你开始学会贮藏自己的情感，少一点期盼，少一点失望，少一点偏执，少一点伤害。成长剥夺了曾经那些矫情又幼稚的情感，经历，冷却了你身上的温度。你终于学会了聪明，不会对一个人倾之所有，不会再轻易对一个人敞开心扉，不会再对一个人倾注过多的时间和精力。你长大了，已然不是那个肆意挥霍时间和精力的少年。优胜劣汰的现实社会，有那么多比你优秀的人仿佛麋鹿一般在用力奔跑，你也要不回头地向前跑，没有时间驻足，没有时间恻隐，你必须把更多的人落在身后，你最无可奈何，但你必须如此。</p>
<p><img src="http://img.shedoor.net/ocnyang/marriagemean/marriagemeaning%20%283%29.jpg" alt="find love">  </p>
<p>有那么一段时光，人们总是会感慨生命中来来去去的人，会想起，会思念，会矫情，但片刻之后便会回归自己的生活，马不停蹄地奔向自己的未来，也不知是摒弃了矫情，还是学会了冷漠。我想，只有放肆地矫情过，长大后才会明白，人的情感，其实都是有期限的，爱，憎，恨，这世间所有的情感，都有期限，过了这个期限，一切都化作似水流年。伤情是因为遗憾，因为不舍，因为对于感情长久的天真，而过了这个期限，已然不会再如此矫情了。成长总会教人放下和忘记，而曾经那份伤情和遗憾的情愫，便是对过往青春，最好的祭奠。</p>
<p><img src="http://img.shedoor.net/ocnyang/marriagemean/marriagemeaning%20%284%29.jpg" alt="一个人的世界">  </p>
<p>我们终其一生寻找的无非是那个甘愿为你停下脚步，为你驻足的人，这是以前看到的一句话。逐渐懂得，生命的时光，越走越短。真正进入你生命的人，越来越少。曾经根深蒂固的情感，也会慢慢地剥离，从你生活的轨迹中消失。有一天，你会开始习惯告别，习惯真的，就再也不见。</p>
<p><img src="http://img.shedoor.net/ocnyang/marriagemean/marriagemeaning%20%285%29.jpg" alt="注定孤独"></p>
<p>我们终会懂得，人的成长，注定是一场孤独的旅途。我们都要学会，在生命里的那个寒冷的冬天，一个人孤独地过冬。不奢求别人，不依赖别人，自己温暖自己，自己之于自己，自己给自己力量和勇气。我们都一样，要学会承受生命的孤独与无助，挺过去，才能看见美好和繁华。</p>
<p>昨天，一个同学说，她要结婚了，因为要赶着一起买房子。不久前，朋友说，想结婚，因为想要一个孩子，生活实在太无趣了。还听到过，不止一个人说，对方条件还不错，那么就结婚吧。很多个结婚的理由，不知道为什么，都是这样的勉强，让人听不出婚姻里喜乐悲哀的理由。很久没有听到这样的理由，他要结婚，是因为很爱很爱一个人，因为想要和另一个人永远的在一起。也许永远，实在是太远了，也许人生真的无法十全十美吧！</p>
<p>在一本书上，看到一位香港的女作家说，我们身处在一个鸡肋世界，生活上太多食之无味的存在，上至婚姻事业，下至中午时分匆匆吃下肚的，那个盒饭。读这段文字的时候，我能够感受到一种不见眼泪的悲伤，和一种不见血肉的折磨。生活，仿佛总在营造着一个又一个的缺陷。</p>
<p><img src="http://img.shedoor.net/ocnyang/marriagemean/marriagemeaning%20%286%29.jpg" alt="等待，回头，遇见">  </p>
<p>有一次，我碰上了一个高中时候的女友，我知道，很长时间以来，她都在相亲，但是始终，没有满意的。于是，我问她，是不是要求太高了，是不是要的是那种，高收入，高学历，高身材的？她笑笑说，不是啊，她对这些倒不是太看重。其实，相亲，是目的性很强的，就是奔着结婚而去，但是，她就是没有那种感觉。什么都对，但是，感觉不对。我知道，这种只要感觉的人是相亲中是最难成功的，就忍不住逼问她，到底是怎样的结婚的感觉呢？她说，我只是希望，在我不开心的时候，他可以让我觉得他会一直在我身边，即使不安慰什么，就抱着我，紧紧的，说他会一直很爱我。我不祈求轰轰烈烈，我的婚姻也会是云淡风情，细水长流。但有一天，当他向我求婚时，不是因为婚姻能带给他多少实际的利益，而是因为，婚姻，在他生活中的那份意义。我希望，在那一刻，他至少可以给我一个理由，他要和我相守，即便，是在那一刻。她的表情坚定，没有一丝玩笑的成分，我忽然觉得有一丝感动，在这个连月光都无法穿越的城市里，感觉到了一丝，温情的光。</p>
]]></content>
      <categories>
        <category>还相信爱情</category>
      </categories>
      <tags>
        <tag>遇见</tag>
        <tag>E.Efall</tag>
        <tag>Love</tag>
      </tags>
  </entry>
  <entry>
    <title>Toolbar开发详解</title>
    <url>/2016/08/26/ToolbarUse/</url>
    <content><![CDATA[<h2 id="初识-Toolbar"><a href="#初识-Toolbar" class="headerlink" title="初识 Toolbar"></a>初识 Toolbar</h2><p>Toolbar 是在 Android 5.0 开始推出的一个 Material Design 风格的导航控件 ，Google 非常推荐大家使用 Toolbar 来作为Android客户端的导航栏，以此来取代之前的 Actionbar 。与 Actionbar 相比，Toolbar 明显要灵活的多。它不像 Actionbar 一样，一定要固定在Activity的顶部，而是可以放到界面的任意位置。  </p>
<span id="more"></span>
<p>除此之外，在设计 Toolbar 的时候，Google也留给了开发者很多可定制修改的余地，这些可定制修改的属性在API文档中都有详细介绍，如：</p>
<ul>
<li>设置导航栏图标；</li>
<li>设置App的logo；</li>
<li>支持设置标题和子标题；</li>
<li>支持添加一个或多个的自定义控件；</li>
<li>支持Action Menu；  </li>
</ul>
<p><img src="http://img.shedoor.net/toolBar/1.png"></p>
<p>总之，与 Actionbar 相比，Toolbar 让我感受到Google满满的诚意。怎样？是否已经对 Toolbar 有大概的了解，跃跃欲试的感觉出来了有木有？接下来，我们就一步一步的来看如何使用 Toolbar。</p>
<h2 id="开始使用-Toolbar"><a href="#开始使用-Toolbar" class="headerlink" title="开始使用 Toolbar"></a>开始使用 Toolbar</h2><p>前面提到 Toolbar 是在 Android 5.0 才开始加上的，Google 为了将这一设计向下兼容，自然也少不了要推出兼容版的 Toolbar 。为此，我们需要在工程中引入 appcompat-v7 的兼容包，使用 android.support.v7.widget.Toolbar 进行开发。下面看一下代码结构，同样把重点部分已经红圈圈出：</p>
<p><img src="http://img.shedoor.net/toolBar/2.png"></p>
<ul>
<li><p>ToolbarActivity 包含了 Toolbar 的一些基本使用， ZhiHuActivity 是在熟悉了 Toolbar 后对知乎主页面的一个高仿实现。</p>
</li>
<li><p>layout和menu文件夹分别是上面提到的两个Activity的布局文件 和 actionmenu 菜单文件。</p>
</li>
<li><p>values、values-v19、values-v21 中包含了一些自定义的 theme，后面用到的时候会顺带讲解。</p>
</li>
</ul>
<p>我们先来看一下 ToolbarActivity 的运行效果</p>
<p><img src="http://img.shedoor.net/toolBar/3.gif"></p>
<p>按照效果图，从左到右分别是我们前面提及到的<strong>导航栏图标、App的logo、标题和子标题、自定义控件、</strong>以及<strong>ActionMenu</strong>。接着，我们来看下布局文件和代码实现。</p>
<p>首先，在布局文件 activity_tool_bar.xml 中添加进我们需要的 Toolbar 控件</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;android.support.v7.widget.Toolbar
        android:id=&quot;@+id/toolbar&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:background=&quot;@color/color_0176da&quot;&gt;

        &lt;!--自定义控件--&gt;
        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;Clock&quot; /&gt;
    &lt;/android.support.v7.widget.Toolbar&gt;
&lt;/LinearLayout&gt;  
</code></pre>
<p>接着在 base_toolbar_menu.xml 中添加 action menu 菜单项</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;

    &lt;item
        android:id=&quot;@id/action_search&quot;
        android:icon=&quot;@mipmap/ic_search&quot;
        android:title=&quot;@string/menu_search&quot;
        app:showAsAction=&quot;ifRoom&quot; /&gt;

    &lt;item
        android:id=&quot;@id/action_notification&quot;
        android:icon=&quot;@mipmap/ic_notifications&quot;
        android:title=&quot;@string/menu_notifications&quot;
        app:showAsAction=&quot;ifRoom&quot; /&gt;

    &lt;item
        android:id=&quot;@+id/action_item1&quot;
        android:title=&quot;@string/item_01&quot;
        app:showAsAction=&quot;never&quot; /&gt;

    &lt;item
        android:id=&quot;@+id/action_item2&quot;
        android:title=&quot;@string/item_02&quot;
        app:showAsAction=&quot;never&quot; /&gt;
&lt;/menu&gt;  
</code></pre>
<p>最后到 ToolbarActivity 中调用代码拿到这 Toolbar 控件，并在代码中做各种setXXX操作。</p>
<pre><code>/**
 * Toolbar的基本使用
 */
public class ToolBarActivity extends BaseActivity &#123;

    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_tool_bar);

        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);

        toolbar.setNavigationIcon(R.mipmap.ic_drawer_home);//设置导航栏图标
        toolbar.setLogo(R.mipmap.ic_launcher);//设置app logo
        toolbar.setTitle(&quot;Title&quot;);//设置主标题
        toolbar.setSubtitle(&quot;Subtitle&quot;);//设置子标题

        toolbar.inflateMenu(R.menu.base_toolbar_menu);//设置右上角的填充菜单
        toolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() &#123;
            @Override
            public boolean onMenuItemClick(MenuItem item) &#123;
                int menuItemId = item.getItemId();
                if (menuItemId == R.id.action_search) &#123;
                    Toast.makeText(ToolBarActivity.this , R.string.menu_search , Toast.LENGTH_SHORT).show();

                &#125; else if (menuItemId == R.id.action_notification) &#123;
                    Toast.makeText(ToolBarActivity.this , R.string.menu_notifications , Toast.LENGTH_SHORT).show();

                &#125; else if (menuItemId == R.id.action_item1) &#123;
                    Toast.makeText(ToolBarActivity.this , R.string.item_01 , Toast.LENGTH_SHORT).show();

                &#125; else if (menuItemId == R.id.action_item2) &#123;
                    Toast.makeText(ToolBarActivity.this , R.string.item_02 , Toast.LENGTH_SHORT).show();

                &#125;
                return true;
            &#125;
        &#125;);
    &#125;
&#125;  
</code></pre>
<p>代码到此已经完成了 Toolbar 的基本使用，注意，是基本使用而已！！！！！下面有几个代码里面需要注意的地方：</p>
<ul>
<li><p>1、我们在使用 Toolbar 时候需要先隐藏掉系统原先的导航栏，网上很多人都说给Activity设置一个NoActionBar的Theme。但个人觉得有点小题大做了，所以这里我直接在BaseActivity中调用 supportRequestWindowFeature(Window.FEATURE_NO_TITLE) 去掉了默认的导航栏（注意，我的BaseActivity是继承了AppCompatActivity的，如果是继承Activity就应该调用requestWindowFeature(Window.FEATURE_NO_TITLE)）；</p>
</li>
<li><p>2、如果你想修改标题和子标题的字体大小、颜色等，可以调用setTitleTextColor、setTitleTextAppearance、setSubtitleTextColor、setSubtitleTextAppearance 这些API；</p>
</li>
<li><p>3、自定义的View位于 title、subtitle 和 actionmenu 之间，这意味着，如果 title 和 subtitle 都在，且 actionmenu选项 太多的时候，留给自定义View的空间就越小；</p>
</li>
<li><p>4、导航图标 和 app logo 的区别在哪？如果你只设置 导航图标（ or app logo） 和 title、subtitle，会发现 app logo 和 title、subtitle 的间距比较小，看起来不如 导航图标 与 它们两搭配美观；</p>
</li>
<li><p>5、Toolbar 和其他控件一样，很多属性设置方法既支持代码设置，也支持在xml中设置（这里也是最最最最最坑爹的地方，如何坑爹法，请接着往下看）；</p>
</li>
</ul>
<h2 id="Toolbar-踩坑填坑"><a href="#Toolbar-踩坑填坑" class="headerlink" title="Toolbar 踩坑填坑"></a>Toolbar 踩坑填坑</h2><h3 id="坑一：xml布局文件中，Toolbar属性设置无效"><a href="#坑一：xml布局文件中，Toolbar属性设置无效" class="headerlink" title="坑一：xml布局文件中，Toolbar属性设置无效"></a>坑一：xml布局文件中，Toolbar属性设置无效</h3><p>刚开始使用Toolbar的时候，我的布局文件中是这样写的</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;android.support.v7.widget.Toolbar
        android:id=&quot;@+id/toolbar&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:background=&quot;@color/color_0176da&quot;
        android:logo=&quot;@mipmap/ic_launcher&quot;
        android:navigationIcon=&quot;@mipmap/ic_drawer_home&quot;
        android:subtitle=&quot;456&quot;
        android:title=&quot;123&quot;&gt;

        &lt;!--自定义控件--&gt;
        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;Clock&quot; /&gt;
    &lt;/android.support.v7.widget.Toolbar&gt;
&lt;/LinearLayout&gt;  
</code></pre>
<p>在真机跑起来之后，看到的结果是下面这样的。</p>
<p><img src="http://img.shedoor.net/toolBar/4.png"></p>
<p>此时心中真是万千匹草泥马在奔腾，除了设置背景色和TextView有效外，说好的 <strong>logo、navigationIcon、subtitle、title</strong> 都跑哪去了？在编译器没报错又不见效果的情况下，参考了其他开发者的用法后找到了以下的解决方案，就是在根布局中加入自定义属性的命名空间</p>
<pre><code>xmlns:toolbar=&quot;http://schemas.android.com/apk/res-auto&quot;(这里的toolbar可以换成你想要其他命名，做过自定义控件的童鞋相比很熟悉此用法了)  
</code></pre>
<p>然后把所有用 android:xxx 设置无效的，都用 toolbar：xxx 设置即可生效。最终的布局代码如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:toolbar=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;android.support.v7.widget.Toolbar
        android:id=&quot;@+id/toolbar&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:background=&quot;@color/color_0176da&quot;
        toolbar:navigationIcon=&quot;@mipmap/ic_drawer_home&quot;
        toolbar:logo=&quot;@mipmap/ic_launcher&quot;
        toolbar:subtitle=&quot;456&quot;
        toolbar:title=&quot;123&quot;&gt;

        &lt;!--自定义控件--&gt;
        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;Clock&quot; /&gt;
    &lt;/android.support.v7.widget.Toolbar&gt;
&lt;/LinearLayout&gt;  
</code></pre>
<p>到此即可解决 xml 中属性设置失效的问题，为什么会出现这种问题呢？我猜测是因为这个控件是兼容版的控件，用 android:xxx 设置无效是的这些属性是在兼容包中，不在默认的Android SDK中，所以我们需要额外的引入。至于为什么IDE不报错，估计就是bug了吧！</p>
<h3 id="坑二：Action-Menu-Item-的文字颜色设置无效"><a href="#坑二：Action-Menu-Item-的文字颜色设置无效" class="headerlink" title="坑二：Action Menu Item 的文字颜色设置无效"></a>坑二：Action Menu Item 的文字颜色设置无效</h3><p>系统默设置了ActionMenu每个Item的文字颜色和大小，像ToolbarActivity在Google原生5.1系统下默认效果就是下面这样的</p>
<p><img src="http://img.shedoor.net/toolBar/5.gif"></p>
<p>Android 5.1 默认的ActionMenu Item的风格<br>此时，如果我有需求要改变一下item文字颜色，应该怎么破？我按照网上比较普遍的解决方案，做了如下两步的修改操作：</p>
<ul>
<li><p>在styles.xml中自定义一个Theme，并设置 actionMenuTextColor 属性（注意：不是 android:actionMenuTextColor ）  </p>
<blockquote>
</blockquote>
  <style name="Theme.ToolBar.Base" parent="Theme.AppCompat.Light.NoActionBar">
      <item name="actionMenuTextColor">@color/color_red</item>
  </style>  </li>
</ul>
<p>在布局文件的Toolbar中设置popupTheme（注意：是toolbar:xxx，不是android:xxx）</p>
<pre><code>&lt;android.support.v7.widget.Toolbar
    android:id=&quot;@+id/toolbar&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:background=&quot;@color/color_0176da&quot;
    toolbar:popupTheme=&quot;@style/Theme.ToolBar.Base&quot;&gt;

    &lt;!--自定义控件--&gt;
    &lt;TextView
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;Clock&quot; /&gt;
&lt;/android.support.v7.widget.Toolbar&gt;
</code></pre>
<p>运行之后，文字的颜色的并没有发生任何改变。说好的改变颜色呢…..找来找去，最后在 StackOverflow 找到一个还不错的解决方案，就是把上面的的 actionMenuTextColor 属性换成 android:textColorPrimary 即可解决，最终得到下面的运行效果。</p>
<p><img src="http://img.shedoor.net/toolBar/6.gif"></p>
<blockquote>
<p>这种方法也有一个小缺点，如果我把自定义控件换成Button，你会发现Button默认的文字颜色也变成了红色。所以，此处如果有朋友有更好的解决方案，请留言赐教。  </p>
</blockquote>
<p>如果你想要修改 ActionMenu Item 的文字大小，也可以在theme中设置加上如下设置</p>
<pre><code>&lt;item name=&quot;android:textSize&quot;&gt;20sp&lt;/item&gt;  
</code></pre>
<p>以上就是目前使用 Toolbar 一些比较折腾的坑，感觉 Google 对 Toolbar 这些坑，还可以进一步优化优化，不然就坑苦了开发者们了。</p>
<blockquote>
<p>摘录来源：<a href="http://www.jianshu.com/p/79604c3ddcae">简书</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Material design</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android教程系列</tag>
        <tag>Toolbar</tag>
        <tag>Material design</tag>
      </tags>
  </entry>
  <entry>
    <title>沉浸式状态栏攻略</title>
    <url>/2016/08/19/TranslucentBars/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>近期注意到QQ新版使用了沉浸式状态栏，ok，先声明一下：本篇博客效果下图：</p>
<p><img src="http://img.shedoor.net/Immersivemenubar/1.jpg">  </p>
<span id="more"></span>

<p>关于这个状态栏变色到底叫「Immersive Mode」/「Translucent Bars」有兴趣可以去 <a href="http://www.zhihu.com/question/27040217">为什么在国内会有很多用户把 ｢透明栏｣（Translucent Bars）称作 ｢沉浸式顶栏｣？</a>上面了解了解.</p>
<p>恩，接下来正题。  </p>
<p>首先只有大于等于4.4版本支持这个半透明状态栏的效果，但是4.4和5.0的显示效果有一定的差异，所有本篇博文内容为：</p>
<ul>
<li>如何实现半透明状态栏效果在大于4.4版本之上。</li>
<li>如何让4.4的效果与5.0的效果尽可能一致。  </li>
</ul>
<p>看了不少参考文章，都介绍到这个库，大家可以了解：<a href="https://github.com/jgilfelt/SystemBarTint">SystemBarTint</a>。</p>
<p>不过本篇博文并未基于此库，自己想了个hack，对于此库源码有空再看了。</p>
<h2 id="二、效果图"><a href="#二、效果图" class="headerlink" title="二、效果图"></a>二、效果图</h2><p>先贴下效果图，以便和实现过程中做下对比</p>
<ul>
<li>4.4 模拟器</li>
</ul>
<p><img src="http://img.shedoor.net/Immersivemenubar/2.gif">  </p>
<ul>
<li>5.x 真机  </li>
</ul>
<p><img src="http://img.shedoor.net/Immersivemenubar/3.gif">  </p>
<p>贴个如果顶部是图片的效果图，其实是一样的，为了方便我就放侧栏的顶部了。</p>
<p><img src="http://img.shedoor.net/Immersivemenubar/4.gif"></p>
<p>ok，有了效果图之后就开始看实现了。</p>
<h2 id="三、实现半透明状态栏"><a href="#三、实现半透明状态栏" class="headerlink" title="三、实现半透明状态栏"></a>三、实现半透明状态栏</h2><p>因为本例使用了NavigationView，所以布局代码稍多，当然如果你不需要，可以自己进行筛减。</p>
<p>注意引入相关依赖：</p>
<pre><code>Java

 compile &#39;com.android.support:appcompat-v7:22.2.1&#39;
 compile &#39;com.android.support:support-v4:22.2.1&#39;
 compile &#39;com.android.support:design:22.2.0&#39;
</code></pre>
<h3 id="（一）colors-xml-和-styles-xml"><a href="#（一）colors-xml-和-styles-xml" class="headerlink" title="（一）colors.xml 和 styles.xml"></a>（一）colors.xml 和 styles.xml</h3><p>首先我们定义几个颜色：</p>
<p>res/values/color.xml</p>
<pre><code>XHTML

&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;color name=&quot;primary&quot;&gt;#FF03A9F4&lt;/color&gt;
    &lt;color name=&quot;primary_dark&quot;&gt;#FF0288D1&lt;/color&gt;
    &lt;color name=&quot;status_bar_color&quot;&gt;@color/primary_dark&lt;/color&gt;
&lt;/resources&gt;
</code></pre>
<p>下面定义几个styles.xml</p>
<p>注意文件夹的路径：</p>
<p>values/styles.xml</p>
<pre><code>XHTML

&lt;resources&gt;
    &lt;style name=&quot;BaseAppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;
        &lt;!-- Customize your theme here. --&gt;
        &lt;item name=&quot;colorPrimary&quot;&gt;@color/primary&lt;/item&gt;
        &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/primary_dark&lt;/item&gt;
        &lt;item name=&quot;colorAccent&quot;&gt;#FF4081&lt;/item&gt;
    &lt;/style&gt;

    &lt;!-- Base application theme. --&gt;
    &lt;style name=&quot;AppTheme&quot; parent=&quot;@style/BaseAppTheme&quot;&gt;
    &lt;/style&gt;
&lt;/resources&gt;
</code></pre>
<p>values-v19</p>
<pre><code>XHTML

&lt;resources&gt;
    &lt;style name=&quot;AppTheme&quot; parent=&quot;@style/BaseAppTheme&quot;&gt;
        &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;
    &lt;/style&gt;
&lt;/resources&gt;
</code></pre>
<p>ok，这个没撒说的。注意我们的主题是基于NoActionBar的，android:windowTranslucentStatus这个属性是v19开始引入的。</p>
<h3 id="（二）布局文件"><a href="#（二）布局文件" class="headerlink" title="（二）布局文件"></a>（二）布局文件</h3><p>activity_main.xml</p>
<pre><code>XHTML

&lt;android.support.v4.widget.DrawerLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    &gt;

    &lt;LinearLayout
        android:id=&quot;@+id/id_main_content&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;

        &lt;android.support.v7.widget.Toolbar
            android:id=&quot;@+id/id_toolbar&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:background=&quot;?attr/colorPrimary&quot;
            android:fitsSystemWindows=&quot;true&quot;
            app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;/&gt;

        &lt;TextView
            android:id=&quot;@+id/id_tv_content&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;0dp&quot;
            android:layout_weight=&quot;1&quot;
            android:gravity=&quot;center&quot;
            android:text=&quot;HelloWorld&quot;
            android:textSize=&quot;30sp&quot;/&gt;
    &lt;/LinearLayout&gt;

    &lt;android.support.design.widget.NavigationView
        android:id=&quot;@+id/id_nv_menu&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_gravity=&quot;start&quot;
        android:fitsSystemWindows=&quot;true&quot;
        app:headerLayout=&quot;@layout/header_just_username&quot;
        app:menu=&quot;@menu/menu_drawer&quot;
        /&gt;
&lt;/android.support.v4.widget.DrawerLayout&gt;
</code></pre>
<p>DrawerLayout内部一个LinearLayout作为内容区域，一个NavigationView作为菜单。<br>注意下Toolbar的高度设置为wrap_content。</p>
<p>然后我们的NavigationView中又依赖一个布局文件和一个menu的文件。</p>
<p>header_just_username.xml</p>
<pre><code>XHTML

&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;192dp&quot;
                android:background=&quot;?attr/colorPrimaryDark&quot;
                android:orientation=&quot;vertical&quot;
                android:padding=&quot;16dp&quot;
                android:fitsSystemWindows=&quot;true&quot;
                android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark&quot;&gt;

    &lt;TextView
        android:id=&quot;@+id/id_link&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_alignParentBottom=&quot;true&quot;
        android:layout_marginBottom=&quot;16dp&quot;
        android:text=&quot;http://blog.csdn.net/lmj623565791&quot;/&gt;

    &lt;TextView
        android:id=&quot;@+id/id_username&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_above=&quot;@id/id_link&quot;
        android:text=&quot;Zhang Hongyang&quot;/&gt;

    &lt;ImageView
        android:layout_width=&quot;72dp&quot;
        android:layout_height=&quot;72dp&quot;
        android:layout_above=&quot;@id/id_username&quot;
        android:layout_marginBottom=&quot;16dp&quot;
        android:src=&quot;@mipmap/ic_launcher&quot;/&gt;

&lt;/RelativeLayout&gt;
</code></pre>
<p>menu的文件就不贴了，更加详细的可以去参考Android 自己实现 NavigationView [Design Support Library(1)]。</p>
<p>大体看完布局文件以后，有几个点要特别注意：</p>
<ul>
<li>ToolBar高度设置为wrap_content</li>
<li>ToolBar添加属性android:fitsSystemWindows=”true”</li>
<li>header_just_username.xml的跟布局RelativeLayout，添加属性android:fitsSystemWindows=”true”  </li>
</ul>
<p>android:fitsSystemWindows这个属性，主要是通过调整当前设置这个属性的view的padding去为我们的status_bar留下空间。</p>
<p>根据上面的解释，如果你不写，那么状态栏和Toolbar就会有挤一块的感觉了，类似会这样：</p>
<p><img src="http://img.shedoor.net/Immersivemenubar/5.jpg">  </p>
<p>ok，最后看下代码。</p>
<h3 id="（三）Activity的代码"><a href="#（三）Activity的代码" class="headerlink" title="（三）Activity的代码"></a>（三）Activity的代码</h3><pre><code>Java

package com.zhy.colorfulstatusbar;

import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.Toolbar;

public class MainActivity extends AppCompatActivity
&#123;

    @Override
    protected void onCreate(Bundle savedInstanceState)
    &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Toolbar toolbar = (Toolbar) findViewById(R.id.id_toolbar);
        setSupportActionBar(toolbar);
        //StatusBarCompat.compat(this, getResources().getColor(R.color.status_bar_color));
        //StatusBarCompat.compat(this);
    &#125;

&#125;
</code></pre>
<p>没撒说的，就是setSupportActionBar。</p>
<ul>
<li>那么现在4.4的效果图是：</li>
</ul>
<p><img src="http://img.shedoor.net/Immersivemenubar/6.jpg">  </p>
<p>其实还不错，有个渐变的效果。</p>
<ul>
<li>现在5.x的效果：</li>
</ul>
<p><img src="http://img.shedoor.net/Immersivemenubar/7.jpg"></p>
<p>可以看到5.x默认并非是一个渐变的效果，类似是一个深一点的颜色。</p>
<p>在看看我们md的规范</p>
<p><img src="http://img.shedoor.net/Immersivemenubar/8.png"></p>
<p>状态栏应该是一个比Toolbar背景色，稍微深一点的颜色。</p>
<p>这么看来，我们还是有必要去为4.4做点适配工作，让其竟可能和5.x显示效果一致，或者说尽可能符合md的规范。</p>
<h2 id="四、调整4-4的显示方案"><a href="#四、调整4-4的显示方案" class="headerlink" title="四、调整4.4的显示方案"></a>四、调整4.4的显示方案</h2><p>那么问题来了？如何做呢？</p>
<p>咱们这么看，4.4之后加入windowTranslucentStatus的属性之后，也就是我们可以用到状态栏的区域了。</p>
<p>既然我们可以用到这块区域，那么我们只要在根布局去设置一个与状态栏等高的View，设置背景色为我们期望的颜色就可以了。</p>
<p>于是有了以下的代码：</p>
<pre><code>Java

package com.zhy.colorfulstatusbar;

import android.annotation.TargetApi;
import android.app.Activity;
import android.content.Context;
import android.graphics.Color;
import android.os.Build;
import android.view.View;
import android.view.ViewGroup;

/**
 * Created by zhy on 15/9/21.
 */
public class StatusBarCompat
&#123;
    private static final int INVALID_VAL = -1;
    private static final int COLOR_DEFAULT = Color.parseColor(&quot;#20000000&quot;);

    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    public static void compat(Activity activity, int statusColor)
    &#123;

        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP)
        &#123;
            if (statusColor != INVALID_VAL)
            &#123;
                activity.getWindow().setStatusBarColor(statusColor);
            &#125;
            return;
        &#125;

        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP)
        &#123;
            int color = COLOR_DEFAULT;
            ViewGroup contentView = (ViewGroup) activity.findViewById(android.R.id.content);
            if (statusColor != INVALID_VAL)
            &#123;
                color = statusColor;
            &#125;
            View statusBarView = new View(activity);
            ViewGroup.LayoutParams lp = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
                    getStatusBarHeight(activity));
            statusBarView.setBackgroundColor(color);
            contentView.addView(statusBarView, lp);
        &#125;

    &#125;

    public static void compat(Activity activity)
    &#123;
        compat(activity, INVALID_VAL);
    &#125;

    public static int getStatusBarHeight(Context context)
    &#123;
        int result = 0;
        int resourceId = context.getResources().getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;);
        if (resourceId &gt; 0)
        &#123;
            result = context.getResources().getDimensionPixelSize(resourceId);
        &#125;
        return result;
    &#125;
&#125;
</code></pre>
<p>代码的思路很简单，根据Activity找到android.R.content，在其中添加一个View(高度为statusbarHeight，背景色为我们设置的颜色，默认为半透明的黑色)。</p>
<p>那么只需要在Activity里面去写上：</p>
<pre><code>Java

StatusBarCompat.compat(this);
</code></pre>
<p>就可以了。</p>
<p>如果你希望自己设置状态看颜色，那么就用这个方法：</p>
<pre><code>Java

StatusBarCompat.compat(this, getResources().getColor(R.color.status_bar_color));
</code></pre>
<p>这样的话我们就解决了4.4到5.x的适配问题，一行代码解决，感觉还是不错的。</p>
<p>最后提一下，对于5.0由于提供了setStatusBarColor去设置状态栏颜色，但是这个方法不能在主题中设置windowTranslucentStatus属性。所以，可以编写一个value-v21文件夹，里面styles.xml写入：</p>
<pre><code>XHTML

&lt;resources&gt;
    &lt;!-- Base application theme. --&gt;
    &lt;style name=&quot;AppTheme&quot; parent=&quot;@style/BaseAppTheme&quot;&gt;
    &lt;/style&gt;
&lt;/resources&gt;
</code></pre>
<p>其实就是不要有windowTranslucentStatus属性。</p>
<p>接下来，对于默认的效果就不测试了，参考上面的效果图。</p>
<p>我们测试个设置状态栏颜色的，我们这里设置个红色。</p>
<ul>
<li>4.4 模拟器  </li>
</ul>
<p><img src="http://img.shedoor.net/Immersivemenubar/9.gif"></p>
<ul>
<li>5.x 真机  </li>
</ul>
<p><img src="http://img.shedoor.net/Immersivemenubar/10.gif"></p>
<p>ok，这样就结束啦~~</p>
<p>源码地址:<a href="https://github.com/hongyangAndroid/ColorfulStatusBar">https://github.com/hongyangAndroid/ColorfulStatusBar</a></p>
<p>参考</p>
<ul>
<li><a href="http://blog.raffaeu.com/archive/2015/04/11/android-and-the-transparent-status-bar.aspx">http://blog.raffaeu.com/archive/2015/04/11/android-and-the-transparent-status-bar.aspx</a></li>
<li><a href="https://mindofaandroiddev.wordpress.com/2013/12/28/making-the-status-bar-and-navigation-bar-transparent-with-a-listview-on-android-4-4-kitkat/">https://mindofaandroiddev.wordpress.com/2013/12/28/making-the-status-bar-and-navigation-bar-transparent-with-a-listview-on-android-4-4-kitkat/</a></li>
<li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1117/1992.html">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1117/1992.html</a>  </li>
<li><a href="http://developer.android.com/intl/zh-cn/reference/android/view/View.html#attr_android:fitsSystemWindows">http://developer.android.com/intl/zh-cn/reference/android/view/View.html#attr_android:fitsSystemWindows</a>  </li>
</ul>
<blockquote>
<p>原文出处： <a href="http://blog.csdn.net/lmj623565791/article/details/48649563">鸿洋</a>   </p>
</blockquote>
]]></content>
      <categories>
        <category>Android教程系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android教程系列</tag>
      </tags>
  </entry>
  <entry>
    <title>小诗：《心结》</title>
    <url>/1993/03/15/XinJie/</url>
    <content><![CDATA[<h1 id="《心结》"><a href="#《心结》" class="headerlink" title="《心结》"></a><center>《心结》</center></h1><center>作者： OCN.Yang</center>  
<center>**心有千千结，结结相思扣。**</center>
<center>**相思扣难解，心上一度秋。**</center>
</br>
</br>
<span style="display:inline-block;width:83px;"><a style="float:left;text-decoration:none;" target="_blank" href="http://www.banquanyin.com/u/101701040004406"><img src="http://s1.banquanyin.com/c/icon-yin-24.png" title="更多授权" style="width:inherit;"></a><a target="_blank" href="http://101701040004406.bqy.pub"><img src="http://s1.banquanyin.com/c/icon-auth-cr-24.png" title="获取授权" style="width:inherit;"></a></span>

</br>
</br>
]]></content>
      <categories>
        <category>还相信爱情</category>
      </categories>
      <tags>
        <tag>遇见</tag>
        <tag>E.Efall</tag>
        <tag>Love</tag>
      </tags>
  </entry>
  <entry>
    <title>你真的懂啥是1024吗？</title>
    <url>/2016/10/24/day1024/</url>
    <content><![CDATA[<p>今天就是一年一度的<a href="http://ocnyang.com/">1024节</a>了！</p>
<pre><code>package com.ocnyang.app;
/**
 * 程序员们，1024快乐。
 */
public class Hello1024 &#123;
    public static final String PROGRAM_APES = &quot;程序猿&quot;;
    public static final String PROGRAM_GIRLS = &quot;程序媛&quot;; //这个真不知道怎么翻译了
    public static final String DATE_1024 = &quot;10月24日&quot;;

    public static void main(String args[]) &#123;
        java.util.Calendar c = java.util.Calendar.getInstance();
        java.text.SimpleDateFormat f = new java.text.SimpleDateFormat(&quot;yyyy年MM月dd日hh时mm分ss秒&quot;);
        is1024(f.format(c.getTime()));
    &#125;

    private static void is1024(String date) &#123;
        if ((!android.text.TextUtils.isEmpty(date)) &amp;&amp; date.contains(DATE_1024))
            System.out.println(PROGRAM_APES + &quot;和&quot; + PROGRAM_GIRLS + &quot;,Happy 1024!&quot;);
    &#125;
&#125;
</code></pre>
<span id="more"></span>

<p>好吧并没有这个节，不过这个日子该庆祝啥，相信在座诸位很多人都懂的：</p>
<p>当然是庆祝二进制了！</p>
<p>1024是一个整数嘛。它等于 210，二进制表示为10000000000。</p>
<p>本来1024这种东西应该是数学家的玩具，但是不幸我们有了电脑，而电脑是基于二进制运行的，所以这个奇怪的数字就变得人尽皆知了……</p>
<h2 id="一个来自巧合的单位"><a href="#一个来自巧合的单位" class="headerlink" title="一个来自巧合的单位"></a>一个来自巧合的单位</h2><p>因为电脑的运行和存储都基于二进制，所以内存也好磁盘也好闪存也好，理论总容量应该是2的某次幂。老一些的内存都是64M、128M、256M、512M这样的数字，更老一些的电脑开机自检会在屏幕上读出内存容量，往往还要读3遍，经常能看到16384kB、65536kB这样的数字——这些也都是2的次幂。</p>
<p><img src="http://img.shedoor.net/1024/1024.gif" alt="1024">  </p>
<p>可能今天多数人对2的次幂主要的熟悉来源，是2048这个游戏。虽然2048是明确复刻了1024，而1024则是抄袭了”Three!”的创意，但这种事情这里就不要提了吧。图片来源：imgur.com</p>
<p>但最常用的2次幂，当然还是1024——它是计算机领域的基本倍数：1M = 1024k，1G = 1024M，等等。</p>
<p>问题来了！<strong>1024和1000</strong>太接近了——一个有趣而有用的巧合，正因此它成了计算机的基本倍数；但另一些时候就烦人了。</p>
<p>210 ≈ 103，这个巧合在估算的时候很管用。比如想知道262是多少，就把它拆成260 × 22，前者约等于1018，后者等于4，因此就是4×1018。（实际上大约是4.61×1018，相差不大。）</p>
<p>但这只是数量级上相差不大，1024毕竟不等于1000。如果你买了一个4600T的硬盘，结果到手只有4000T，你可能就不开心了。</p>
<h2 id="到底是1000还是1024？"><a href="#到底是1000还是1024？" class="headerlink" title="到底是1000还是1024？"></a>到底是1000还是1024？</h2><p>其实现在硬盘几乎都在玩这个花招。计算机内部计算都是按照1024来算的，但是销售时却都会按照1000来宣称。比如我现在这个标称为500G的硬盘，实际上总可用空间是接近500000000000字节，对于计算机来说，只有465G。</p>
<p><img src="http://img.shedoor.net/1024/10242.png" alt="1000or1024">  </p>
<p>然而你又不太好说他们错——k啊M啊这些前缀，都是从科学计数法的前缀里拿来的，人家本来就是指1000，只是在电脑里成了1024。这些前缀都来自希腊语：</p>
<ul>
<li><strong>kilo</strong>是1795年法国人设立公制的时候从希腊语改来的词，本来是1000，但计算机里1kB = 1024B；</li>
<li><strong>Mega</strong>来自希腊文“大”，1947年在科学计数法里确立为1000k，在计算机里就是1024k；</li>
<li><strong>Giga</strong>来自希腊文“非常大”，在科学计数法是1000M，计算机是1024M；</li>
<li><strong>Tera</strong>来自希腊文“怪物”，在科学计数法是1000G，计算机是1024G；</li>
<li><strong>Peta</strong>来自希腊文“五”，因为正常的大词用完了，于是改用“第五个1000”这种意思。在科学计数法是1000T，计算机是1024T。其实本来五应该写作penta，但是因为上一个词——Tera正好比“四”Tetra少一个字母，所以Peta也是故意去掉了中间的字母来保证不会和原词相混；</li>
<li><strong>Exa</strong>来自希腊文“六”，和hexa同根，但这次希腊文自己就没有保留那个“h”，所以沿用了；</li>
<li><strong>Zetta</strong>是本系列里唯一的异类。正常的希腊文“七”前缀应该是hepta，但没有使用，反而用了希腊数字体系里的Ζʹ（读作zeta）；</li>
<li><strong>Yotta</strong>则回归本源，来自希腊文“八”。</li>
</ul>
<p>一般用户几乎不会接触到P以上的级别。在T这一级上，二者的差距不到10%，大家通常也就忍了。</p>
<p>为了避免混淆，国际电工委员会（IEC）提出过一个标准：IEC 80000-13。在这个标准下，科学计数法（1000）按照正常标记，而计算机领域（1024）则全都加一个小写i。因此，1kB就是1000B，而1KiB才是1024B；1 MiB = 1024 KiB，1 GiB = 1024 MiB，等等。不幸的是，这个标准没有得到很广泛的使用，现在大家还是都是乱来的。</p>
<h2 id="最先用1024的可能是……埃及人？"><a href="#最先用1024的可能是……埃及人？" class="headerlink" title="最先用1024的可能是……埃及人？"></a>最先用1024的可能是……埃及人？</h2><p>大家平常喜欢说是中国人发明了二进制。这么说倒也不是不可以，二进制正式进入数学体系要归功于莱布尼兹，而莱布尼兹很喜欢中国，明确认为《易》所用的八卦和六十四卦就是一种二进制。但是古代中国人并没有使用这些二进制数进行计算。单纯说构想出二进制表达数字的办法，那很多文明都干过；然而古埃及人有一种乘法，真的是在用相当于二进制的方式来运算了。</p>
<p>比如，计算1262 × 13，他们会这样计算：</p>
<pre><code>1262 × 13
= (1024 + 128 + 64 + 32 + 8 + 4 + 2) × 13
= 1024 ×  13 + 128 × 13 + 64 × 13 + 32 × 13 + 8 × 13 + 4 × 13 + 2 × 13
= 13312 + 1664 + 832 + 416 + 104 + 52 + 26
= 16406
</code></pre>
<p>等等，这是在干啥？</p>
<p>如果我们来做乘法的话，那么我们会：</p>
<pre><code>1262 × 13
= 1000 × 13 + 200 × 13 + 60 × 13 + 2 × 13
</code></pre>
<p>……好像也差不多。</p>
<p>对，古埃及人也是把大数拆成小数来算乘法，但是我们拆成10、100、1000的倍数，而他们则拆成2、4、8、16、32、64……的倍数。这是二进制呀！</p>
<p>虽然不那么直观，但是二进制也有它的好处：便于不动脑查表格。按照我们十进制乘法，每一位都有10种可能：千位可能没有，也可能是1000、2000、3000、4000……9000。这样表格上就得留出9个位置。但是二进制乘法下，每一位要么有，要么没有。虽然要拆的次数变成了三倍（还记得为什么是三倍吗），但拆完之后就省事儿了。</p>
<p>这种计算方式并没有对后代产生很大影响，但每次我们敲出1024的时候，除了<a href="http://www.guokr.com/article/181723/">达盖尔</a>的旗帜之外，似乎还是值得缅怀一下古埃及人？</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/12/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>你认识我的时候</title>
    <url>/2016/07/24/thetime_youmeetme/</url>
    <content><![CDATA[<p>你认识我的时候，我已是待嫁的年龄，你没有见过我和男生成群结队去别人家菜地偷萝卜的样子；</p>
<p>你认识我的时候，我已经蓄了很久的长发，你没有见过我剪短发穿迷彩服混迹于男生堆打闹的岁月；</p>
<p>你认识我的时候，我已经可以照顾自己，心情不好就做家务，手洗各种衣服，你不知道从前的我不会洗袜子，从没拖过地。</p>
<span id="more"></span>
<p>你认识我的时候，我知道替别人着想、习惯倾听，从不打断别人的说话，你没有经历过我武断专横、不听任何人解释、我行我素的岁月。</p>
<p>你认识我的时候，我脾气收敛，从不大声骂人，你不会知道原来的我生气时摔东西、撕纸条泄愤。</p>
<p>你认识我的时候，我理性、友好、克制、习惯微笑，你没有见过我情绪崩溃，哭到喘不过气，甚至没有见过我撒娇的样子。</p>
<p>你认识我的时候，我已经养成了良好的饮食习惯和运动习惯，你不知道从前的我喜欢吃油炸食品，不爱跑步，晚上十点半可以吃掉半盆排骨，把自己喂到130多斤。</p>
<p>你认识我的时候，我已经会画简单的妆，知道什么季节穿黑丝袜、什么季节穿打底裤，商场里给你介绍化妆品让你晕头转向，你无法想象上中学时的我，早晨只刷牙不洗脸不梳头还能在学校转一整天。</p>
<p>你认识我的时候，我已经知道怎么和陌生人打交道、怎么在酒桌上全身而退，你没有见过我说话脸红、被一瓶啤酒醉倒睡一晚的时候。</p>
<p>你认识我的时候，我已经是这个样子，是个符合或者不符合你想法的成品，你再也无法参与我的成长，不能看到我从不懂事到懂事，从不温柔到温柔。</p>
<p>所以，你认识的、喜欢的终究只是半个我。你不能理解我各种奇怪的忌讳，不能明白我对着一首老歌，一种场景发呆，无法理解我的坚持、放弃、隐忍、等待。同样，我认识你的时候，你穿带领子的衣服上班、不知道你穿球衣打球的样子；我认识你的时候，你请吃饭从不心疼，那些花钱拮据，攒钱吃大餐的日子你不是和我在一起；我认识你的时候，你知道不同的花代表不同的花语，而那个伴你成长教会你这些的女生不是我。我们半路相遇，都是成品，那些打磨过我们的人都随着时光走远了。</p>
<p>我是应该唏嘘还是应该感谢， 别人教会你这些，陪着你长大，然后你们分开，再转到我的身边。我是应该庆幸吧，看到的你已是稳重大方、彬彬有礼、知道对女生该说什么话，如何讨人喜欢。可是我多么想有一个人和我一起成长，和我一起年少轻狂、少不更事，从青涩到成熟都只是同一个人，成长的痕迹在对方眼中就能看到。二十多年的岁月中有十几年是和他相伴，然后一起让小时候的梦想一步步都成为现实。</p>
<p>遗憾的是，所有的旅伴都是暂时的，我终于还是自己长大了，跟着不同的队伍，最后还是一个人、孤独的长大了。</p>
]]></content>
      <categories>
        <category>还相信爱情</category>
      </categories>
      <tags>
        <tag>遇见</tag>
        <tag>E.Efall</tag>
        <tag>Love</tag>
      </tags>
  </entry>
  <entry>
    <title>当你迷茫的时候</title>
    <url>/2016/08/03/whenyouloseyouself/</url>
    <content><![CDATA[<h1 id="致迷茫的你"><a href="#致迷茫的你" class="headerlink" title="致迷茫的你"></a>致迷茫的你</h1><p><strong>致迷茫的你13幅探讨关于生活哲学的逻辑图，将帮助你更清晰地了解自己的行为、目标以及思考问题的方式，选择正确的方式去实现心中所想。</strong></p>
<span id="more"></span>

<p><img src="http://img.shedoor.net/1.png" alt="什么是生活"></p>
<h3 id="No-1、什么是生活"><a href="#No-1、什么是生活" class="headerlink" title="No.1、什么是生活"></a>No.1、什么是生活</h3><p>生活中我们往往因为缺乏对自我的认知而错过了我们很多原本属于自己的生活，生活总是在不经意间见错过了那些最美好的东西。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“Pay close attention. This is your life.”</span><br></pre></td></tr></table></figure>
<p>请留意生活中的细节，这是你的生活。</p>
<p><img src="http://img.shedoor.net/2.png"></p>
<h3 id="No-2、明天比今天更重要"><a href="#No-2、明天比今天更重要" class="headerlink" title="No.2、明天比今天更重要"></a>No.2、明天比今天更重要</h3><p>人们总是过于在意那些重要的决定 (比如接受什么样的工作或者职位) 但是实际上明天总是模糊的。潜心规划，向你认为最好的目标大胆进发，要知道，很少有所谓完全“正确”或是“错误”的决定，因为它们只不过都是一个让你的生命进入下一个阶段的台阶。</p>
<p><strong>认真地思考，清楚滴知道自己的追求及内心深处想要的东西是神马，这是航行中的灯塔，没有了这个灯塔，前行的路上就会有更多“错误”的选择，今天—&gt;明天是一条不可逆转的路，珍惜每个当下及生命中的过客。</strong></p>
<p><img src="http://img.shedoor.net/3.png"></p>
<h3 id="No-3、获得满足感"><a href="#No-3、获得满足感" class="headerlink" title="No.3、获得满足感"></a>No.3、获得满足感</h3><p>和你得到的实物相比，你可以从和别人建立的关系中获得更多的满足。在我们的现实生活中，我们总是错误地追求“物质”所带来的快感，就如我常说的，钱绝对不是 我们人生的追求，它只不过是满足我们需求的工具而已，可是很多人只看了工具，却没有想清楚，努力获得这个工具用来干什么？在现实生活中往往会出现两种情况：</p>
<ol>
<li><p><strong>钱有了，却无所事事；</strong></p>
</li>
<li><p><strong>钱没了，所有的精力及焦点都陷入到“求生存”的状态，几乎没有心智考虑幸福的事情，然后越来越穷，越来越没有幸福感。</strong></p>
</li>
</ol>
<p><img src="http://img.shedoor.net/4.png"></p>
<h3 id="No-4、体现生命的价值"><a href="#No-4、体现生命的价值" class="headerlink" title="No.4、体现生命的价值"></a>No.4、体现生命的价值</h3><p>在 这里的“头衔”是指他人的评价，也就是所谓的面子，我们往往太在意他人的评价而忽略了自己最真实的需求，有一句话说的很好“外面只有自己，没有别人”；这 句话反过来说也挺有意义：“里面只有别人，没有自己”，真正的忽略了别人的评价。其实，我们在生活的道场中要认真的反思与修行。尊重人比尊重头衔重要，每 个人的生命都有自己的价值。</p>
<p><strong>外面只有自己，没有别人。</strong></p>
<p><strong>里面只有别人，没有自己。</strong></p>
<p><img src="http://img.shedoor.net/5.png"></p>
<h3 id="NO-5、不要轻易说“不”"><a href="#NO-5、不要轻易说“不”" class="headerlink" title="NO.5、不要轻易说“不”"></a>NO.5、不要轻易说“不”</h3><p>学会重新认识拒绝。当你努力想要成为领导者或者建立公司的时候，人们会经常告诉你“不行”。但是与其把这个NO视为事情的结束，不如把它看作一个寻找原因的 机会：你是不是找了错误的人?你是不是还没有展现出你具有承担这个新责任的能力? 水滴石穿，NO会变成另一个等待，学习和再次尝试的机会。</p>
<p><strong>其实人们最大的问题问题在于遭受拒绝的时候“郁闷”的心情，由于情绪的影响我们不愿意发现自己的问题，而更愿意用找借口的方式去处理，因为这个过程中是逃避 了“发现自己问题”痛苦，就像吃了止疼药，虽然现在不疼了，可问题还是会出现，因此多去“求证为什么”是一种非常好的思维模式。</strong></p>
<p><img src="http://img.shedoor.net/6.png"></p>
<h3 id="No-6、挑战自我"><a href="#No-6、挑战自我" class="headerlink" title="No.6、挑战自我"></a>No.6、挑战自我</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“Find a place where you can be challenged. Ask yourself: Am I proudof my work?”</span><br></pre></td></tr></table></figure>
<p>找到一个挑战自己的事业。自省:“我是否为我的工作感到自豪”？</p>
<p><strong>这是一幅很有意义的图，如果你不去热爱你的工作与生活，不能发现工作与生活中的价值，再大的努力你的人生体验都会停留在峰底。</strong></p>
<p><img src="http://img.shedoor.net/7.png"></p>
<h3 id="No-7、别害怕不确定性"><a href="#No-7、别害怕不确定性" class="headerlink" title="No.7、别害怕不确定性"></a>No.7、别害怕不确定性</h3><p>别害怕偏离你的计划,勇敢的接受不确定性。那些在你感情，工作和生活上表现出不确定性和高风险的东西往往都是很Cool而且很值得你尝试的。</p>
<p><strong>其实偏离计划的事情，往往可以帮助自己打破“舒适圈”，在早些时候，选择一些自己不愿意做的事情，当然这些事情不会带来太大的负面情绪与结果，然后反思这个过程，个人的成长还是蛮大的，所以尝试你没有尝试的是一种进步，有时候也很Cool！</strong></p>
<p><img src="http://img.shedoor.net/8.png"></p>
<h3 id="No-8、回顾过去的经历"><a href="#No-8、回顾过去的经历" class="headerlink" title="No.8、回顾过去的经历"></a>No.8、回顾过去的经历</h3><p>当你进入你人生的新阶段，别忘了停下来回头看看，去发现你过去经历的意义。它可以让你更好的了解你是谁，将到哪里去，如何去那里。</p>
<p><strong>这真心是一个不错的建议，所有的经历没有反思则这份经历就失去了成长的意义，如果一直按照一个思维方式去思考问题，经历再多结果也是一样，不管是工作还是感情都符合这条规则。</strong></p>
<p><img src="http://img.shedoor.net/9.png"></p>
<h3 id="No-9、受到教育不等于聪明"><a href="#No-9、受到教育不等于聪明" class="headerlink" title="No.9、受到教育不等于聪明"></a>No.9、受到教育不等于聪明</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“Never confuse being educated with being smart。”</span><br></pre></td></tr></table></figure>
<p>别把受到教育这件事和聪明这件事混为一个概念。</p>
<p>** 特别是在中国，别把自己的高等教育当回事，即便你的学历再高，南哥让你说出小学五年级第一篇语文课文的题目时，你恐怕早已经不记得了，真正的思考能力、创新能力及优秀的品格才是职业发展的源动力。 **</p>
<p><img src="http://img.shedoor.net/10.png"></p>
<h3 id="No-10、阅读能激发灵感"><a href="#No-10、阅读能激发灵感" class="headerlink" title="No.10、阅读能激发灵感"></a>No.10、阅读能激发灵感</h3><p>广泛的阅读，热情的阅读。创造力是一个必需的生存技能，而一些灵感就来自于你没有期待的来源。</p>
<p><strong>这是一幅需要铭记在心的图画，你阅读的越多你的灵感就越多，找到恰当的书籍，在阅读时候并联想解决自己遇到的问题是一种非常高效的学习方法。</strong></p>
<p><img src="http://img.shedoor.net/11.png"></p>
<h3 id="No-11、诚实比什么都重要"><a href="#No-11、诚实比什么都重要" class="headerlink" title="No.11、诚实比什么都重要"></a>No.11、诚实比什么都重要</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“Be true to yourself. Be willing to learn and to be coachable.”</span><br></pre></td></tr></table></figure>
<p>诚实的对待自己，愿意学习，愿意被指导。</p>
<p><strong>关于诚实我们被这个社会教坏了，导致我们有一部分人不能诚实的对待别人，更不能诚实的对待自己的内心世界，所谓的诚实地对待别人是真诚+真实的想法，所谓诚实的对待自己就是认清自己真实的想法与清醒，能够允许自己的喜怒哀乐！</strong></p>
<p><img src="http://img.shedoor.net/12.png"></p>
<h3 id="No-12、拥有感恩的心"><a href="#No-12、拥有感恩的心" class="headerlink" title="No.12、拥有感恩的心"></a>No.12、拥有感恩的心</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“Give back—serve from a sense of gratitude.”</span><br></pre></td></tr></table></figure>
<p>回报用感恩的心，感恩身边的人和事。</p>
<p><strong>关于感恩的心很多时候被解读为知恩图报，实际上这是一种幸福生活的方式，因为常怀感恩之心的人，内心总是充满了感动，而那些受益者以理所当然的心态，或者是一味的扮演索取者的角色是永远无法感受到这份感动，却时常陷入到得不偿失的痛苦之中。</strong></p>
]]></content>
      <categories>
        <category>还相信爱情</category>
      </categories>
      <tags>
        <tag>遇见</tag>
        <tag>E.Efall</tag>
        <tag>Love</tag>
      </tags>
  </entry>
  <entry>
    <title>xUtils3简介</title>
    <url>/2016/07/31/xUtils3/</url>
    <content><![CDATA[<ul>
<li>xUtils 包含了很多实用的android工具.</li>
<li>xUtils 支持超大文件(超过2G)上传，更全面的http请求协议支持(11种谓词)，拥有更加灵活的ORM，更多的事件注解支持且不受混淆影响…</li>
<li>xUtils 最低兼容Android 4.0 (api level 14). (<a href="https://github.com/wyouflf/xUtils3/issues/8">Android 2.3?</a>)</li>
<li>xUtils3变化较多所以建立了新的项目不在旧版(github.com/wyouflf/xUtils)上继续维护, 相对于旧版本:<ol>
<li>HTTP实现替换HttpClient为UrlConnection, 自动解析回调泛型, 更安全的断点续传策略.</li>
<li>支持标准的Cookie策略, 区分domain, path…</li>
<li>事件注解去除不常用的功能, 提高性能.</li>
<li>数据库api简化提高性能, 达到和greenDao一致的性能.</li>
<li>图片绑定支持gif(受系统兼容性影响, 部分gif文件只能静态显示), webp; 支持圆角, 圆形, 方形等裁剪, 支持自动旋转…</li>
</ol>
</li>
</ul>
<span id="more"></span>

<h4 id="使用Gradle构建时添加一下依赖即可"><a href="#使用Gradle构建时添加一下依赖即可" class="headerlink" title="使用Gradle构建时添加一下依赖即可:"></a>使用Gradle构建时添加一下依赖即可:</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">compile <span class="string">&#x27;org.xutils:xutils:3.3.4&#x27;</span></span><br></pre></td></tr></table></figure>
<h5 id="如果使用eclipse可以-点击这里下载aar文件-然后用zip解压-取出jar包和so文件"><a href="#如果使用eclipse可以-点击这里下载aar文件-然后用zip解压-取出jar包和so文件" class="headerlink" title="如果使用eclipse可以 点击这里下载aar文件, 然后用zip解压, 取出jar包和so文件."></a>如果使用eclipse可以 <a href="http://dl.bintray.com/wyouflf/maven/org/xutils/xutils/">点击这里下载aar文件</a>, 然后用zip解压, 取出jar包和so文件.</h5><h5 id="混淆配置参考示例项目sample的配置"><a href="#混淆配置参考示例项目sample的配置" class="headerlink" title="混淆配置参考示例项目sample的配置"></a>混淆配置参考示例项目sample的配置</h5><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题:"></a>常见问题:</h4><ol>
<li>更好的管理图片缓存: <a href="https://github.com/wyouflf/xUtils3/issues/149">https://github.com/wyouflf/xUtils3/issues/149</a></li>
<li>Cookie的使用: <a href="https://github.com/wyouflf/xUtils3/issues/125">https://github.com/wyouflf/xUtils3/issues/125</a></li>
<li>关于query参数? http请求可以通过 header, url, body(请求体)传参; query参数是url中问号(?)后面的参数.</li>
<li>关于body参数? body参数只有PUT, POST, PATCH, DELETE(老版本RFC2616文档没有明确指出它是否支持, 所以暂时支持)请求支持.</li>
</ol>
<h4 id="使用前配置"><a href="#使用前配置" class="headerlink" title="使用前配置"></a>使用前配置</h4><h5 id="需要的权限"><a href="#需要的权限" class="headerlink" title="需要的权限"></a>需要的权限</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在application的onCreate中初始化</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    x.Ext.init(<span class="keyword">this</span>);</span><br><span class="line">    x.Ext.setDebug(<span class="keyword">true</span>); <span class="comment">// 是否输出debug日志</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="使用-Event事件注解-ContentView-ViewInject等更多示例参考sample项目"><a href="#使用-Event事件注解-ContentView-ViewInject等更多示例参考sample项目" class="headerlink" title="使用@Event事件注解(@ContentView, @ViewInject等更多示例参考sample项目)"></a>使用@Event事件注解(@ContentView, @ViewInject等更多示例参考sample项目)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 方法必须私有限定,</span></span><br><span class="line"><span class="comment"> * 2. 方法参数形式必须和type对应的Listener接口一致.</span></span><br><span class="line"><span class="comment"> * 3. 注解参数value支持数组: value=&#123;id1, id2, id3&#125;</span></span><br><span class="line"><span class="comment"> * 4. 其它参数说明见&#123;<span class="doctag">@link</span> org.xutils.event.annotation.Event&#125;类的说明.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Event(value = R.id.btn_test_baidu1,</span></span><br><span class="line"><span class="meta">        type = View.OnClickListener.class/*可选参数, 默认是View.OnClickListener.class*/)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onTestBaidu1Click</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="访问网络-更多示例参考sample项目"><a href="#访问网络-更多示例参考sample项目" class="headerlink" title="访问网络(更多示例参考sample项目)"></a>访问网络(更多示例参考sample项目)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义实体参数类请参考:</span></span><br><span class="line"><span class="comment"> * 请求注解 &#123;<span class="doctag">@link</span> org.xutils.http.annotation.HttpRequest&#125;</span></span><br><span class="line"><span class="comment"> * 请求注解处理模板接口 &#123;<span class="doctag">@link</span> org.xutils.http.app.ParamsBuilder&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 需要自定义类型作为callback的泛型时, 参考:</span></span><br><span class="line"><span class="comment"> * 响应注解 &#123;<span class="doctag">@link</span> org.xutils.http.annotation.HttpResponse&#125;</span></span><br><span class="line"><span class="comment"> * 响应注解处理模板接口 &#123;<span class="doctag">@link</span> org.xutils.http.app.ResponseParser&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例: 查看 org.xutils.sample.http 包里的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaiduParams params = <span class="keyword">new</span> BaiduParams();</span><br><span class="line">params.wd = <span class="string">&quot;xUtils&quot;</span>;</span><br><span class="line"><span class="comment">// 有上传文件时使用multipart表单, 否则上传原始文件流.</span></span><br><span class="line"><span class="comment">// params.setMultipart(true);</span></span><br><span class="line"><span class="comment">// 上传文件方式 1</span></span><br><span class="line"><span class="comment">// params.uploadFile = new File(&quot;/sdcard/test.txt&quot;);</span></span><br><span class="line"><span class="comment">// 上传文件方式 2</span></span><br><span class="line"><span class="comment">// params.addBodyParameter(&quot;uploadFile&quot;, new File(&quot;/sdcard/test.txt&quot;));</span></span><br><span class="line">Callback.Cancelable cancelable</span><br><span class="line">       = x.http().get(params,</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 1. callback的泛型:</span></span><br><span class="line"><span class="comment">        * callback参数默认支持的泛型类型参见&#123;<span class="doctag">@link</span> org.xutils.http.loader.LoaderFactory&#125;,</span></span><br><span class="line"><span class="comment">        * 例如: 指定泛型为File则可实现文件下载, 使用params.setSaveFilePath(path)指定文件保存的全路径.</span></span><br><span class="line"><span class="comment">        * 默认支持断点续传(采用了文件锁和尾端校验续传文件的一致性).</span></span><br><span class="line"><span class="comment">        * 其他常用类型可以自己在LoaderFactory中注册,</span></span><br><span class="line"><span class="comment">        * 也可以使用&#123;<span class="doctag">@link</span> org.xutils.http.annotation.HttpResponse&#125;</span></span><br><span class="line"><span class="comment">        * 将注解HttpResponse加到自定义返回值类型上, 实现自定义ResponseParser接口来统一转换.</span></span><br><span class="line"><span class="comment">        * 如果返回值是json形式, 那么利用第三方的json工具将十分容易定义自己的ResponseParser.</span></span><br><span class="line"><span class="comment">        * 如示例代码&#123;<span class="doctag">@link</span> org.xutils.sample.http.BaiduResponse&#125;, 可直接使用BaiduResponse作为</span></span><br><span class="line"><span class="comment">        * callback的泛型.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 2. callback的组合:</span></span><br><span class="line"><span class="comment">        * 可以用基类或接口组合个种类的Callback, 见&#123;<span class="doctag">@link</span> org.xutils.common.Callback&#125;.</span></span><br><span class="line"><span class="comment">        * 例如:</span></span><br><span class="line"><span class="comment">        * a. 组合使用CacheCallback将使请求检测缓存或将结果存入缓存(仅GET请求生效).</span></span><br><span class="line"><span class="comment">        * b. 组合使用PrepareCallback的prepare方法将为callback提供一次后台执行耗时任务的机会,</span></span><br><span class="line"><span class="comment">        * 然后将结果给onCache或onSuccess.</span></span><br><span class="line"><span class="comment">        * c. 组合使用ProgressCallback将提供进度回调.</span></span><br><span class="line"><span class="comment">        * ...(可参考&#123;<span class="doctag">@link</span> org.xutils.image.ImageLoader&#125;</span></span><br><span class="line"><span class="comment">        * 或 示例代码中的 &#123;<span class="doctag">@link</span> org.xutils.sample.download.DownloadCallback&#125;)</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 3. 请求过程拦截或记录日志: 参考 &#123;<span class="doctag">@link</span> org.xutils.http.app.RequestTracker&#125;</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 4. 请求Header获取: 参考 &#123;<span class="doctag">@link</span> org.xutils.http.app.RequestInterceptListener&#125;</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 5. 其他(线程池, 超时, 重定向, 重试, 代理等): 参考 &#123;<span class="doctag">@link</span> org.xutils.http.RequestParams&#125;</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">       <span class="keyword">new</span> Callback.CommonCallback&lt;String&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line">               Toast.makeText(x.app(), result, Toast.LENGTH_LONG).show();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable ex, <span class="keyword">boolean</span> isOnCallback)</span> </span>&#123;</span><br><span class="line">               <span class="comment">//Toast.makeText(x.app(), ex.getMessage(), Toast.LENGTH_LONG).show();</span></span><br><span class="line">               <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> HttpException) &#123; <span class="comment">// 网络错误</span></span><br><span class="line">                   HttpException httpEx = (HttpException) ex;</span><br><span class="line">                   <span class="keyword">int</span> responseCode = httpEx.getCode();</span><br><span class="line">                   String responseMsg = httpEx.getMessage();</span><br><span class="line">                   String errorResult = httpEx.getResult();</span><br><span class="line">                   <span class="comment">// ...</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123; <span class="comment">// 其他错误</span></span><br><span class="line">                   <span class="comment">// ...</span></span><br><span class="line">               &#125;</span><br><span class="line">               Toast.makeText(x.app(), ex.getMessage(), Toast.LENGTH_LONG).show();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCancelled</span><span class="params">(CancelledException cex)</span> </span>&#123;</span><br><span class="line">               Toast.makeText(x.app(), <span class="string">&quot;cancelled&quot;</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// cancelable.cancel(); // 取消请求</span></span><br></pre></td></tr></table></figure>
<h4 id="如果你只需要一个简单的版本"><a href="#如果你只需要一个简单的版本" class="headerlink" title="如果你只需要一个简单的版本:"></a>如果你只需要一个简单的版本:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Event(value = R.id.btn_test_baidu2)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onTestBaidu2Click</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    RequestParams params = <span class="keyword">new</span> RequestParams(<span class="string">&quot;https://www.baidu.com/s&quot;</span>);</span><br><span class="line">    params.setSslSocketFactory(...); <span class="comment">// 设置ssl</span></span><br><span class="line">    params.addQueryStringParameter(<span class="string">&quot;wd&quot;</span>, <span class="string">&quot;xUtils&quot;</span>);</span><br><span class="line">    x.http().get(params, <span class="keyword">new</span> Callback.CommonCallback&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line">            Toast.makeText(x.app(), result, Toast.LENGTH_LONG).show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable ex, <span class="keyword">boolean</span> isOnCallback)</span> </span>&#123;</span><br><span class="line">            Toast.makeText(x.app(), ex.getMessage(), Toast.LENGTH_LONG).show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCancelled</span><span class="params">(CancelledException cex)</span> </span>&#123;</span><br><span class="line">            Toast.makeText(x.app(), <span class="string">&quot;cancelled&quot;</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line">#### 带有缓存的请求示例:</span><br><span class="line">```java</span><br><span class="line">BaiduParams params = <span class="keyword">new</span> BaiduParams();</span><br><span class="line">params.wd = <span class="string">&quot;xUtils&quot;</span>;</span><br><span class="line"><span class="comment">// 默认缓存存活时间, 单位:毫秒.(如果服务没有返回有效的max-age或Expires)</span></span><br><span class="line">params.setCacheMaxAge(<span class="number">1000</span> * <span class="number">60</span>);</span><br><span class="line">Callback.Cancelable cancelable</span><br><span class="line"><span class="comment">// 使用CacheCallback, xUtils将为该请求缓存数据.</span></span><br><span class="line">= x.http().get(params, <span class="keyword">new</span> Callback.CacheCallback&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasError = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> String result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCache</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 得到缓存数据, 缓存过期后不会进入这个方法.</span></span><br><span class="line"><span class="comment">// 如果服务端没有返回过期时间, 参考params.setCacheMaxAge(maxAge)方法.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// * 客户端会根据服务端返回的 header 中 max-age 或 expires 来确定本地缓存是否给 onCache 方法.</span></span><br><span class="line">        <span class="comment">//   如果服务端没有返回 max-age 或 expires, 那么缓存将一直保存, 除非这里自己定义了返回false的</span></span><br><span class="line">        <span class="comment">//   逻辑, 那么xUtils将请求新数据, 来覆盖它.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// * 如果信任该缓存返回 true, 将不再请求网络;</span></span><br><span class="line">        <span class="comment">//   返回 false 继续请求网络, 但会在请求头中加上ETag, Last-Modified等信息,</span></span><br><span class="line">        <span class="comment">//   如果服务端返回304, 则表示数据没有更新, 不继续加载数据.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// true: 信任缓存数据, 不在发起网络请求; false不信任缓存数据.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 注意: 如果服务返回304或 onCache 选择了信任缓存, 这里将不会被调用,</span></span><br><span class="line">        <span class="comment">// 但是 onFinished 总会被调用.</span></span><br><span class="line"><span class="keyword">this</span>.result = result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable ex, <span class="keyword">boolean</span> isOnCallback)</span> </span>&#123;</span><br><span class="line">hasError = <span class="keyword">true</span>;</span><br><span class="line">Toast.makeText(x.app(), ex.getMessage(), Toast.LENGTH_LONG).show();</span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> HttpException) &#123; <span class="comment">// 网络错误</span></span><br><span class="line">HttpException httpEx = (HttpException) ex;</span><br><span class="line"><span class="keyword">int</span> responseCode = httpEx.getCode();</span><br><span class="line">String responseMsg = httpEx.getMessage();</span><br><span class="line">String errorResult = httpEx.getResult();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 其他错误</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCancelled</span><span class="params">(CancelledException cex)</span> </span>&#123;</span><br><span class="line">Toast.makeText(x.app(), <span class="string">&quot;cancelled&quot;</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!hasError &amp;&amp; result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 成功获取数据</span></span><br><span class="line">Toast.makeText(x.app(), result, Toast.LENGTH_LONG).show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h3 id="使用数据库-更多示例参考sample项目"><a href="#使用数据库-更多示例参考sample项目" class="headerlink" title="使用数据库(更多示例参考sample项目)"></a>使用数据库(更多示例参考sample项目)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Parent test = db.selector(Parent.class).where(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;in&quot;</span>, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>&#125;).findFirst();</span><br><span class="line"><span class="keyword">long</span> count = db.selector(Parent.class).where(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;LIKE&quot;</span>, <span class="string">&quot;w%&quot;</span>).and(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="number">32</span>).count();</span><br><span class="line">List&lt;Parent&gt; testList = db.selector(Parent.class).where(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;between&quot;</span>, <span class="keyword">new</span> String[]&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;5&quot;</span>&#125;).findAll();</span><br></pre></td></tr></table></figure>


<h3 id="绑定图片-更多示例参考sample项目"><a href="#绑定图片-更多示例参考sample项目" class="headerlink" title="绑定图片(更多示例参考sample项目)"></a>绑定图片(更多示例参考sample项目)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.image().bind(imageView, url, imageOptions);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// assets file</span></span><br><span class="line">x.image().bind(imageView, <span class="string">&quot;assets://test.gif&quot;</span>, imageOptions);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// local file</span></span><br><span class="line">x.image().bind(imageView, <span class="keyword">new</span> File(<span class="string">&quot;/sdcard/test.gif&quot;</span>).toURI().toString(), imageOptions);</span><br><span class="line">x.image().bind(imageView, <span class="string">&quot;/sdcard/test.gif&quot;</span>, imageOptions);</span><br><span class="line">x.image().bind(imageView, <span class="string">&quot;file:///sdcard/test.gif&quot;</span>, imageOptions);</span><br><span class="line">x.image().bind(imageView, <span class="string">&quot;file:/sdcard/test.gif&quot;</span>, imageOptions);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x.image().bind(imageView, url, imageOptions, <span class="keyword">new</span> Callback.CommonCallback&lt;Drawable&gt;() &#123;...&#125;);</span><br><span class="line">x.image().loadDrawable(url, imageOptions, <span class="keyword">new</span> Callback.CommonCallback&lt;Drawable&gt;() &#123;...&#125;);</span><br><span class="line">x.image().loadFile(url, imageOptions, <span class="keyword">new</span> Callback.CommonCallback&lt;File&gt;() &#123;...&#125;);</span><br></pre></td></tr></table></figure>


<hr>
<h3 id="关于libwebpbackport"><a href="#关于libwebpbackport" class="headerlink" title="关于libwebpbackport"></a>关于libwebpbackport</h3><ul>
<li>部分4.x的机型对webp格式的支持仍然有问题, 需要借助webp.</li>
<li>webp来自:<a href="https://github.com/webmproject/libwebp">https://github.com/webmproject/libwebp</a></li>
<li>webpbackport来自:<a href="https://github.com/alexey-pelykh/webp-android-backport">https://github.com/alexey-pelykh/webp-android-backport</a></li>
<li>其中为webpbackport添加了nativeDecodeFile的实现, 并修复在Android 5.0以上系统存在bug:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// android_backport_webp.cpp</span></span><br><span class="line"><span class="comment">// 修改:</span></span><br><span class="line">jclassRef = jniEnv-&gt;<span class="built_in">FindClass</span>(...);</span><br><span class="line"><span class="comment">// 为:</span></span><br><span class="line">jclass temp = jniEnv-&gt;<span class="built_in">FindClass</span>(...);</span><br><span class="line">jclassRef = (jclass)jniEnv-&gt;<span class="built_in">NewGlobalRef</span>(temp);</span><br><span class="line">jniEnv-&gt;<span class="built_in">DeleteLocalRef</span>(temp);</span><br><span class="line"><span class="comment">// 其他jni代码修改见: http://my.oschina.net/u/1171837/blog/533153</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>第三方框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>第三方框架</tag>
        <tag>xUtils3</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 一共有多少种动画？准确告诉你！</title>
    <url>/2018/07/27/AndridAnimationTips/</url>
    <content><![CDATA[<p><img src="http://img.shedoor.net/github/androidanimationset/FnCS.gif" alt="Android 动画">  </p>
<p>Android 动画在开发中是不可或缺的功能，或者说是界面灵动的添加剂。那你是否总结过 Android 中总共为开发者提供了多少种方式的动画呢？今天就为大家总结归纳一下。</p>
<span id="more"></span>

<p><img src="http://img.shedoor.net/github/androidanimationset/JRYHqwhI.jpg" alt="报告老师，我知道">  </p>
<p>我话音未落，前排那位骚气不减当年、故事布满双眼的大胸弟就激动得高高举起了那只满是老茧的右手：“我知道，我知道！都有平移动画、缩放动画、旋转动画、渐变动画、还有……”  </p>
<p>看着这位兄弟回答时专注又冥思苦想的表情，我真不忍心伤害他那颗纯真的幼小心灵。于是我决定说一个谎：“这位同学，你说的太对了！你都知道的这么全面了还出来听课真是太辛苦了。这么热的天，不如回家吹吹空调、吃吃西瓜，把这次学习的机会让给更需要的人不挺好吗！”</p>
<p>看着那位兄弟一脸满足后远去的欢快背影，我终于可以放心的开始今天重点了。好了，上面内容纯属扯淡，转入正题。  </p>
<blockquote>
<p>本文章一部分教程图片来自网络，在这里先对这些图片的作者表示感谢。</p>
</blockquote>
<h2 id="动画种类"><a href="#动画种类" class="headerlink" title="动画种类"></a>动画种类</h2><p>Android 动画可以归纳为以下几种：  </p>
<ul>
<li><a href="#1">视图动画（View 动画）</a></li>
<li><a href="#2">帧动画（Frame 动画、Drawable 动画）</a></li>
<li><a href="#3">属性动画</a></li>
<li><a href="#4">触摸反馈动画（Ripple Effect）</a></li>
<li><a href="#5">揭露动画（Reveal Effect）</a></li>
<li><a href="#6">转场动画 &amp; 共享元素（Activity 切换动画）</a></li>
<li><a href="#7">视图状态动画（Animate View State Changes）</a></li>
<li><a href="#8">矢量图动画（Vector 动画）</a></li>
<li><a href="#9">约束布局实现的关键帧动画（ConstraintSet 动画）</a></li>
</ul>
<p>上面动画分类是个人通过每种动画种类概念的独立性来划分的，目前能想到的只有这么多，如果有所遗漏大家可以指点出来以供我后续完善。  </p>
<p>可能有很多人迅速的反应出，缺少了目前使用也相对较多的 <strong><a href="https://github.com/airbnb/lottie-android">airbnb/lottie-android</a></strong> 动画。不可置疑，Lottie 库目前在 Android 开发中尤其复杂动画效果上地位显著。但我们今天要是的 Android 原生上为我们提供的能使用的动画方式，Lottie 动画今天暂且搁置。同时对于 RecyclerView item 加载动画今天也暂且不提。我们且把这些动画归为其他，并不是把它们遗忘了。  </p>
<h2 id="详尽教程"><a href="#详尽教程" class="headerlink" title="详尽教程"></a>详尽教程</h2><p>对于上面列举的动画种类，可能大家对部分较常用的动画早已熟练应用，比如 View 动画、属性动画等。而对部分较少使用（比如 揭露动画）、或者常常使用却从未意识到它也属于动画的一种（比如 触摸反馈动画）知道的并不是那么全面。“那么今天就一一为大家详细讲解每种动画的概念”，那是不可能滴~~，就这么点篇幅，这么可能把每种动画都细说下来。  </p>
<p>要这些动画一一梳理清晰，那将是一项浩大的工作，而我已经为大家总结成了一个<strong>《详尽 Android 动画系列教程》</strong>，大家可以到<br><a href="https://github.com/OCNYang/Android-Animation-Set">https://github.com/OCNYang/Android-Animation-Set</a><br>进行查看，由于动画知识点涉及的太多而教程详细程度令人发指，大家可以收藏起来慢慢查看。另外总结的教程中每种动画都提供了动画示例，大家可以结合源码细细品味。（上面总结的系列教程，大多数都是借用前人总结的教程，选用的都是针对每种动画网上流传的最详细全面的教程，在梳理中对部分错误也进行了更正。）  </p>
<p>那今天的任务是什么呢？接下来主要通过粗略的介绍来讲解每种动画在开发中都适用在哪种场景。  </p>
<h2 id="1">视图动画（View 动画）</h2>  

<p>自从有了属性动画，View 动画的处境就非常凄凉，但有时我们需要的仅仅就是简易的动画效果，那我们使用 View 动画起来就十分便捷。  </p>
<p>View 动画的一个特点就是，他的动画仅仅是动的 View 的绘制地方，View 真正的位置并没有一起动画。</p>
<p>View 一般会用作直接作用页面中的 View 上，实现基本的动画效果：平移、旋转、缩放、透明度、或前几者的交集：  </p>
<p><img src="http://img.shedoor.net/github/androidanimationset/view_animation_base.png" alt="view_animation_base">  </p>
<p>除了这几种用法还有几种特殊的使用场景：  </p>
<ul>
<li><ol>
<li><strong>给 PopupWindow 设置显示隐藏的动画效果</strong>：</li>
</ol>
</li>
</ul>
<p>大家可以对比一下默认动画和设置后的动画效果对比：  </p>
<p><img src="http://img.shedoor.net/github/androidanimationset/view_animation_popup1.gif"  width="400px" alt="默认效果"/> <img src="http://img.shedoor.net/github/androidanimationset/view_animation_popup2.gif"  width="400px" alt="自定义效果"/>  </p>
<ul>
<li><ol start="2">
<li><strong>给 Activity 设置页面跳转、退出动画效果</strong>：</li>
</ol>
</li>
</ul>
<p>Activity 过场动画效果可以通过很多方式设置，而使用 View 动画实现的方式就是借助设置<br><code>overridePendingTransition(int enterAnim, int exitAnim)</code> 方法。跟在 startActivity() 或 finish() 后面，在页面转换时就显示上面方法设置的切换动画效果。  </p>
<p>效果对比：  </p>
<p><img src="http://img.shedoor.net/github/androidanimationset/view_animation_skip1.gif"  width="400px" alt="默认效果"/> <img src="http://img.shedoor.net/github/androidanimationset/view_animation_skip2.gif"  width="400px" alt="自定义效果"/>  </p>
<ul>
<li><ol start="3">
<li><strong>给 ViewGroup 设置子控件的进场动画效果</strong>：  </li>
</ol>
</li>
</ul>
<p>就是通过给 ViewGroup 控件设置一条 <code>android:layoutAnimation=&quot;@anim/anim_layout&quot;</code> 的属性。而 <code>anim_layout</code> 就是 ViewGroup 中子控件在第一次显示时的进场动画效果。  </p>
<p>效果如下：  </p>
<p><img src="http://img.shedoor.net/github/androidanimationset/view_animation_layoutanimation1.gif"  width="400px" alt="默认效果"/> <img src="http://img.shedoor.net/github/androidanimationset/view_animation_layoutanimation2.gif"  width="400px" alt="自定义效果"/>  </p>
<blockquote>
<p>LayoutAnimation 适用于所有的 ViewGroup ，自然也包含 ListView、RecyclerView 等控件。上面说过 LayoutAnimation 提供的是进场动画效果，所以只在 ViewGroup 第一次加载子 View 时显示一次，所以列表控件的 item 加载动画我们一般不使用它，我们会使用 列表 专门的 Item 加载动画， 比如 recyclerView.setItemAnimator() 等。</p>
</blockquote>
<h2 id="2">帧动画</h2>  

<p><img src="http://img.shedoor.net/github/androidanimationset/frame_animation_0.gif" alt="动画书">  </p>
<p>帧动画这个很好理解，其实就和看的动画片一样，每一帧代表一个画面动作，当快速逐帧显示时，速度到达人眼无法分辨每一帧时，就达到了动画的效果。</p>
<p>在使用中，先要准备好每一帧的素材图片：<br><img src="http://img.shedoor.net/github/androidanimationset/frame_animation_1.png" alt="帧动画素材图">  </p>
<p>然后播放出来就成了动画的效果：  </p>
<img src="https://user-gold-cdn.xitu.io/2018/7/27/164db18974b5778f?imageslim"  width="400px" alt="帧动画播放效果"/>  

<p>要说起帧动画的使用场景，在开发中使用的真是少之又少，一般会有两种：  </p>
<ul>
<li>设备的开关机动画</li>
<li> “复杂” 的动画效果，看似不可能完成的动画</li>
</ul>
<blockquote>
<p>之所以说开机动画是帧动画。是因为一般开机动画是通过 system/media/bootanimation.zip 这个压缩包，bootanimation 里面主要包含一个 desc.txt 以及 N 个文件夹。而文件夹里面放着的就是开机动画的图片资源。decs.txt 的作用就是指导系统如何去执行开机动画。<br>desc.txt 编写规范，例如开机动画需要用到 2 个文件夹，分别是 folder1 和 folder2，开机的时候，先把 folder1 里面的图片都播放一遍，然后再循环播放 folder2 里面的文件，直到进入系统。</p>
</blockquote>
<p>而在开发中，开机动画我们一般涉及不到的。而常常使用到的是，当我们需要一些比较复杂的图片动画显示效果时，其他动画又实现不了，这时我们可以考虑帧动画，但要注意防止 OOM。<br>其实真正用到帧动画时，更多的时候我们还不如使用 GIF 图片代替，现在几个主流图片加载框架都支持 GIF 图片，同时也能控制 GIF 的播放时机。</p>
<h2 id="3">属性动画</h2>  

<p>属性动画所提供的功能和 View 动画十分相似。但两者在实现原理上完全不同，而相对 View 动画来说，属性动画要强大的许多。这里我们先对两者做个对比：   </p>
<p><strong>View 动画/视图动画：</strong>  </p>
<ol>
<li>View 动画只能为 View 添加动画效果，且不能监听 View 相关属性的变化过程。</li>
<li>View 动画提供的动画能力较为单一，目前只支持帧动画、缩放动画、位移动画、旋转动画、透明度动画以及这些动画的集合动画。</li>
<li>View动画改变的是 View 的绘制效果，View 的真正位置和相关属性并不会改变，这也就造成了点击事件的触发区域是动画前的位置而不是动画后的位置的原因。</li>
</ol>
<p><strong>属性动画</strong>  </p>
<ol>
<li>属性动画作用对象不局限在 View 上，而是任何提供了 Getter 和 Setter 方法的对象的属性上。</li>
<li>属性动画没有直接改变 View 状态的能力，而是通过动态改变 View 相关属性的方式来改变 View 的显示效果。</li>
<li>属性动画使用更方便，可以用更简洁的代码实现相关的动画效果。</li>
<li>属性动画上手难度较高，对于 propertyName 需要自己去挖掘，或者自己通过 Wrapper 的方式去自定义 propertyName。</li>
<li>属性动画是 Android3.0 以上系统提供的能力，在 3.0 以下需导入 nineoldandroids 三方库解决兼容性问题。</li>
</ol>
<p>那属性动画的使用场景有哪些呢？  </p>
<ul>
<li>基本上视图动画作用在 View 上的动画效果，属性动画都可以实现；</li>
<li>在自定义 View 时，需要实现一些复杂的动画效果，或对 View 的一些特殊属性值进行动画变更时，视图动画无法实现时；</li>
<li>另外，属性动画你也可以用在非动画场景，比如，你在自定义 View 需要一个有一定规律（根据特定差值器变化）且可监听的数值变化器，这个时候借助属性动画是再合适不过了。</li>
</ul>
<p>属性动画是功能更强大、实现方式更优雅的动画解决方案，在为自定义 View 设置动效上有着非常强大的表现能力，可以实现 View 动画实现不了的更加炫酷的动画效果。详细的属性动画介绍可以去查看 《Android 动画详尽教程》系列。</p>
<p>这里盗一张前段时间有位网友实现的灵动的红鲤鱼效果，具体的实现也用到了不少属性动画的原理。  </p>
<p><img src="http://img.shedoor.net/github/androidanimationset/fish_animation.gif" alt="灵动的红鲤鱼">  </p>
<h2 id="4">触摸反馈动画（Ripple Effect）</h2>  

<p>所谓触摸反馈动画就是一种点击效果，作用在可点击的 View 上时，当有点击事件时会有涟漪般的反馈效果，使用在 按钮 上是再好不过了。  </p>
<p>Ripple 波纹效果有两种：  </p>
<pre><code>//有边界
?android:attr/selectableItemBackground
//无边界 （要求API21以上）
?android:attr/selectableItemBackgroundBorderless
</code></pre>
<p>效果分别为：</p>
<img src="http://img.shedoor.net/github/androidanimationset/ripple_effect1.gif"  width="400px" alt="有边界效果"/>  
<img src="http://img.shedoor.net/github/androidanimationset/ripple_effect2.gif.gif"  width="400px" alt="无边界效果"/>  

<p>使用也非常简单，只要将上面两种效果设置为控件的背景或者前景就好了，同时需要给控件设置点击事件、或把控件设置为可点击 <code>android:clickable=&quot;true&quot;</code>  </p>
<h2 id="5">揭露动画（Reveal Effect）</h2>  

<p>揭露动画在系统中很常见，就是类似波纹的效果， 从某一个点向四周展开或者从四周向某一点聚合起来。  </p>
<ul>
<li>可以用在 Activity 里面的 View 动画效果，用来揭露某个隐藏 View 的显示；*</li>
<li>也可以使用在 Activity 跳转过渡动画中。</li>
</ul>
<p>如下图使用时的一些效果：</p>
<p><img src="http://img.shedoor.net/github/androidanimationset/reveal_animation.gif?imageView2/2/w/600" alt="显示隐藏View揭露动画">  </p>
<p>如果加上些 View 动画效果，结合后成这样：  </p>
<p><img src="http://img.shedoor.net/github/androidanimationset/reveal_animation2.gif?imageView2/2/w/400" alt="与基础动画效果结合">  </p>
<p>同时它还可以和下面要说的转场动画结合成下面更酷炫的效果：  </p>
<p><img src="http://img.shedoor.net/github/androidanimationset/reveal_animation3.gif?imageView2/2/w/400" alt="与转场动画结合">  </p>
<p>上面动画效果是：先使用转场动画的共享元素转场，然后再使用揭露动画显示 View。</p>
<h2 id="6">转场动画 & 共享元素（Activity 切换动画）</h2>  

<p>转场动画听名字就知道它的使用场景了，转场、转场自然是用在场景转换的时候：</p>
<ul>
<li>转场效果我们一般用在 Activity 切换时的动画效果上；</li>
<li>共享元素一般我们使用在转换的前后两个页面有共同元素<sub>[注1]</sub>时；</li>
<li>同时也可以在 Activity 布局发生场景变化时，让其中的 View 产生相应的过渡动画。</li>
</ul>
<blockquote>
<p>共同元素：并非限制指作用的两个共享元素的状态、大小、显示位置完全相同。而是指两者在页面中要传递的内容相同，比如是从文章列表转到文章详情页面时的相同标题、主图等。如果共享元素的两者是不同的元素，一方面在显示时共享元素在将结束转场完成转换时会有显示的闪动，另一方面，如果两者表达的是不同的元素，用户也会感到很莫名。</p>
</blockquote>
<p>话不多说，放上效果图：  </p>
<img src="http://img.shedoor.net/github/androidanimationset/t1.gif"  width="400px" alt="转场效果"/>  
<img src="https://user-gold-cdn.xitu.io/2018/7/27/164db189cddc8de3?imageslim"  width="400px" alt="共享元素效果"/>

<h2 id="7">视图状态动画（Animate View State Changes）</h2>  

<p>所谓视图状态动画，就是 View 在状态改变时执行的动画效果。和之前我们通过 selector 选择器给 Button 设置不同状态下的背景效果是一样一样的。  </p>
<p>当然，它的使用场景也是特定的：  </p>
<ul>
<li>当 View 的状态改变时，希望此时显示的效果和静态效果有所区分，即显示效果也做出相应的改变，比如 Z 轴抬高，大小改变、或其他动画效果等。</li>
</ul>
<p>放上一个按钮被点击后设置的视图状态动画：  </p>
<img src="https://user-gold-cdn.xitu.io/2018/7/27/164db18a129d927b?imageslim"  width="400px" alt="视图状态动画"/>

<h2 id="8">矢量图动画（Vector 动画）</h2>  

<p>不知道大家现在在开发中，在图标显示上是不是还在切各种尺寸的 .png 图片适配。现在我可是一直在使用 svg 图标（在开发中是通过<a href="http://inloop.github.io/svg2android/">转换成 Vector </a>再使用，现在 AS 中导入，可以自动完成转换，转换不成功的再用上面网址转换），svg 图标的好处自不用说了。那矢量图动画有是怎么回事呢？  </p>
<p>VectorDrawable 一般是以 <vector> 为根标签定义的 XML 文件，<vector>、<group>、<clip-path>、<path> 元素都有各自可以播放动画的属性。具体怎么生成具有动画效果的图标，可以在<a href="https://github.com/OCNYang/Android-Animation-Set">系列教程</a>中查看。  </p>
<p>我们可以在以下场景使用：  </p>
<ul>
<li>具有动态变换效果的图标；</li>
<li>也可以用在需要特定动画效果的 VectorDrawable 图片上。</li>
</ul>
<img src="https://user-gold-cdn.xitu.io/2018/7/27/164db1c99e8a917a?imageslim"  width="400px" alt="动态图标"/>  
<img src="https://user-gold-cdn.xitu.io/2018/7/27/164db18a21e2f850?imageslim"  width="400px" alt="奔跑的图钉"/>


<h2 id="9">约束布局实现的关键帧动画（ConstraintSet 动画）</h2>  

<p>这个动画就比较新了，甚至连官方都没有提供完整的文档。这是通过 ConstraintLayout 实现的一种关键帧动画。</p>
<blockquote>
<p><strong>关键帧动画</strong>：(百度百科)任何动画要表现运动或变化，至少前后要给出两个不同的关键状态，而中间状态的变化和衔接电脑可以自动完成，在 Flash 中，表示关键状态的帧动画叫做关键帧动画<br>所谓关键帧动画，就是给需要动画效果的属性，准备一组与时间相关的值，这些值都是在动画序列中比较关键的帧中提取出来的，而其他时间帧中的值，可以用这些关键值，采用特定的插值方法计算得到，从而达到比较流畅的动画效果。  </p>
</blockquote>
<p>而 ConstraintSet 动画既然实现的是关键帧动画，那至少需要两个关键帧，而对于 ConstraintSet 来说每次需要的两个关键帧就是两种布局状态，而两种布局状态的转变过程 ConstraintSet 会生成一定的动画过渡。  </p>
<p>那使用场景根据约束动画的说明也比较明显了，就是同一个布局需要重新调整布局内部 View 位置时使用。  </p>
<p><img src="http://img.shedoor.net/github/androidanimationset/constraintset.gif" alt="约束布局动画">  </p>
<h2 id="更详细的动画介绍"><a href="#更详细的动画介绍" class="headerlink" title="更详细的动画介绍"></a>更详细的动画介绍</h2><p>这里介绍的只是对 Android 各个种类的动画进行了一个简单的介绍，如果你要更加详细更加全面的查看 Android 各个动画的系列教程，可以到本文章同系列文章教程进行查看：  </p>
<p><strong><a href="https://github.com/OCNYang/Android-Animation-Set">Android 动画详尽教程：https://github.com/OCNYang/Android-Animation-Set</a></strong>  </p>
<p>本篇教程终于完了，这时我又想起了文章开头那个大胸弟，我想他此刻肯定在家正洋洋得意的啃着大西瓜。不多说了，如此炎热的天气，我也要去啃个西瓜抚慰一下狂躁的心。</p>
]]></content>
      <categories>
        <category>Android教程系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android M 新的运行时权限开发者需要知道的一切</title>
    <url>/2016/08/16/AndroidMPermission/</url>
    <content><![CDATA[<p>android M 的名字官方刚发布不久，最终正式版即将来临！<br>android在不断发展，最近的更新 M 非常不同，一些主要的变化例如运行时权限将有颠覆性影响。惊讶的是android社区鲜有谈论这事儿，尽管这事很重要或许在不远的将来会引发很严重的问题。<br>这是今天我写这篇博客的原因。这里有一切关于android运行时权限你需要知道的，包括如何在代码中实现。现在亡羊补牢还不晚。</p>
<span id="more"></span>

<h2 id="新运行时权限"><a href="#新运行时权限" class="headerlink" title="新运行时权限"></a>新运行时权限</h2><p>android的权限系统一直是首要的安全概念，因为这些权限只在安装的时候被询问一次。一旦安装了，app可以在用户毫不知晓的情况下访问权限内的所有东西。<br>难怪一些坏蛋利用这个缺陷恶意收集用户数据用来做坏事了！<br>android小组也知道这事儿。7年了！权限系统终于被重新设计了。在android6.0棉花糖，app将不会在安装的时候授予权限。取而代之的是，app不得不在运行时一个一个询问用户授予权限。  </p>
<p><img src="http://img.shedoor.net/runtime_permissionruntimepermission.jpg">  </p>
<p>注意权限询问对话框不会自己弹出来。开发者不得不自己调用。如果开发者要调用的一些函数需要某权限而用户又拒绝授权的话，函数将抛出异常直接导致程序崩溃。  </p>
<p><img src="http://img.shedoor.net/runtime_permissionruntimepermissioncrash.jpg">  </p>
<p>另外，用户也可以随时在设置里取消已经授权的权限。  </p>
<p><img src="http://img.shedoor.net/runtime_permissionpermissionsrevoke.jpg">  </p>
<p>你或许已经感觉到背后生出一阵寒意。。。如果你是个android开发者，意味着要完全改变你的程序逻辑。你不能像以前那样直接调用方法了，你不得不为每个需要的地方检察权限，否则app就崩溃了！<br>是的。我不能哄你说这是简单的事儿。尽管这对用户来说是好事，但是对开发者来说就是噩梦。我们不得不修改编码不然不论短期还是长远来看都是潜在的问题。<br>这个新的运行时权限仅当我们设置targetSdkVersion to 23（这意味着你已经在23上测试通过了）才起作用，当然还要是M系统的手机。app在6.0之前的设备依然使用旧的权限系统。</p>
<h2 id="已经发布了的app会发生什么"><a href="#已经发布了的app会发生什么" class="headerlink" title="已经发布了的app会发生什么"></a>已经发布了的app会发生什么</h2><blockquote>
<p>新运行时权限可能已经让你开始恐慌了。<strong>“hey，伙计！我三年前发布的app可咋整呢。如果他被装到android 6.0上，我的app会崩溃吗？！？”</strong><br>莫慌张，放轻松。android小队又不傻，肯定考虑到了这情况。<strong>如果app的targetSdkVersion 低于 23，那将被认为app没有用23新权限测试过，那将被继续使用旧有规则：用户在安装的时候不得不接受所有权限，安装后app就有了那些权限咯！</strong>  </p>
</blockquote>
<p><img src="http://img.shedoor.net/mpermission22_1%20%281%29.jpg">  </p>
<p>然后app像以前一样奔跑！注意，此时用户依然可以取消已经同意的授权！用户取消授权时，android 6.0系统会警告，但这不妨碍用户取消授权。  </p>
<p><img src="http://img.shedoor.net/runtime_permissionmpermission22denyperm_1.jpg">  </p>
<p>问题又来了，这时候你的app崩溃吗？<br>善意的主把这事也告诉了android小组，当我们在targetSdkVersion 低于23的app调用一个需要权限的函数时，这个权限如果被用户取消授权了的话，不抛出异常。但是他将啥都不干，结果导致函数返回值是null或者0.  </p>
<p><img src="http://img.shedoor.net/runtime_permissiontargetsdkversion2223.jpg">  </p>
<p>别高兴的太早。尽管app不会调用这个函数时崩溃，返回值null或者0可能接下来依然导致崩溃。<br>好消息（至少目前看来）是这类取消权限的情况比较少，我相信很少用户这么搞。如果他们这么办了，后果自负咯。<br>但从长远看来，我相信还是会有大量用户会关闭一些权限。我们app不能在新设备完美运行这是不可接受的。<br>怎样让他完美运行呢，你最好修改代码支持最新的权限系统，而且我建议你立刻着手搞起！<br>代码没有成功改为支持最新运行时权限的app,不要设置targetSdkVersion 23 发布，否则你就有麻烦了。只有当你测试过了，再改为targetSdkVersion 23 。  </p>
<blockquote>
<p><strong>警告：现在你在android studio新建项目，targetSdkVersion 会自动设置为 23。如果你还没支持新运行时权限，我建议你首先把targetSdkVersion 降级到22</strong>  </p>
</blockquote>
<h2 id="PROTECTION-NORMAL类权限"><a href="#PROTECTION-NORMAL类权限" class="headerlink" title="PROTECTION_NORMAL类权限"></a>PROTECTION_NORMAL类权限</h2><p>当用户安装或更新应用时，系统将授予应用所请求的属于 PROTECTION_NORMAL 的所有权限（安装时授权的一类基本权限）。这类权限包括：  </p>
<pre><code>android.permission.ACCESS_LOCATION_EXTRA_COMMANDS
android.permission.ACCESS_NETWORK_STATE
android.permission.ACCESS_NOTIFICATION_POLICY
android.permission.ACCESS_WIFI_STATE
android.permission.ACCESS_WIMAX_STATE
android.permission.BLUETOOTH
android.permission.BLUETOOTH_ADMIN
android.permission.BROADCAST_STICKY
android.permission.CHANGE_NETWORK_STATE
android.permission.CHANGE_WIFI_MULTICAST_STATE
android.permission.CHANGE_WIFI_STATE
android.permission.CHANGE_WIMAX_STATE
android.permission.DISABLE_KEYGUARD
android.permission.EXPAND_STATUS_BAR
android.permission.FLASHLIGHT
android.permission.GET_ACCOUNTS
android.permission.GET_PACKAGE_SIZE
android.permission.INTERNET
android.permission.KILL_BACKGROUND_PROCESSES
android.permission.MODIFY_AUDIO_SETTINGS
android.permission.NFC
android.permission.READ_SYNC_SETTINGS
android.permission.READ_SYNC_STATS
android.permission.RECEIVE_BOOT_COMPLETED
android.permission.REORDER_TASKS
android.permission.REQUEST_INSTALL_PACKAGES
android.permission.SET_TIME_ZONE
android.permission.SET_WALLPAPER
android.permission.SET_WALLPAPER_HINTS
android.permission.SUBSCRIBED_FEEDS_READ
android.permission.TRANSMIT_IR
android.permission.USE_FINGERPRINT
android.permission.VIBRATE
android.permission.WAKE_LOCK
android.permission.WRITE_SYNC_SETTINGS
com.android.alarm.permission.SET_ALARM
com.android.launcher.permission.INSTALL_SHORTCUT
com.android.launcher.permission.UNINSTALL_SHORTCUT
</code></pre>
<p>只需要在AndroidManifest.xml中简单声明这些权限就好，安装时就授权。不需要每次使用时都检查权限，而且用户不能取消以上授权。  </p>
<h2 id="让你的app支持新运行时权限"><a href="#让你的app支持新运行时权限" class="headerlink" title="让你的app支持新运行时权限"></a>让你的app支持新运行时权限</h2><p>是时候让我们的app支持新权限模型了，从设置<strong>compileSdkVersion</strong> and <strong>targetSdkVersion</strong> 为 23开始吧.</p>
<pre><code>android &#123;
    compileSdkVersion 23
    ...

    defaultConfig &#123;
        ...
        targetSdkVersion 23
        ...
    &#125;
</code></pre>
<p>例子，我想用以下方法添加联系人。</p>
<pre><code>privatestaticfinal String TAG = &quot;Contacts&quot;;
privatevoid insertDummyContact() &#123;
// Two operations are needed to insert a new contact.
    ArrayList operations = new ArrayList(2);

// First, set up a new raw contact.
    ContentProviderOperation.Builder op =
            ContentProviderOperation.newInsert(ContactsContract.RawContacts.CONTENT_URI)
                    .withValue(ContactsContract.RawContacts.ACCOUNT_TYPE, null)
                    .withValue(ContactsContract.RawContacts.ACCOUNT_NAME, null);
    operations.add(op.build());

// Next, set the name for the contact.
    op = ContentProviderOperation.newInsert(ContactsContract.Data.CONTENT_URI)
            .withValueBackReference(ContactsContract.Data.RAW_CONTACT_ID, 0)
            .withValue(ContactsContract.Data.MIMETYPE,
                    ContactsContract.CommonDataKinds.StructuredName.CONTENT_ITEM_TYPE)
            .withValue(ContactsContract.CommonDataKinds.StructuredName.DISPLAY_NAME,
&quot;__DUMMY CONTACT from runtime permissions sample&quot;);
    operations.add(op.build());

// Apply the operations.
    ContentResolver resolver = getContentResolver();
try &#123;
        resolver.applyBatch(ContactsContract.AUTHORITY, operations);
    &#125; catch (RemoteException e) &#123;
        Log.d(TAG, &quot;Could not add a new contact: &quot; + e.getMessage());
    &#125; catch (OperationApplicationException e) &#123;
        Log.d(TAG, &quot;Could not add a new contact: &quot; + e.getMessage());
    &#125;
&#125;
</code></pre>
<p>上面代码需要WRITE_CONTACTS权限。如果不询问授权，app就崩了。<br>下一步像以前一样在AndroidManifest.xml添加声明权限。</p>
<pre><code>&lt;uses-permission  android:name=&quot;android.permission.WRITE_CONTACTS&quot;/&gt;
</code></pre>
<p>下一步，不得不再写个方法检查有没有权限。如果没有弹个对话框询问用户授权。然后你才可以下一步创建联系人。<br>权限被分组了，如下表：  </p>
<p><img src="http://img.shedoor.net/runtime_permissionpermgroup.png">  </p>
<p>同一组的任何一个权限被授权了，其他权限也自动被授权。例如，一旦WRITE_CONTACTS被授权了，app也有READ_CONTACTS和GET_ACCOUNTS权限了。<br>源码中被用来检查和请求权限的方法分别是Activity的checkSelfPermission和requestPermissions。这些方法在api23引入。</p>
<pre><code>finalprivateint REQUEST_CODE_ASK_PERMISSIONS = 123;

privatevoid insertDummyContactWrapper() &#123;
int hasWriteContactsPermission = checkSelfPermission(Manifest.permission.WRITE_CONTACTS);
if (hasWriteContactsPermission != PackageManager.PERMISSION_GRANTED) &#123;
        requestPermissions(new String[] &#123;Manifest.permission.WRITE_CONTACTS&#125;,
                REQUEST_CODE_ASK_PERMISSIONS);
return;
    &#125;
    insertDummyContact();
&#125;
</code></pre>
<p>如果已有权限，insertDummyContact()会执行。否则，requestPermissions被执行来弹出请求授权对话框，如下：</p>
<p>不论用户同意还是拒绝，activity的onRequestPermissionsResult会被回调来通知结果（通过第三个参数），grantResults,如下：</p>
<pre><code>@Override
publicvoid onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123;
switch (requestCode) &#123;
caseREQUEST_CODE_ASK_PERMISSIONS:
if (grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123;
// Permission Granted
                insertDummyContact();
            &#125; else &#123;
// Permission Denied
                Toast.makeText(MainActivity.this, &quot;WRITE_CONTACTS Denied&quot;, Toast.LENGTH_SHORT)
                        .show();
            &#125;
break;
        default:
super.onRequestPermissionsResult(requestCode, permissions, grantResults);
    &#125;
&#125;
</code></pre>
<p>这就是新权限模型工作过程。代码真复杂但是只能去习惯它。。。为了让app很好兼容新权限模型，你不得不用以上类似方法处理所有需要的情况。<br>如果你想捶墙，现在是时候了。。。  </p>
<h2 id="处理-“不再提醒”"><a href="#处理-“不再提醒”" class="headerlink" title="处理 “不再提醒”"></a>处理 “不再提醒”</h2><p>如果用户拒绝某授权。下一次弹框，用户会有一个“不再提醒”的选项的来防止app以后继续请求授权。  </p>
<p><img src="http://img.shedoor.net/runtime_permissionneveraskagain.jpg">  </p>
<p>如果这个选项在拒绝授权前被用户勾选了。下次为这个权限请求requestPermissions时，对话框就不弹出来了，结果就是，app啥都不干。<br>这将是很差的用户体验，用户做了操作却得不到响应。这种情况需要好好处理一下。在请求requestPermissions前，我们通过activity的shouldShowRequestPermissionRationale方法来检查是否需要弹出请求权限的提示对话框，代码如下：</p>
<pre><code>final private int REQUEST_CODE_ASK_PERMISSIONS = 123;

private void insertDummyContactWrapper() &#123;
int hasWriteContactsPermission = checkSelfPermission(Manifest.permission.WRITE_CONTACTS);
if (hasWriteContactsPermission != PackageManager.PERMISSION_GRANTED) &#123;
if (!shouldShowRequestPermissionRationale(Manifest.permission.WRITE_CONTACTS)) &#123;
                showMessageOKCancel(&quot;You need to allow access to Contacts&quot;,
new DialogInterface.OnClickListener() &#123;
@Override
publicvoid onClick(DialogInterface dialog, int which) &#123;
                                requestPermissions(new String[] &#123;Manifest.permission.WRITE_CONTACTS&#125;,
                                        REQUEST_CODE_ASK_PERMISSIONS);
                            &#125;
                        &#125;);
return;
            &#125;
        requestPermissions(new String[] &#123;Manifest.permission.WRITE_CONTACTS&#125;,
                REQUEST_CODE_ASK_PERMISSIONS);
return;
    &#125;
    insertDummyContact();
&#125;

private void showMessageOKCancel(String message, DialogInterface.OnClickListener okListener) &#123;
new AlertDialog.Builder(MainActivity.this)
            .setMessage(message)
            .setPositiveButton(&quot;OK&quot;, okListener)
            .setNegativeButton(&quot;Cancel&quot;, null)
            .create()
            .show();
&#125;
</code></pre>
<p>当一个权限第一次被请求和用户标记过不再提醒的时候,我们写的对话框被展示。<br>最后一种情况，onRequestPermissionsResult 会收到PERMISSION_DENIED ，系统询问对话框不展示。  </p>
<p><img src="http://img.shedoor.net/runtime_permissionrationaledialog.jpg">  </p>
<p>搞定！  </p>
<h2 id="一次请求多个权限"><a href="#一次请求多个权限" class="headerlink" title="一次请求多个权限"></a>一次请求多个权限</h2><p>当然了有时候需要好多权限，可以用上面方法一次请求多个权限。不要忘了为每个权限检查“不再提醒”的设置。<br>修改后的代码：</p>
<pre><code>final private int REQUEST_CODE_ASK_MULTIPLE_PERMISSIONS = 124;

private void insertDummyContactWrapper() &#123;
    List&lt;String&gt; permissionsNeeded = new ArrayList&lt;String&gt;();

    final List&lt;String&gt; permissionsList = new ArrayList&lt;String&gt;();
    if (!addPermission(permissionsList, Manifest.permission.ACCESS_FINE_LOCATION))
        permissionsNeeded.add(&quot;GPS&quot;);
    if (!addPermission(permissionsList, Manifest.permission.READ_CONTACTS))
        permissionsNeeded.add(&quot;Read Contacts&quot;);
    if (!addPermission(permissionsList, Manifest.permission.WRITE_CONTACTS))
        permissionsNeeded.add(&quot;Write Contacts&quot;);

    if (permissionsList.size() &gt; 0) &#123;
        if (permissionsNeeded.size() &gt; 0) &#123;
            // Need Rationale
            String message = &quot;You need to grant access to &quot; + permissionsNeeded.get(0);
            for (int i = 1; i &lt; permissionsNeeded.size(); i++)
                message = message + &quot;, &quot; + permissionsNeeded.get(i);
            showMessageOKCancel(message,
                    new DialogInterface.OnClickListener() &#123;
                        @Override
                        public void onClick(DialogInterface dialog, int which) &#123;
                            requestPermissions(permissionsList.toArray(new String[permissionsList.size()]),
                                    REQUEST_CODE_ASK_MULTIPLE_PERMISSIONS);
                        &#125;
                    &#125;);
            return;
        &#125;
        requestPermissions(permissionsList.toArray(new String[permissionsList.size()]),
                REQUEST_CODE_ASK_MULTIPLE_PERMISSIONS);
        return;
    &#125;

    insertDummyContact();
&#125;

private boolean addPermission(List&lt;String&gt; permissionsList, String permission) &#123;
    if (checkSelfPermission(permission) != PackageManager.PERMISSION_GRANTED) &#123;
        permissionsList.add(permission);
        // Check for Rationale Option
        if (!shouldShowRequestPermissionRationale(permission))
            return false;
    &#125;
    return true;
&#125;
</code></pre>
<p>如果所有权限被授权，依然回调onRequestPermissionsResult，我用hashmap让代码整洁便于阅读。</p>
<pre><code>@Override
publicvoid onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123;
switch (requestCode) &#123;
caseREQUEST_CODE_ASK_MULTIPLE_PERMISSIONS:
            &#123;
            Map perms = new HashMap();
// Initial
            perms.put(Manifest.permission.ACCESS_FINE_LOCATION, PackageManager.PERMISSION_GRANTED);
            perms.put(Manifest.permission.READ_CONTACTS, PackageManager.PERMISSION_GRANTED);
            perms.put(Manifest.permission.WRITE_CONTACTS, PackageManager.PERMISSION_GRANTED);
// Fill with results
for (int i = 0; i &lt; permissions.length; i++)
                perms.put(permissions[i], grantResults[i]);
// Check for ACCESS_FINE_LOCATION
if (perms.get(Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED
                    &amp;&amp; perms.get(Manifest.permission.READ_CONTACTS) == PackageManager.PERMISSION_GRANTED
                    &amp;&amp; perms.get(Manifest.permission.WRITE_CONTACTS) == PackageManager.PERMISSION_GRANTED) &#123;
// All Permissions Granted
                insertDummyContact();
            &#125; else &#123;
// Permission Denied
                Toast.makeText(MainActivity.this, &quot;Some Permission is Denied&quot;, Toast.LENGTH_SHORT)
                        .show();
            &#125;
            &#125;
break;
        default:
super.onRequestPermissionsResult(requestCode, permissions, grantResults);
    &#125;
&#125;
</code></pre>
<p>条件灵活的，你自己设置。有的情况，一个权限没有授权，就不可用；但是也有情况，能工作，但是表现的是有所限制的。对于这个我不做评价，你自己设计吧。  </p>
<h2 id="用兼容库使代码兼容旧版"><a href="#用兼容库使代码兼容旧版" class="headerlink" title="用兼容库使代码兼容旧版"></a>用兼容库使代码兼容旧版</h2><p>以上代码在android 6.0以上运行没问题，但是23 api之前就不行了，因为没有那些方法。<br>粗暴的方法是检查版本</p>
<pre><code>if (Build.VERSION.SDK_INT &gt;= 23) &#123;
// Marshmallow+
&#125; else &#123;
// Pre-Marshmallow
&#125;
</code></pre>
<p>但是太复杂，我建议用v4兼容库，已对这个做过兼容，用这个方法代替：  </p>
<ul>
<li>ContextCompat.checkSelfPermission()<br>  被授权函数返回PERMISSION_GRANTED，否则返回PERMISSION_DENIED ，在所有版本都是如此。</li>
<li>ActivityCompat.requestPermissions()<br>  这个方法在M之前版本调用，OnRequestPermissionsResultCallback 直接被调用，带着正确的 PERMISSION_GRANTED或者 PERMISSION_DENIED 。</li>
<li>ActivityCompat.shouldShowRequestPermissionRationale()<br>  在M之前版本调用，永远返回false。<br>  用v4包的这三方法，完美兼容所有版本！这个方法需要额外的参数，Context or Activity。别的就没啥特别的了。下面是代码：  <blockquote>
</blockquote>
</li>
</ul>
<pre><code>private void insertDummyContactWrapper()&#123;
int hasWriteContactsPermission = ContextCompat.checkSelfPermission(MainActivity.this,
            Manifest.permission.WRITE_CONTACTS);
if (hasWriteContactsPermission != PackageManager.PERMISSION_GRANTED) &#123;
if (!ActivityCompat.shouldShowRequestPermissionRationale(MainActivity.this,
                Manifest.permission.WRITE_CONTACTS)) &#123;
            showMessageOKCancel(&quot;You need to allow access to Contacts&quot;,
new DialogInterface.OnClickListener() &#123;
@Override
publicvoidonClick(DialogInterface dialog, int which)&#123;
                            ActivityCompat.requestPermissions(MainActivity.this,
new String[] &#123;Manifest.permission.WRITE_CONTACTS&#125;,
                                    REQUEST_CODE_ASK_PERMISSIONS);
                        &#125;
                    &#125;);
return;
        &#125;
        ActivityCompat.requestPermissions(MainActivity.this,
new String[] &#123;Manifest.permission.WRITE_CONTACTS&#125;,
                REQUEST_CODE_ASK_PERMISSIONS);
return;
    &#125;
    insertDummyContact();
&#125;  
</code></pre>
<p>后两个方法，我们也可以在Fragment中使用，用v13兼容包：FragmentCompat.requestPermissions() and FragmentCompat.shouldShowRequestPermissionRationale()和activity效果一样。  </p>
<h2 id="第三方库简化代码"><a href="#第三方库简化代码" class="headerlink" title="第三方库简化代码"></a>第三方库简化代码</h2><p>以上代码真尼玛复杂。为解决这事，有许多第三方库已经问世了，真66溜真有速度。我试了很多最终找到了个满意的<a href="https://github.com/hotchemi/PermissionsDispatcher">hotchemi’s PermissionsDispatcher</a>。<br>他和我上面做的一样，只是简化了代码。灵活易扩展，试一下吧。如果不满足你可以找些其他的。  </p>
<h2 id="如果我的app还开着呢，权限被撤销了，会发生生么"><a href="#如果我的app还开着呢，权限被撤销了，会发生生么" class="headerlink" title="如果我的app还开着呢，权限被撤销了，会发生生么"></a>如果我的app还开着呢，权限被撤销了，会发生生么</h2><p>权限随时可以被撤销。  </p>
<p><img src="http://img.shedoor.net/runtime_permissionpermissionsrevoke%20%281%29.jpg">  </p>
<p>当app开着的时候被撤消了会发生什么呢？我试过了发现这时app会突然终止 terminated。app中的一切都被简单粗暴的停止了，因为terminated！对我来说这可以理解，因为系统如果允许它继续运行（没有某权限），这会召唤弗雷迪到我的噩梦里。或许更糟…  </p>
<h2 id="结论建议"><a href="#结论建议" class="headerlink" title="结论建议"></a>结论建议</h2><p>我相信你对新权限模型已经有了清晰的认识。我相信你也意识到了问题的严峻。<br>但是你没得选择。新运行时权限已经在棉花糖中被使用了。我们没有退路。我们现在唯一能做的就是保证app适配新权限模型.<br>欣慰的是只有少数权限需要运行时权限模型。大多数常用的权限，例如，网络访问，属于Normal Permission 在安装时自动会授权，当然你要声明，以后无需检查。因此，只有少部分代码你需要修改。<br>两个建议：  </p>
<ol>
<li>严肃对待新权限模型</li>
<li>如果你代码没支持新权限，不要设置targetSdkVersion 23 。尤其是当你在Studio新建工程时，不要忘了修改！  </li>
</ol>
<p>说一下代码修改。这是大事，如果代码结构被设计的不够好，你需要一些很蛋疼的重构。每个app都要被修正。如上所说，我们没的选择。。。<br>列出所有你需要请求的权限所有情形，如果A被授权，B被拒绝，会发生什么。blah，blah。<br>祝重构顺利。把它列为你需要做的大事，从现在就开始着手做，以保证M正式发布的时候没有问题。<br>希望本文对你有用，快乐编码！  </p>
<blockquote>
<p>译文来自 <em><a href="http://inthecheesefactory.com/blog/things-you-need-to-know-about-android-m-permission-developer-edition/en">http://inthecheesefactory.com/blog/things-you-need-to-know-about-android-m-permission-developer-edition/en</a></em><br>翻译摘录来自 <em><a href="http://jijiaxin89.com/2015/08/30/Android-s-Runtime-Permission/">http://jijiaxin89.com/2015/08/30/Android-s-Runtime-Permission/</a></em>  </p>
</blockquote>
]]></content>
      <categories>
        <category>Android教程系列</category>
      </categories>
      <tags>
        <tag>Android6.0权限</tag>
        <tag>Android教程系列</tag>
        <tag>AndroidM权限</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio详细安装流程和配置、主题</title>
    <url>/2016/09/13/AndroidStudioSet/</url>
    <content><![CDATA[<p>在这里先给大家一张我的Android studio的外观截图：</p>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio_ocnyang.png"></p>
<span id="more"></span>

<h2 id="1、Android-Studio安装"><a href="#1、Android-Studio安装" class="headerlink" title="1、Android Studio安装"></a>1、Android Studio安装</h2><p><strong>Android studio下载地址：</strong>  </p>
<ul>
<li>官方下载地址（版本最新/需爬墙）：<a href="https://developer.android.com/studio/index.html">https://developer.android.com/studio/index.html</a>  </li>
<li>Android Studio 中文社区：<a href="http://www.android-studio.org/">http://www.android-studio.org/</a>  </li>
<li>网盘地址下载：<a href="http://pan.baidu.com/s/1hrRax1q">点击进入（密码:4051）</a></li>
</ul>
<p><strong>安装流程</strong><br>这个比较基础简单，在这给一个地址，大家可以参考一下<a href="http://www.runoob.com/android/android-studio-install.html">Android studio安装流程</a>  </p>
<blockquote>
<p>Android studio是可以同时安装两个版本的，你可以选择安装一个自己习惯的稳定版本，同时再安装一个最新的Beta版本。<br>注意点：在安装第二个版本时，在安装流程选项里的<strong>“uninstall the privious version”</strong>的选项要取消勾选，如下图(取消勾选代表不覆盖原有安装版本)。  </p>
</blockquote>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio1.png"></p>
<h2 id="2、安装常见问题及其解决方案"><a href="#2、安装常见问题及其解决方案" class="headerlink" title="2、安装常见问题及其解决方案"></a>2、安装常见问题及其解决方案</h2><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>在安装的时候最好是按照它原来的路径安装，不要修改路径。修改了路径后可能会出现了一些问题，没有解决。所以提醒大家，在安装的时候最好不要修改安装路径哦~<br>当然，如果你对安装流程已经很熟悉了的话，可以按照自己的方式设置路径等配置  </p>
<h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><pre><code>&#39;tools.jar&#39; seems to be not in Android Studio classpath.
Please ensure JAVA_HOME points to JDK rather than JRE.  
</code></pre>
<p>在打开的过程中报出以上错误，tools包没有找到，解决方法是在设置环境变量中的JAVA HOME时需要注意，在最后需要以\结尾。如图：  </p>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio2.png" alt="2">  </p>
<h3 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h3><p>一直停留在fetching Android sdk compoment information界面  </p>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio3.png" alt="3"></p>
<p>出现该界面是一直在获得android sdk的信息。<br>解决方法：  </p>
<ol>
<li>找到安装的Android Studio目录下的bin目录。找到idea.properties文件，用文本编辑器打开。  </li>
<li>在idea.properties文件末尾添加一行： disable.android.first.run=true ，然后保存文件。  </li>
<li>关闭Android Studio后重新启动，便可进入界面。  </li>
</ol>
<h3 id="问题四"><a href="#问题四" class="headerlink" title="问题四"></a>问题四</h3><pre><code>Failed to fetch URL http://dl-ssl.google.com/android/repository/repository.xml, reason: Connection timed out: connect  
</code></pre>
<p>连接谷歌网络超时<br>解决方法：<br>打开SDK目录 安装时默认地址为C:\Users\Administrator\AppData\Local\Android\sdk 。打开SDKManager，选择Tools下的Options，将如图所示选项勾上。也就是others中第一个选项  </p>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio4.jpg" alt="4"></p>
<p>然后打开C:\WINDOWS\system32\drivers\etc中的hosts文件，在最后一行添加如下内容：  </p>
<pre><code>203.208.46.146 www.google.com
74.125.113.121 developer.android.com
203.208.46.146 dl.google.com
203.208.46.146 dl-ssl.google.com  
</code></pre>
<h2 id="3、Android-studio配置"><a href="#3、Android-studio配置" class="headerlink" title="3、Android studio配置"></a>3、Android studio配置</h2><p>Android Studio 原有配置，比如编辑区字体大小、Log输出的颜色真的不敢恭维。我们敲代码是要有一个舒适的视觉环境的。<br>其实AS提供了一个非常方便的功能帮助我们导入或者导出设置。因此我们在安装一个新的 Android Studio 的时候通常会导入一个之前的设置。这点上也表现出AS的方便之处。  </p>
<p>下面是当我在配置我的 Android Studio 的时候，一些配置技巧或许对你有一定的帮助。  </p>
<h3 id="显示行号"><a href="#显示行号" class="headerlink" title="显示行号"></a>显示行号</h3><p>当我首次启动我的 Android Studio 的时候，我想做的第一件事就是希望能看到文件中的行号。  </p>
<p>配置方法  </p>
<ol>
<li>File | Settings 打开设置</li>
<li>选择 Editor | General | Appearance</li>
<li>勾选 Show line numbers</li>
</ol>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio5.png" alt="5">  </p>
<blockquote>
<p>ps:在编辑区域最左侧右键选中 Show line numbers 也可以让当前打开的文件显示行号，不过这是一个临时设置，当前文件关闭后便失效。  </p>
</blockquote>
<h3 id="驼峰选择"><a href="#驼峰选择" class="headerlink" title="驼峰选择"></a>驼峰选择</h3><p>Android 开发中，我们通常会使用驼峰命名法对变量进行命名，但是当我们通过 Ctrl + Left/ Right 键改变字符选择区域的时候 Android Studio 默认不支持‘驼峰’单词的选择。  </p>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio6.gif" alt="6">  </p>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio7.gif" alt="7">  </p>
<p>配置方法  </p>
<ol>
<li>File | Settings 打开设置</li>
<li>选择 Editor | General | Smart Keys</li>
<li>选中 Use “CamelHumps” words</li>
</ol>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio8.png" alt="8">  </p>
<p>注意:如果你仍然希望当鼠标在单词上双击之后选中整个单词，需要作如下设置：  </p>
<ol>
<li>File | Settings 打开设置</li>
<li>选择 Editor | General</li>
<li>取消选中 ‘Honor Camel Humps words settings when selecting on double click’  </li>
</ol>
<h3 id="命名前缀"><a href="#命名前缀" class="headerlink" title="命名前缀"></a>命名前缀</h3><p>我们通常会遵循 Android 官方关于编码风格的指导来进行字段命名。在 Android 源码中我们可以看到通常成员变量都是以‘m’开始。其实Android Studio 可以自动在帮我们生成字段名称的时候加上自定义的前缀，如:  </p>
<ul>
<li>非共有，非静态的成员变量以’m’开始</li>
<li>静态成员变量以’s’开始  </li>
</ul>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio9.gif" alt="9">  </p>
<p>配置方法  </p>
<ol>
<li>File | Settings 打开设置</li>
<li>选择 Editor | Code Style | Java</li>
<li>选择 Code Generation 标签</li>
<li>给普通 Field 添加一个’m’前缀，给 Static filed 添加一个’s’前缀  </li>
</ol>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio10.png" alt="10">  </p>
<h3 id="快速导包"><a href="#快速导包" class="headerlink" title="快速导包"></a>快速导包</h3><p>在 Android Studio 中，我们可以通过 Alt + Enter 和 Control + Alt + O 进行导包和清除无用导包，但我们都希望这些事情应当快速自动完成。  </p>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio11.gif" alt="11">  </p>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio12.gif" alt="12">  </p>
<p>配置方法  </p>
<ol>
<li>File | Settings 打开设置</li>
<li>选择 Editor | General | Auto Import</li>
<li>勾选 Optimize imports on the fly</li>
<li>勾选 Add unambiguous imports on the fly</li>
</ol>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio13.png" alt="13">  </p>
<blockquote>
<p>PS:这里我补充一下，关于这个配置，个别朋友在问，如果我的项目中两个甚至多个包下都有一个类叫 ImageLoader ，自动导入的结果有没有可能不是我想要的包下的？兄弟你放心，你去查一下 unambiguous 的意思就知道了。针对包名不确定的情况， Android Studio 会选择 No can no import, you can you up ，不会自作聪明，而是会让你自己手动导入。所以，请放心使用。  </p>
</blockquote>
<h3 id="Log-颜色"><a href="#Log-颜色" class="headerlink" title="Log 颜色"></a>Log 颜色</h3><p>Darcula 主题中 Logcat 的默认配色只有红白两种颜色，不太便于我们区分 Log 的类型。  </p>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio14.png" alt="14">  </p>
<p>我建议大家采用之前 Android Holo 主题那种鲜明的配色  </p>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio15.png" alt="15">  </p>
<p>配置方法  </p>
<ol>
<li>File | Settings 打开设置</li>
<li>选择 Editor | Color &amp; Fonts | Android Logcat</li>
<li>点击 Click on Save As…按钮创建一个新的配色 Scheme</li>
<li>按照下面的表格修改对应的颜色(修改之前需要取消勾选 Use inherited attributes)  </li>
</ol>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio16.png" alt="16"></p>
<h2 id="4、配置补充"><a href="#4、配置补充" class="headerlink" title="4、配置补充"></a>4、配置补充</h2><h3 id="主题修改"><a href="#主题修改" class="headerlink" title="主题修改"></a>主题修改</h3><p>可能大家会觉得软件的界面不太好看，我们可以换一下主题。选择菜单栏“File–settings–apperance–theme”，主题选择Darcula：  </p>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio17.jpg" alt="17"></p>
<h3 id="导入第三方主题-amp-代码配色"><a href="#导入第三方主题-amp-代码配色" class="headerlink" title="导入第三方主题 &amp; 代码配色"></a>导入第三方主题 &amp; 代码配色</h3><p>Android Studio 中默认主题的代码配色个人感觉已经很和谐，但这个东西仁者见仁。<br>这里呢我们就不教大家一个一个配置对应颜色了，这里教大家如何导入第三方主题。<br>系统提供的两种主题可能都不太好看，我们可以进入下面等等网站来获取第三方主题，比如说Sublime主题就是我个人喜爱的：  </p>
<blockquote>
<p>第三方主题常用下载地址：<br><a href="http://www.androidstudiothemes.com/">Android Studio Themes</a><br><a href="http://color-themes.com/?view=index">Color Themes</a></p>
</blockquote>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio18.png" alt="18"><br><img src="http://img.shedoor.net/androidstudio/Androidstudio19.png" alt="19"></p>
<p>上图中，下载下来之后，是一个jar包。那怎么导入到Android Studio呢？<br>别着急，回到Android Studio，选择菜单栏“ File-Import Settings”，将下载好的jar包导入即可。  </p>
<h3 id="代码字体修改"><a href="#代码字体修改" class="headerlink" title="代码字体修改"></a>代码字体修改</h3><p>代码编辑区字体修改：选择菜单栏“File–settings–Editor–Colors&amp;Fonts–Font”：</p>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio20.png" alt="20"></p>
<p>同样也可以修改控制台的字体：  </p>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio21.png" alt="21"></p>
<p>修改完之后发现AS的一些默认字体如侧边栏的工程目录的字体并没有发生变化，如果想改的话，那还是改一下吧（我个人一般是不改的），修改AS的默认字体：  </p>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio22.png" alt="22"></p>
<blockquote>
<p>对于什么字体是编程的最佳字体，这个真的要靠个人的见解了。如果你没有字体的观念，这里我推荐：Windows 下 Consolas 可能是你最好的选择。  </p>
<p>附：知乎上关于字体的一篇帖子<br><a href="https://www.zhihu.com/question/38958773">Android Studio有哪些值得推荐的主题背景</a></p>
</blockquote>
<h3 id="附：我的风骚主题"><a href="#附：我的风骚主题" class="headerlink" title="附：我的风骚主题"></a>附：我的风骚主题</h3><p>在网上偶尔看到有网友推荐这个主题，试用了大爱。目前我用的这个，其它没发现好看的。  </p>
<p><img src="http://img.shedoor.net/androidstudio/www_ocnyang_com.png" alt="截图"></p>
<blockquote>
<p>注意界面的图标，颜色。是不是看上去很有爱啊？</p>
</blockquote>
<p><strong>设置方法：</strong></p>
<ol>
<li>打开 Settings/Preferences对话框（OSX / Unix系统⌘+,，Windows系统：Ctrl+Alt+S）  </li>
<li>在左侧窗格中，选择Plugins。  </li>
<li>点击 Browse repositories…,搜索 Material Theme UI  </li>
<li>点击安装插件，并确认你的意图，以下载并安装插件。  </li>
<li>点击OK在设置对话框，然后重新启动以使更改生效。  </li>
</ol>
<p><img src="http://img.shedoor.net/androidstudio/AndroidstudioA.png" alt="A"></p>
<p>通过重启发现主题变得好看的不要不要的，不要激动，接下来接着下载插件并修改代码和Logcat输出颜色（步骤同上）  </p>
<ol>
<li>打开File &gt;&gt; Settings &gt;&gt; Plugins,点击Browse Repositories…  </li>
<li>搜索ChroMATERIAL并安装上，重启。  </li>
<li>接下来通过设置应用上这个插件。打开File &gt;&gt; Settings &gt;&gt; Editor &gt;&gt; Colors &amp; Fonts &gt;&gt; Scheme  </li>
<li>选中ChroMATERIAL并确定。</li>
<li>接着设置Logcat。打开Preferences → Editor → Colors &amp; Fonts → Android Logcat  </li>
<li>确保ChroMATERIAL在下拉列表中选中，然后单击另存为…，选择一个名称前，ChroMATERIAL + HOLO并用确认OK。</li>
<li>在中心点击每个项目从列表并改变它们的前景根据下表推荐的颜色到对应的选项上，<br>单击应用 / 确定。  </li>
</ol>
<p><img src="http://img.shedoor.net/androidstudio/AndroidstudioB.png" alt="B"></p>
<h2 id="5、活动模板"><a href="#5、活动模板" class="headerlink" title="5、活动模板"></a>5、活动模板</h2><p>Android Studio 中默认提供了很多非常方便的活动模板(Live Templates)，例如，我们输入sout 后按 enter 键， Android Studio 会自动帮我们写入 System.out.println();  </p>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio23.gif" alt="图片23">  </p>
<p>其实 sout 就是 AS 自带的一个活动模板。  </p>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio26.jpg" alt="图片26"></p>
<p>由此可以看出，活动模板就是我们常用代码的一个缩写。开发中有很多代码都会重复出现，因此自定义合适的活动模板能很大程度上避免我们很多重复的体力劳动。那么问题来了，如何自定义？</p>
<p><strong>这里我们实现一个AS不自带的方法，就是我们经常使用的switch用法作为例子。</strong></p>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio24.png" alt="24"></p>
<p>按照图上的流程走即可,我说一下switch()里的参数  </p>
<ol>
<li>在Custom的自定义组下，创建一个swi的自定义活动模板</li>
<li>提示关键字设置为 swi ，描述为 switch的选择语句</li>
<li>然后设置四个参数CONTAINER, FIRST,SECOND,END,分别代表着参数，第一个选择，第二个选择，最后一个光标坐落点。</li>
<li>然后点击右边的Edit variabldes，然后进行对四个参数的作用进行赋值，第一个参数我们选择suggestFirstVariableName(“Object”)表示系统推荐的，第二、三是为了我们方便写入我们需要的值，换行只需要回车就可以切换，避免鼠标操作，纯键盘手打，第四个参数就是我们输入的最后。  </li>
</ol>
<p>输入方式如下图所示：  </p>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio25.png" alt="25"></p>
<p><strong>这里我们再以Handler为例。下面是在 Activity 中一个合格的 Handler 该有的样子：</strong></p>
<pre><code>private static class MyHandler extends Handler &#123;
        private WeakReference activityWeakReference;

        public MyHandler(MainActivity activity) &#123;
            activityWeakReference = new WeakReference(activity);
        &#125;

        @Override
        public void handleMessage(Message msg) &#123;
            MainActivity activity = activityWeakReference.get();
            if (activity != null) &#123;

            &#125;
        &#125;
    &#125;  
</code></pre>
<p>至于原因我就不再重复了，网上有太多的文章有讲过。现在如果我只希望输入一个‘psh’就自动出现上面这段代码的话，我应该这么做：  </p>
<p>配置方法  </p>
<ul>
<li>File | Settings 打开设置</li>
<li>选择 Editor | Code Style | Live Templates</li>
<li>点击最右侧的加号并选择 Template Group</li>
<li>在弹出的对话框中输入一个活动模板分组的名称，如 custom</li>
<li>在左侧选中上一步中创建的 custom 分组，点击右边的加号</li>
<li>选择 Live Template ，在 Abbreviation 中对输入 psh</li>
<li>在 Description 中输入这个活动模板的描述</li>
<li>在 Template text 中输入以下代码  </li>
</ul>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio27.jpeg" alt="图片27">  </p>
<ul>
<li>点击下方的 Define 按钮，选中 java 表示这个模板用于java代码</li>
<li>点击右侧的 Edit variables</li>
<li>选择 Expression 下拉框中的 className 并勾选 Skip if…  </li>
</ul>
<blockquote>
<p>这个操作的作用是，AS会自动将我们在上一步中用’$’符包裹的 className自动替换为当前类不含包名的类名  </p>
</blockquote>
<ul>
<li>点击 Apply 和 Ok 让设置生效。  </li>
</ul>
<p>至此，一个我们自定义的 custom 模板组中的 psh 活动模板就定义完成了。下面我们来验证一下，见证奇迹的时候到了：  </p>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio28.gif" alt="图片28">  </p>
<h2 id="6、其他配置"><a href="#6、其他配置" class="headerlink" title="6、其他配置"></a>6、其他配置</h2><h3 id="类的头文件声明，标上自己的专注权"><a href="#类的头文件声明，标上自己的专注权" class="headerlink" title="类的头文件声明，标上自己的专注权"></a>类的头文件声明，标上自己的专注权</h3><p>类的头文件声明，因为我们写的代码，在开发程序的时候，我们一般都会给文件自动添加上一些关于文件的注释信息，比如开发者的名字，开发的时间，开发者的联系方式等等，效果图如下。</p>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio29.png" alt="29"></p>
<p><strong>设置步骤</strong></p>
<ol>
<li>点击菜单栏的“File“-&gt;“Settings”，打开Settings窗口</li>
<li>点击“IDE Settings”下面的“File and Code Templates”，然后选中Templates里面的Class</li>
<li>然后选中Includes tab下面的File Header。</li>
<li>在最右边的输入框中就可以输入我们想要设置的注释模板了。比如我们输入：  </li>
</ol>
<pre><code>    /**  
     * Created by OCN.Yang on $&#123;DATE&#125;. $&#123;HOUR&#125;:$&#123;MINUTE&#125;  
     * mail:yangocn@163.com  
     */  
</code></pre>
<p>然后点击ok便大功告成了。  </p>
<h3 id="关闭更新"><a href="#关闭更新" class="headerlink" title="关闭更新"></a>关闭更新</h3><p><img src="http://img.shedoor.net/androidstudio/Androidstudio30.png" alt="30"></p>
<h3 id="禁止自动打开上次的工程"><a href="#禁止自动打开上次的工程" class="headerlink" title="禁止自动打开上次的工程"></a>禁止自动打开上次的工程</h3><p>我喜欢自己选打开哪个工程，果断禁用，设置如下：</p>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio31.png" alt="31"></p>
<h3 id="禁止代码折叠"><a href="#禁止代码折叠" class="headerlink" title="禁止代码折叠"></a>禁止代码折叠</h3><p>Intellij IDEA默认有很多地方的代码都会自动折叠，不过我看不惯，所以取消了，设置如下：</p>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio32.png" alt="32"></p>
<h3 id="修改注释位置，禁用“语句堆一行”："><a href="#修改注释位置，禁用“语句堆一行”：" class="headerlink" title="修改注释位置，禁用“语句堆一行”："></a>修改注释位置，禁用“语句堆一行”：</h3><p><img src="http://img.shedoor.net/androidstudio/Androidstudio33.png" alt="33"></p>
<p>Comment at frist column：启用的话，注释符号就会在行首，否则就按照缩进来注释。我取消掉了。<br>Control statement in one line：格式化代码的时候，会把些很短的语句合并成一行。我觉得这样影响代码可读性，故取消。  </p>
<h3 id="修改文件编码"><a href="#修改文件编码" class="headerlink" title="修改文件编码"></a>修改文件编码</h3><p><img src="http://img.shedoor.net/androidstudio/Androidstudio34.png" alt="34"></p>
<h2 id="7、最后的定格：保存自己的配置"><a href="#7、最后的定格：保存自己的配置" class="headerlink" title="7、最后的定格：保存自己的配置"></a>7、最后的定格：保存自己的配置</h2><p>安装好Android studio，辛辛苦苦设置的属于自己的独特配置，当面临重新安装新版本或是换工作硬件时，又要头大的重新来过？不要慌，不要怕，作为程序员，面对这种场景我们更不会重新造轮子的。现在就教你怎么导出设置，从而实现共享  </p>
<ul>
<li>1、选择 File -&gt; Export Settings…，然后勾选需要到处的设置项，Code Style，File Template， Key maps ，Live Templates 等比较常用的，可以自己选择到处后的存放地址，命名为 settings.jar  </li>
</ul>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio35.jpg" alt="35"></p>
<ul>
<li>2、导出成功后，会有一个成功提示。导出成功后，会得到一个 settings.jar 包，可以把这个 jar 包保存起来，共享给同事，或者拷贝到 家里 或者 办公室 的电脑里面。  </li>
</ul>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio36.jpg" alt="36"></p>
<ul>
<li>3、接着便是 导入 的工作，选择 File -&gt; Import Settings…，然后选择第二步中的 jar 包，选择需要导入的模块，点击 OK 即可。  </li>
</ul>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio37.jpg" alt="37">  </p>
<p><img src="http://img.shedoor.net/androidstudio/Androidstudio38.jpg" alt="38"></p>
<blockquote>
<p>参考文章<br><a href="http://jingyan.baidu.com/article/e9fb46e170287a7520f7665c.html">Android studio安装配置常见问题及其解决方案</a><br><a href="http://www.androidchina.net/4862.html">Android Studio 进阶详细配置</a>  </p>
</blockquote>
<h2 id="8、更新："><a href="#8、更新：" class="headerlink" title="8、更新："></a>8、更新：</h2><h3 id="Android-Studio-Prettify"><a href="#Android-Studio-Prettify" class="headerlink" title="Android Studio Prettify"></a>Android Studio Prettify</h3><p>当提到这个控件大多数人知道的它的功能是能<strong>自动书写findViewById</strong><br><img src="http://img.shedoor.net/ocnyangcom/androidstudio2_1.png" alt="1">  </p>
<blockquote>
<p>这里的用法是：光标放到设置xml文件的那行，Alt+Insert会弹出插件目录，在这里你可以选择是生成全局还是局部的控件变量，相对来说还是挺方便的。<br>但是这里需要注意的是，当有多个activity用到相同的xml文件时可能会有小bug。这个是听用的人说的，我没具体用到过具体是怎样的bug不太清楚。本人来说不建议使用它来生成findviewbyid。毕竟<a href="http://ocnyang.com/">Android ButterKnife Zelezny</a>还是挺方便的。  </p>
</blockquote>
<p>相对来说我更喜欢它的另外一个作用：<strong>将代码中的字符串写在string.xml文件中</strong><br><img src="http://img.shedoor.net/ocnyangcom/androidstudio2_2.png" alt="2"><br>在代码中的字符串上可以右键选择将它写在string.xml文件里。<br>当然你也可以选择光标放在字符串上Alt+Enter(回车键)选择第一个Extract String Resource选项完成。同时这个方法你也可以用到编写布局文件上：<br><img src="http://img.shedoor.net/ocnyangcom/androidstudio2_3.png" alt="3">  </p>
<h3 id="让Android-studio像Sublime一样全屏代码"><a href="#让Android-studio像Sublime一样全屏代码" class="headerlink" title="让Android studio像Sublime一样全屏代码"></a>让Android studio像Sublime一样全屏代码</h3><p>先看一下效果（真正意义的全屏代码啊）：<br><img src="http://img.shedoor.net/ocnyangcom/androidstudio_submit2.png" alt="sublime2"><br>看上去是不是特别爽，在有些时候用用也是不错的体验呢。<br>这个功能是Android studio自带的功能，但是需要你先手动设置一下：全屏代码的快捷键（默认情况下这个功能是没有快捷键的，即是关闭的）：<br><img src="http://img.shedoor.net/ocnyangcom/Androidstudio_submit.png" alt="sublime1"><br>这里我设置的是Ctrl+分号，大家在设置的时候也可以根据自己的喜好设置，只要不要和官方的其他快捷键冲突就好。当然我的设置是亲测不冲突的哦！  </p>
<h3 id="Sexy-Editor-代码编辑区设置背景图"><a href="#Sexy-Editor-代码编辑区设置背景图" class="headerlink" title="Sexy Editor(代码编辑区设置背景图)"></a>Sexy Editor(代码编辑区设置背景图)</h3><p>其实这个插件功能我是早就知道的，但是我不提倡这样做，毕竟一个花花绿绿的背景图会给代码编辑造成一定的视觉障碍。现在想想，作为程序员，也行设置一个背景图片也是自己个性风骚独步的一种体现，那就在这里说说它的实现方式吧，下面先看一下效果图（截图摘自他处）：<br><img src="http://img.shedoor.net/ocnyangcom/androidstudio2_6.png"><br>效果怎么样？如果你喜欢的话……  </p>
<p>下面我们介绍一下安装过程：<br>如果想添加图片背景我们需要安装一个插件，Preferences –&gt;Plugins  搜索 Sexy Editor  (前提是你没有安装过哦)，看图：<br><img src="http://img.shedoor.net/ocnyangcom/androidstudio2_5.png"><br>OK，到这一步呢，你已经成功一半了，安装完毕后在你的Other Setting下看到Sexy Editor,如图：<br><img src="http://img.shedoor.net/ocnyangcom/androidstudio2_4.png"><br>到这里都基本OK，在最下面点Insert 上传图片就可以了，就可以体验你想要的图片背景了。  </p>
<blockquote>
<p>配置方法：<br>Position是对齐方式，<br>Opacity是透明度，<br>Shrink to fit适应屏幕，<br>Slideshow是图片轮换时间单位ms，<br>Random是随机轮换照片，<br>最底下Insert导入本地图片。</p>
</blockquote>
]]></content>
      <categories>
        <category>原创</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android教程系列</tag>
        <tag>Android studio</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio 常用高效快捷键</title>
    <url>/2016/12/28/AndroidStudioSkills/</url>
    <content><![CDATA[<blockquote>
<p>整理<code>Android群英传</code>和网上出现的比较完整<code>AS</code>的快捷小技巧. <code>mac</code>版已测, <code>win</code>大部分已测试. 最后有一个整理的完整<code>快捷键表格</code>. win也好mac也好, 如果快捷被修改还是错误, 都可以通过提供的<code>Keymap中的关键字</code>来进行重设.</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p> 图中<code>gif</code>如果看不清, 放大页面即可.</p>
</blockquote>
<p><a href="https://github.com/suzeyu1992/repo">原文地址</a></p>
<ul>
<li><a href="#1">常用小操作</a><ul>
<li><a href="#2">单词选择</a></li>
<li><a href="#3">显示最近操作,修改的文件</a></li>
<li><a href="#4">文件查找</a></li>
<li><a href="#5">操作记录</a></li>
<li><a href="#6">移动行</a></li>
<li><a href="#7">查找方法调用处</a></li>
<li><a href="#8">方法的跟进</a></li>
<li><a href="#9">显示方法的参数</a></li>
<li><a href="#10">行的快速操作</a></li>
<li><a href="#11">多行操作</a></li>
<li><a href="#12">快速补全完成</a></li>
<li><a href="#13">代码提示</a></li>
<li><a href="#14">变量的快速操作</a></li>
<li><a href="#15">代码折叠</a></li>
<li><a href="#16">预览方法定义</a></li>
<li><a href="#17">粘贴板管理</a></li>
<li><a href="#18">拆分窗口</a></li>
<li><a href="#19">变量命令风格</a></li>
<li><a href="#20">查看大纲</a></li>
<li><a href="#21">书签</a></li>
</ul>
</li>
<li><a href="#22">快速重构</a><ul>
<li><a href="#23">重构入口</a></li>
<li><a href="#24">surround with</a></li>
<li><a href="#25">Extract</a></li>
</ul>
</li>
<li><a href="#26">代码模块</a>  </li>
<li><a href="#27">代码分析</a><ul>
<li><a href="#28">Insepect Code &amp; Code cleanup</a></li>
<li><a href="#29">Dependencies</a></li>
<li><a href="#30">方法调用栈</a></li>
</ul>
</li>
<li><a href="#31">断点调试</a><ul>
<li><a href="#32">快速调试</a></li>
</ul>
</li>
<li><a href="#33">快捷键查找表</a>       </li>
</ul>
<a name="1"/>
## 常用小操作

<a name="2"/>
### 单词选择

<p>一般<code>IDE</code>通过<code>option + 方向键左右</code>(win为<code>ctrl + 左右方向键</code>)对光标进行单词的跳动, 但是由于我们使用驼峰式命名较多, 默认的会导致由多个单词组成的驼峰式的首尾跳转. 还好<code>AS</code>可以对这种风格进行设定.</p>
<p><strong>默认效果</strong></p>
<p><img src="http://img.shedoor.net/ocnyang/androidstudioskills/smart_old.gif"></p>
<p><strong>修改后的效果</strong></p>
<p><img src="http://img.shedoor.net/ocnyang/androidstudioskills/smart_new.gif"></p>
<p><strong>修改步骤</strong></p>
<p>打开<strong>偏好设置</strong>如图片设置</p>
<p><img src="http://img.shedoor.net/ocnyang/androidstudioskills/smart.png"></p>
<a name="3"/>
### 显示最近操作, 修改的文件

<p>例如: 我打开了<code>main_activity.xml</code>布局文件, 然后关闭页面. 这个时候<code>Command + E</code>, 就会如下显示之前的操作文件.</p>
<p><img src="http://img.shedoor.net/ocnyang/androidstudioskills/recent_file.png"></p>
<p>那么如果要查看之前修改过的文件, <code>Command + Shift + E</code>即可.  可以配合<code>Control + Tab</code>进行快速界面的切换.</p>
<p><strong>快捷键</strong></p>
<ul>
<li>最近操作<ul>
<li><code>Command + E</code> <strong>(mac)</strong></li>
<li><code>ctrl + E</code> <strong>(win)</strong></li>
</ul>
</li>
<li>最近修改<ul>
<li><code>Command + Shift + E</code>  <strong>(mac)</strong></li>
<li><code>ctrl + shift + enter</code> <strong>(win)</strong></li>
</ul>
</li>
</ul>
<a name="4"/>
### 文件查找



<p><code>search Everywhere</code></p>
<p>项目中的全局查找功能文件功能</p>
<p><strong>查找类文件</strong></p>
<ul>
<li><code>command + o</code> <strong>(mac)</strong></li>
<li><code>ctrl + n</code> <strong>(win)</strong></li>
</ul>
<p>默认只是在项目代码中查找类文件, 如果需要查找<code>sdk</code>或者类库中的相关类. 再按一次快捷键, 或者勾选下图选项搜索全局类文件</p>
<p><img src="http://img.shedoor.net/ocnyang/androidstudioskills/find_class.png"></p>
<hr>
<p><strong>查找文件</strong></p>
<p>这个级别比上面那个更广. 包括所有文件, 如<code>xml</code>等.</p>
<ul>
<li><code>command + shift + o</code> <strong>(mac)</strong></li>
<li><code>ctrl + shift + n</code> <strong>(win)</strong></li>
</ul>
<p>如上如果需要搜索类库或者源码, 请在按一次快捷键, 或者勾选<code>查找类</code>给出图中的选项.</p>
<a name="5"/>
### 操作记录

<p>在浏览代码结构的时候, 很多时候总是会跟进许多类里面, 如果想回到之前浏览调转点. 那么这个快捷键你就必须要记住.</p>
<ul>
<li><code>Command + Option + Left\Right</code> 或者 <code>command + [</code>, <code>command + ]</code> <strong>(mac)</strong></li>
<li><code>ctrl + alt + Left\Right</code><strong>(win)</strong></li>
</ul>
<a name="6"/>
### 移动行

<p>这个不用太多介绍, 就是<strong>整行</strong>的上下移动.</p>
<ul>
<li><code>Option + shift + 方向键上\方向键下</code> <strong>(mac)</strong></li>
<li><code>alt + shift + 方向键上\方向键下</code> <strong>(win)</strong></li>
</ul>
<a name="7"/>
### 查找方法调用处

<p>场景: 查找一个方法在何处被调用, 或者一个ID在哪里被引用. 选中这个方法<strong>右键</strong>, 选择<code>Find Usages</code>即可.</p>
<p>快捷键:</p>
<ul>
<li><code>option + F7</code> <strong>(mac)</strong></li>
<li><code>alt + F7</code> <strong>(win)</strong></li>
</ul>
<a name="8"/>
### 方法的跟进

<p>方法总是伴随着调转, 我们也总是会对方法的内部查看细节. 常用的办法是<code>按住Command 并点击方法名</code>的方式.</p>
<p>也可以在光标所在处直接通过<code>Command + B</code>进行方法内部跟进.</p>
<ul>
<li><code>Command + B</code> <strong>(mac)</strong></li>
<li><code>ctrl + alt + B</code> <strong>(win)</strong></li>
</ul>
<a name="9"/>
### 显示方法的参数

<p>当我们使用一个方法的时候, 会在刚开始的时候显示出所有的参数. 但是过一会可能就不存在了. 这个时候如果你想知道下一个参数是什么类型, 或者看一下所有参数.</p>
<p><img src="http://img.shedoor.net/ocnyang/androidstudioskills/params.gif"></p>
<p>快捷键:</p>
<ul>
<li><code>command + P</code> <strong>(mac)</strong></li>
<li><code>ctrl + P</code> <strong>(win)</strong></li>
</ul>
<p>如果你还想查看一下方法的文档, 不用跟进源码, 直接<code>F1</code>键即可显示出文档.</p>
<a name="10"/>
### 行的快速操作

<p>快速删除行, 其实使用剪切功能就可以<code>Command + X</code></p>
<p><strong>快速复制行</strong>, 使用<code>command + D</code><strong>mac</strong>, <code>ctrl + D</code><strong>win</strong></p>
<a name="11"/>
### 多行操作

<p>可能有时候我们会声明做一系列相关的变量为<code>float</code>类型, 但是真实的需要的是<code>int</code>类型. 这个时候就可以进行<code>多重选择</code>进行整体修改. 如下图:</p>
<p><img src="http://img.shedoor.net/ocnyang/androidstudioskills/mul_condition.gif"></p>
<p>按住<code>option</code>(win为<code>alt</code>)键, 然后鼠标进行区域的选择. 然后进行对应修改即可.</p>
<p>你可能认为上面的必须要连续的才可以. 那么如果可以设置<code>多个光标点</code>是否就可以满足你的问题了?</p>
<p>看下图:</p>
<p><img src="http://img.shedoor.net/ocnyang/androidstudioskills/mul_no_condition.gif"></p>
<ul>
<li><code>option + shift + 鼠标点击</code> <strong>(mac)</strong></li>
<li><code>alt + shift + 鼠标点击</code><strong>(win)</strong></li>
</ul>
<p>即可添加一个<code>编辑光标</code>. 最后如果不需要那么就<code>esc</code>即可关闭多余光标.</p>
<a name="12"/>
### 快速补全完成

<p>创建一个对象. 或者<code>findViewById()</code>有时总需要移动鼠标或者光标到末尾进行<code>分号</code>的补全. 这些都可以快捷键搞定.  当你用习惯之后, 会非常的方便好用.</p>
<ul>
<li><code>command + shift + enter</code><strong>(mac)</strong></li>
<li><code>ctrl + shift + enter</code><strong>(win)</strong></li>
</ul>
<p>实现的功能</p>
<ul>
<li>方法体大括号的添加</li>
<li>行尾分号的添加</li>
<li>自动格式化改行操作等</li>
</ul>
<a name="13"/>
### 代码提示

<p>任何地方都可以调出的代码提示.</p>
<p><code>control + option + /</code>(不是默认, mac默认为<code>control + space</code>). 这里要说的是. 代码提示之后一般都会<code>回车键</code>确定. 当按<code>回车键</code>的时候. 会保留光标之后的内容. 当有的时候我们并不需要. 这个时候你就可以使用<code>table</code>键进行选择. 它会将后面的输入内容删掉.</p>
<p>win的快捷方式<code>ctrl + 空格</code>(win同样大部分和输入法冲突, 请手动在AS设置里面<code>keymap</code>项查找<code> completion basic</code>手动修改快捷键)</p>
<p><img src="http://img.shedoor.net/ocnyang/androidstudioskills/tip.gif"></p>
<p><strong>快速生成变量</strong></p>
<p>比如在方法体中<code>logi</code>直接快速生成一个<code>log</code>日志输出的模板, 但是<code>TAG</code>这个常量还没有声明. 这个时候用光标移动到<code>TAG</code>上. 使用快捷键提示即可快速生成.</p>
<ul>
<li><code>option + enter</code><strong>(mac)</strong></li>
<li><code>alt + enter</code><strong>(win)</strong></li>
</ul>
<a name="14"/>
### 变量的快速操作

<p><img src="http://img.shedoor.net/ocnyang/androidstudioskills/filed.gif"></p>
<p>上图使用了两次快捷键,</p>
<ul>
<li>第一次: 跳转到变量的<code>声明处</code><ul>
<li><code>command + B</code> <strong>(mac)</strong></li>
<li><code>ctrl + b</code>  <strong>(win)</strong></li>
</ul>
</li>
<li>第二次: 跳转到变量类型的<code>定义处</code><ul>
<li><code>command + shift + B</code> <strong>(mac)</strong></li>
<li><code>ctrl + shift + b</code> <strong>(win)</strong></li>
</ul>
</li>
</ul>
<a name="15"/>
### 代码折叠

<p>对代码块进行折叠和展开.</p>
<ul>
<li><code>command + 加号\减号</code><strong>(mac)</strong></li>
<li><code>ctrl + 加号\减号</code> <strong>(win)</strong></li>
</ul>
<a name="16"/>
### 预览方法定义

<p>如果只想大体了解方法的定义, 而不需要进行方法所在源码类的跳转显示. 可以通过<code>Command + Y</code> (win快捷键为<code>ctrl + shift + I</code>)来进行预览</p>
<p><img src="http://img.shedoor.net/ocnyang/androidstudioskills/method_pre.png"></p>
<a name="17"/>
### 粘贴板管理

<p>对于复制粘贴. 我们习惯只是<code>单次</code>的<code>c+v</code>, 那么如果你想查看之前被覆盖了的<code>复制过的</code>内容. <code>AS</code>同样有<code>复制粘贴板</code>来管理.  展示最近几次的复制内容.</p>
<p><img src="http://img.shedoor.net/ocnyang/androidstudioskills/command_copy.png"></p>
<ul>
<li><code>command + shift + v</code> <strong>(mac)</strong></li>
<li><code>ctrl + shift + v</code>    <strong>(win)</strong></li>
</ul>
<a name="18"/>
### 拆分窗口

<p><img src="http://img.shedoor.net/ocnyang/androidstudioskills/split.png"></p>
<p>只需要在标签页上<code>右键</code>. 选择<code>split vertical\horizontal</code>.</p>
<a name="19"/>
### 变量命名风格

<p>对于<code>成员变量</code>应该<code>m</code>开头. 对于<code>静态成员</code>通常是<code>s</code>开头.  可以这样设置这个风格.</p>
<p><img src="http://img.shedoor.net/ocnyang/androidstudioskills/set_name.png"></p>
<p>这样在输入一个变量的名字时, 就可以自动补全<code>m</code>或者<code>s</code>. 同时在<code>Extra</code>代码的时候, 生成的代码都可以自动根据这个规则重构.</p>
<a name="20"/>
### 查看大纲

<p>当一个类很大的时候. 可以通过<code>command + F12</code>(win为<code>ctrl + F12</code>) 打开大纲界面. 展示全部的方法和成员变量列表.</p>
<p><img src="http://img.shedoor.net/ocnyang/androidstudioskills/all_body.png"></p>
<p>并且支持模糊搜索. 来进行筛选显示. 可以快速的找到要搜索的方法集.</p>
<a name="21"/>
### 书签

<p>在浏览大型代码, 或者调试时.  有时可能会需要记住一些关键的代码或者方法. 这个时候就可以使用<code>书签</code>. 来记录此关键代码. 只需要在点击需要标记的行, 并按<code>F3</code>就会在左侧出现一个<code>小对勾</code>. 这就说明已经打上了一个书签.</p>
<p>同时在<code>Favorites</code>标签中, 也可以找到对应的<code>Bookmarks</code></p>
<p>可以通过快捷键<code>command + F3</code> (win为<code>shift + F11</code>)快速调出书签面板, 进行后续的操作.</p>
<a name="22"/>
## 快速重构

<a name="23"/>
### 重构入口

<p>当一个代码片段准备重构的时候. 可以使用<code>control + T</code> (win为<code>ctrl + alt + shift + T</code>)打开重构入口. 或者<code>右键单击</code>选择<code>Refactor</code>显示重构界面.</p>
<p>这里有很多方便的功能. 提成方法等等.</p>
<a name="24"/>
### surround With

<p>当对一个段代码进行, 条件包裹, 捕捉异常, 循环, Runnable等. 可以直接使用快捷的方式, 而不需要手动生成条件在进行代码块的<code>复制-粘贴</code></p>
<p><img src="http://img.shedoor.net/ocnyang/androidstudioskills/runnable.gif"></p>
<p>快捷键</p>
<ul>
<li><code>command + option + T</code><strong>(mac)</strong></li>
<li><code>ctrl + alt + T</code><strong>(win)</strong></li>
</ul>
<a name="25"/>
### Extract

<p>你可以经常使用它,提取出一个方法.</p>
<p><img src="http://img.shedoor.net/ocnyang/androidstudioskills/extract_method.gif"></p>
<p>不仅仅如此, 你还可以对<code>xml</code>中的多个控件相同的属性进行抽取为<code>style</code></p>
<p><img src="http://img.shedoor.net/ocnyang/androidstudioskills/extract_xml.gif"></p>
<p>快捷键：  </p>
<ul>
<li><code>ctrl + alt + shift + T</code><strong>(win)</strong></li>
</ul>
<p>是不是很爽?</p>
<p>这是其一, 对于<code>xml</code>不仅可以抽取<code>Style</code>, 还可以抽取布局<code>Layout</code></p>
<p>而代码中, 可以提取各种变量, 参数, 长廊.</p>
<a name="26"/>
## 代码模板

<p><code>AS</code>中已经内置了很多代码模板, 你可以很嗖嗖嗖的就完成之前倒背如流的代码. 如下一小部分</p>
<p><img src="http://img.shedoor.net/ocnyang/androidstudioskills/template.gif"></p>
<p>通过快捷键可调出这些代码模板</p>
<ul>
<li><code>command + J</code><strong>(mac)</strong></li>
<li><code>ctrl + J</code><strong>(win)</strong></li>
</ul>
<a name="27"/>
## 代码分析

<p><code>Google</code>提供了很多代码分析工具, 这些工具都集中在顶部菜单栏的<code>Analyze</code>中.</p>
<a name="28"/>
### Inspect Code & Code cleanup

<p><code>Inspect Code</code>可以让<code>IDE</code>分析整个工程. 类似于<code>Lint</code>分析, 并会给出大致修改意见等</p>
<p><code>Code cleanup</code>功能可以进行自动的代码修复.</p>
<a name="29"/>
### Dependencies

<p>通过<code>Analyze</code>中的几个<code>Dependencies</code>选项. 可以快速分析项目的依赖.</p>
<a name="30"/>
### 方法调用栈

<p>对于某些方法来说, 查看它被调用的地方和调用的顺序是非常重要的. 可通过<code>control + option + H</code>快速查找方法调用栈.</p>
<a name="31"/>
## 断点调试

<a name="32"/>
### 快速断点

<p><code>条件断点</code>. 主要用在循环体内. 一个循环10次的<code>for</code>. 只想在第<code>8</code>次进入断点.</p>
<p>和<code>普通断点</code>相似, 一样先声明一个断点. 然后在<code>普通断点</code>上<code>单击鼠标右键</code>. 在弹出的菜单填写断点条件即可. 如下:</p>
<p><img src="http://img.shedoor.net/ocnyang/androidstudioskills/condition.gif"></p>
<p>上面图中<code>Enable</code>可以控制<code>启用</code>, 还是<code>停用</code>一个断点.</p>
<hr>
<p><code>临时断点</code>. 如果需要一个只执行一次的断点. 执行完之后断点自动取消. 那么可以通过快捷点将当前行作为临时断点.</p>
<p><img src="http://img.shedoor.net/ocnyang/androidstudioskills/one_debug.png"></p>
<ul>
<li><code>command + option + shift + F8</code></li>
<li><code>ctrl + alt + shift + F8</code></li>
</ul>
<p>为了篇幅不是很长, 调试的部分贴一个讲解很详细的帖子</p>
<ul>
<li><a href="http://blog.csdn.net/dd864140130/article/details/51560664">Android Studio代码调试大全</a></li>
</ul>
<a name="33"/>
## 快捷键查找表

<p>速查表列出了<code>keymap</code>快捷键的名称. 可以直接通过<code>AS setting</code>界面搜索<code>keymap</code>. 通过对应的快捷键名称来添加或者修改快捷键.</p>
<table>
<thead>
<tr>
<th>功能描述</th>
<th>keymap对应名字</th>
<th>Mac</th>
<th>Win/Linux</th>
</tr>
</thead>
<tbody><tr>
<td><strong>提示错误解决方案</strong></td>
<td><strong>Show Intention Actions</strong></td>
<td><code>option + enter</code></td>
<td><code>alt + enter</code></td>
</tr>
<tr>
<td><strong>AS配置界面</strong></td>
<td><strong>Preferences</strong></td>
<td><code>command + ,</code></td>
<td><code>control+alt+S</code></td>
</tr>
<tr>
<td><strong>工程项目配置界面</strong></td>
<td><strong>Project Structure</strong></td>
<td><code>command + ;</code></td>
<td><code>Control＋Alt+Shift+S</code></td>
</tr>
<tr>
<td><strong>快速构成代码</strong></td>
<td><strong>Code Generate</strong></td>
<td><code>command + N</code></td>
<td><code>alt + insert</code></td>
</tr>
<tr>
<td><strong>代码提示</strong></td>
<td><strong>Completion/Basic</strong></td>
<td><code>control + space</code>(mac会冲突, 手动修改)</td>
<td><code>ctrl + 空格</code>(win同样大部分和输入法冲突, 手动修改)</td>
</tr>
<tr>
<td><strong>选择视图</strong></td>
<td><strong>select in any view</strong></td>
<td><code>option + F1</code></td>
<td><code>alt + F1</code></td>
</tr>
<tr>
<td><strong>添加书签标识</strong></td>
<td><strong>Toggle Bookmark</strong></td>
<td><code>option + F3</code></td>
<td><code>ctrl + F11</code></td>
</tr>
<tr>
<td><strong>向下移动一行</strong></td>
<td><strong>Move Line Down</strong></td>
<td><code>option + shift + Down</code></td>
<td><code>alt + shift + Down</code></td>
</tr>
<tr>
<td><strong>向上移动一行</strong></td>
<td><strong>Move Line Up</strong></td>
<td><code>option + shift + Up</code></td>
<td><code>alt + shift + Up</code></td>
</tr>
<tr>
<td><strong>注释代码</strong></td>
<td><strong>Comment with Line Comment</strong></td>
<td><code>command + /</code></td>
<td><code>ctrl + /</code></td>
</tr>
<tr>
<td><strong>用代码模板包裹代码</strong></td>
<td><strong>surround with Live Template</strong></td>
<td><code>command + option + J</code></td>
<td><code>ctrl + alt + J</code></td>
</tr>
<tr>
<td><strong>格式化代码</strong></td>
<td><strong>Reformat Code</strong></td>
<td><code>command + option + L</code></td>
<td><code>ctrl + alt + L</code></td>
</tr>
<tr>
<td><strong>Copy Reference</strong></td>
<td><strong>Copy Reference</strong></td>
<td><code>command + option + shift + C</code></td>
<td><code>ctrl + alt + shift + C</code></td>
</tr>
<tr>
<td><strong>if/try等包裹代码</strong></td>
<td><strong>Surround With..</strong></td>
<td><code>command + option + T</code></td>
<td><code>ctrl + alt + T</code></td>
</tr>
<tr>
<td><strong>查看声明</strong></td>
<td><strong>Declaration</strong></td>
<td><code>command + B</code></td>
<td><code>ctrl + B</code></td>
</tr>
<tr>
<td><strong>快捷向下复制行</strong></td>
<td><strong>Duplicate Line or Block</strong></td>
<td><code>command + D</code></td>
<td><code>ctrl + D</code></td>
</tr>
<tr>
<td><strong>删除行</strong></td>
<td><strong>Delete Line</strong></td>
<td><code>command + delete</code></td>
<td><code>ctrl + Y</code></td>
</tr>
<tr>
<td><strong>快捷最近打开</strong></td>
<td><strong>Recent Files</strong></td>
<td><code>command + E</code></td>
<td><code>ctrl + E</code></td>
</tr>
<tr>
<td><strong>查找</strong></td>
<td><strong>Edit/Find/Find</strong></td>
<td><code>command + F</code></td>
<td><code>ctrl + F</code></td>
</tr>
<tr>
<td><strong>文件方法结构</strong></td>
<td><strong>File Structure</strong></td>
<td><code>command + F12</code></td>
<td><code>ctrl + F12</code></td>
</tr>
<tr>
<td><strong>显示书签</strong></td>
<td><strong>Show Bookmarks</strong></td>
<td><code>command + F3</code></td>
<td><code>shift + F11</code></td>
</tr>
<tr>
<td><strong>代码高亮向下查找</strong></td>
<td><strong>Move To Next Occurrence</strong></td>
<td><code>command + G</code></td>
<td><code>F3</code></td>
</tr>
<tr>
<td><strong>代码高亮向上查找</strong></td>
<td><strong>Move To Previous Occurrence</strong></td>
<td><code>command + shift + G</code></td>
<td><code>shift + F3</code></td>
</tr>
<tr>
<td><strong>按照模板生成代码</strong></td>
<td><strong>Insert Live Template</strong></td>
<td><code>command + J</code></td>
<td><code>ctrl + J</code></td>
</tr>
<tr>
<td><strong>定位到行</strong></td>
<td><strong>Navigate/Line</strong></td>
<td><code>command + L</code></td>
<td><code>ctrl + G</code></td>
</tr>
<tr>
<td><strong>快速到行首/尾</strong></td>
<td><strong>Move Caret to Line Start/End</strong></td>
<td><code>command + Left/Right</code></td>
<td><code>ctrl + Left/Right</code></td>
</tr>
<tr>
<td><strong>代码折叠/展开</strong></td>
<td><strong>Collapse/Expand</strong></td>
<td><code>command + 减号/加号</code></td>
<td><code>ctrl + 减号/加号</code></td>
</tr>
<tr>
<td><strong>查找类</strong></td>
<td><strong>Navigate/Class</strong></td>
<td><code>command + O</code></td>
<td><code>ctrl + N</code></td>
</tr>
<tr>
<td><strong>多行注释</strong></td>
<td>**Code/Comment **</td>
<td><code>command + option + /</code></td>
<td><code>ctrl + alt + /</code></td>
</tr>
<tr>
<td><strong>格式化代码</strong></td>
<td><strong>Reformat Code</strong></td>
<td><code>command + option + L</code></td>
<td><code>ctrl + alt + L</code></td>
</tr>
<tr>
<td><strong>提示参数类型</strong></td>
<td><strong>Parameter Info</strong></td>
<td><code>command + P</code></td>
<td><code>ctrl + P</code></td>
</tr>
<tr>
<td><strong>查找替换</strong></td>
<td><strong>Replace</strong></td>
<td><code>command + R</code></td>
<td><code>ctrl + R</code></td>
</tr>
<tr>
<td><strong>查找命令</strong></td>
<td><strong>Find Action</strong></td>
<td><code>command + shift + A</code></td>
<td><code>ctrl + shift + A</code></td>
</tr>
<tr>
<td><strong>拷贝文件路径</strong></td>
<td><strong>Copy Paths</strong></td>
<td><code>command + shift + C</code></td>
<td><code>ctrl + shift + C</code></td>
</tr>
<tr>
<td><strong>移动代码块</strong></td>
<td><strong>Move Statement Up/Down</strong></td>
<td><code>command + shift + down/up</code></td>
<td><code>ctrl + shift + down/up</code></td>
</tr>
<tr>
<td><strong>代码补全</strong></td>
<td><strong>Complete Current Statement</strong></td>
<td><code>command + shift + enter</code></td>
<td><code>ctrl + shift + enter</code></td>
</tr>
<tr>
<td><strong>全路径查找</strong></td>
<td><strong>Find in Path</strong></td>
<td><code>command + shift + F</code></td>
<td><code>ctrl + shift + F</code></td>
</tr>
<tr>
<td><strong>代码高亮</strong></td>
<td><strong>Highlight Usages in File</strong></td>
<td><code>command + shift + F7</code></td>
<td><code>alt + J</code></td>
</tr>
<tr>
<td><strong>窗口内所有代码折叠/展开</strong></td>
<td><strong>Collapse/Expand All</strong></td>
<td><code>command + shift + 减号/加号</code></td>
<td><code>ctrl + shift + 减号/加号</code></td>
</tr>
<tr>
<td><strong>查找文件</strong></td>
<td><strong>Navigate/File</strong></td>
<td><code>command + shift + O</code></td>
<td><code>ctrl + shift + N</code></td>
</tr>
<tr>
<td><strong>全路径中替换</strong></td>
<td><strong>Replace in Path</strong></td>
<td><code>command + shift + R</code></td>
<td><code>ctrl + shift + R</code></td>
</tr>
<tr>
<td><strong>大小写转换</strong></td>
<td><strong>Toggle Case</strong></td>
<td><code>command + shift + U</code></td>
<td><code>ctrl + shift + U</code></td>
</tr>
<tr>
<td><strong>显示粘贴版历史</strong></td>
<td><strong>Paste from History</strong></td>
<td><code>command + shift + V</code></td>
<td><code>ctrl + shift + V</code></td>
</tr>
<tr>
<td><strong>快速查找定义</strong></td>
<td></td>
<td><code>command + space</code></td>
<td><code>ctrl + shift + I</code></td>
</tr>
<tr>
<td><strong>粘贴</strong></td>
<td><strong>Paste</strong></td>
<td><code>command + V</code></td>
<td><code>ctrl + V</code></td>
</tr>
<tr>
<td><strong>复制</strong></td>
<td><strong>Copy</strong></td>
<td><code>command + C</code></td>
<td><code>ctrl + C</code></td>
</tr>
<tr>
<td><strong>去除无效包引用</strong></td>
<td><strong>Optimize Imports</strong></td>
<td><code>control + option + O</code></td>
<td><code>ctrl + alt + O</code></td>
</tr>
<tr>
<td><strong>显示类关系继承体系</strong></td>
<td><strong>Type Hierarchy</strong></td>
<td><code>control + H</code></td>
<td><code>ctrl + H</code></td>
</tr>
<tr>
<td><strong>快速覆写方法</strong></td>
<td><strong>override Methods</strong></td>
<td><code>control + O</code></td>
<td><code>ctrl + O</code></td>
</tr>
<tr>
<td><strong>查找调用的位置</strong></td>
<td><strong>Call hierarchy</strong></td>
<td><code>control + option + H</code></td>
<td><code>ctrl + alt + H</code></td>
</tr>
<tr>
<td><strong>添加书签</strong></td>
<td><strong>Toggle Bookmark</strong></td>
<td><code>F3</code></td>
<td><code>F11</code></td>
</tr>
<tr>
<td><strong>扩大缩小选中范围</strong></td>
<td><strong>Extend Selection/Shrink Selection</strong></td>
<td><code>option + UP/Down</code></td>
<td><code>ctrl + W + shift + W</code></td>
</tr>
<tr>
<td><strong>跳转到父类</strong></td>
<td><strong>Super method</strong></td>
<td><code>command + U</code></td>
<td><code>ctrl + U</code></td>
</tr>
<tr>
<td><strong>关闭当前tab标签</strong></td>
<td><strong>Editor Tabs / Close</strong></td>
<td><code>command + W</code></td>
<td><code>ctrl + shift + a</code></td>
</tr>
<tr>
<td><strong>关闭除编辑窗口的其余窗口</strong></td>
<td><strong>Hide All Tool Windows</strong></td>
<td><code>command + shift + F12</code></td>
<td><code>ctrl + shift + F12</code></td>
</tr>
<tr>
<td><strong>预览方法定义</strong></td>
<td><strong>Quick Definition</strong></td>
<td><code>command + Y</code></td>
<td><code>ctrl + shift + I</code></td>
</tr>
<tr>
<td><strong>返回光标最后编辑位置</strong></td>
<td><strong>Last Edit Location</strong></td>
<td><code>command + shift + delete</code></td>
<td><code>control + shift + Backspace</code></td>
</tr>
<tr>
<td><strong>调到代码块首部/尾部</strong></td>
<td><strong>Move Caret To Code Block</strong></td>
<td><code>Option + Command + [ 或者 ]</code></td>
<td><code>Control+[ 或者 ]</code></td>
</tr>
<tr>
<td><strong>重命名</strong></td>
<td><strong>Rename</strong></td>
<td><code>shift + F6</code></td>
<td><code>shift + F6</code></td>
</tr>
<tr>
<td><strong>抽取方法</strong></td>
<td><strong>Extract Method</strong></td>
<td><code>command + option + M</code></td>
<td><code>control+alt+M</code></td>
</tr>
<tr>
<td><strong>抽取变量</strong></td>
<td><strong>Extract Variable</strong></td>
<td><code>command + option + V</code></td>
<td><code>control+alt+V</code></td>
</tr>
<tr>
<td><strong>抽取字段</strong></td>
<td><strong>Extract Field</strong></td>
<td><code>command + option + F</code></td>
<td><code>control+alt+F</code></td>
</tr>
<tr>
<td><strong>抽取常量</strong></td>
<td><strong>Extract Constant</strong></td>
<td><code>command + option + C</code></td>
<td><code>control+alt+C</code></td>
</tr>
<tr>
<td><strong>抽取参数</strong></td>
<td><strong>Extract Parameter</strong></td>
<td><code>command + option + P</code></td>
<td><code>control+alt+P</code></td>
</tr>
<tr>
<td><strong>重构入口</strong></td>
<td><strong>Refactor This</strong></td>
<td><code>control + T</code></td>
<td><code>ctrl + alt + shift + T</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Android教程系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android教程系列</tag>
        <tag>Android studio</tag>
      </tags>
  </entry>
  <entry>
    <title>组合控件详解 &amp; 自定义属性</title>
    <url>/2016/08/24/CombinedWidget/</url>
    <content><![CDATA[<blockquote>
<p>摘录来源：<a href="http://wiki.jikexueyuan.com/project/android-actual-combat-skills/combined-control.html">极客学院WiKi</a></p>
</blockquote>
<p>组合控件是自定义控件的一种，只不过它是由其他几个原生控件组合而成，故名组合控件。  </p>
<p>在实际项目中，GUI 会遇到一些可以提取出来做成自定义控件情况。  </p>
<p>一个自定义控件的好处就是把一些需要模块化的 UI 和逻辑放在一起，做到了高内聚，向其他模块提供接口并很少依赖外界，这样就是低耦合。一个自定义控件就是一个封闭的王国，这里由你掌控。  </p>
<p>上述是我自己的一个体会，想必大家也会常做自定义控件吧，就像逻辑部分的模块化一样。  </p>
<span id="more"></span>

<p>下面我要做一个例子，请看完成图。</p>
<p><img src="http://img.shedoor.net/zuhekongjian/zuhekongjian.png" alt="ocn.yang">  </p>
<p>下面一排图片加文字就是组合控件了，我是怎么做的呢？</p>
<p>其实这里用到了两个组合控件，一个是图片+文字，我把它叫一个 Item，而三个在一起就是另一个控件了。</p>
<p>重点看这个 Item，它有自己的属性如图片、文字、图片大小、文字大小、不透明度等等。这些把它定义在 attr 文件中，然后在 xml 文件中配置，就像我们用原生控件一样。</p>
<h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p>先看 attr 文件。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;resources&gt;  
        &lt;declare-styleable name=&quot;LevelMenuItem&quot;&gt;  
        &lt;attr name=&quot;text&quot; format=&quot;string&quot; /&gt;  
        &lt;attr name=&quot;text_color&quot; format=&quot;color&quot;/&gt;  
        &lt;attr name=&quot;text_size&quot; format=&quot;dimension&quot; /&gt;          
        &lt;attr name=&quot;image_src&quot; format=&quot;reference&quot;/&gt;  
        &lt;attr name=&quot;image_bg&quot; format=&quot;reference&quot;/&gt;  
        &lt;attr name=&quot;image_alpha&quot; format=&quot;integer&quot; /&gt;  
        &lt;attr name=&quot;image_height&quot; format=&quot;dimension&quot;&gt;&lt;/attr&gt;  
        &lt;attr name=&quot;image_width&quot; format=&quot;dimension&quot; /&gt;  
    &lt;/declare-styleable&gt;  
&lt;/resources&gt;  
</code></pre>
<p>这个文件在 values 下，和 string 文件同级。把你自己要定义的属性都写在这里吧。format 是属性的“单位”，如果你要问有多少中 format 呀？答案在这里。  </p>
<h3 id="组合控件的布局文件"><a href="#组合控件的布局文件" class="headerlink" title="组合控件的布局文件"></a>组合控件的布局文件</h3><p>有了属性了，下面看看布局文件 level_menu_item.xml。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;LinearLayout xmlns:android=&quot;http:// schemas.android.com/apk/res/android&quot;  
    android:layout_width=&quot;fill_parent&quot;  
    android:layout_height=&quot;fill_parent&quot;  
    android:orientation=&quot;vertical&quot; &gt;  
        &lt;ImageView  
            android:id=&quot;@+id/image_item&quot;  
            android:layout_width=&quot;fill_parent&quot;  
            android:layout_height=&quot;fill_parent&quot;  
            android:scaleType=&quot;fitCenter&quot;  
            /&gt;  
         &lt;TextView  
            android:id=&quot;@+id/tv_item&quot;  
            android:layout_width=&quot;fill_parent&quot;  
            android:layout_height=&quot;wrap_content&quot;  
            android:gravity=&quot;center_horizontal&quot;  
            android:textColor=&quot;#23ffffff&quot;  
            android:textSize=&quot;25sp&quot;   
         /&gt;      
&lt;/LinearLayout&gt;  
</code></pre>
<p>这里唯一值得一说的是文本的颜色。大家看见他是8位的，前两位是表示不透明度的，后六位是表示颜色的，三色，范围都是00～ff。</p>
<p>如果在 Java 中设置颜色，需要这样。</p>
<pre><code>setTextColor(0x23ffffff);  
</code></pre>
<p>关于不透明度，一般美工会定义。有些要求不透明如30%这样的，可以用整型换算一下。00～ff 对应十进制为0～255，那么30%就是255x0.3=76.5，用科学计算机换算为4c。</p>
<p>更多颜色相关设置这里附上《Android 中设置文本颜色的三种办法》  </p>
<blockquote>
<p>1、 利于系统自带的颜色类<br>如： <strong>TextView1.setTextColor(android.graphics.Color.RED);</strong><br>布局文件中：<strong>android:textColor=”@android:color/white”</strong><br>详见Android源码:<strong>base/core/res/res/values/colors.xml</strong><br>2、 数字颜色表示法<br><strong>TextView1.setTextColor(0xffff00ff);</strong><br>3、 自定义颜色<br><strong>TextView1.setTextColor(this.getResources().getColor(R.drawable.red));</strong></p>
</blockquote>
<h3 id="组合控件的类文件"><a href="#组合控件的类文件" class="headerlink" title="组合控件的类文件"></a>组合控件的类文件</h3><p>然后我们就要写一个类，我这继承子线性布局。有两个构造函数，我们主要在两个参数的函数中工作。</p>
<pre><code>public class LevelMenuItem extends LinearLayout &#123;  

    public LevelMenuItem(Context context, AttributeSet attrs) &#123;  
        super(context, attrs);  

    &#125;  
</code></pre>
<p>这个类中我们要完成的工作是，初始化控件属性、提供外部修改属性的接口、控件点击的回调接口。</p>
<p>此类完整代码：</p>
<pre><code>package com.linc.game;  

import android.content.Context;  
import android.content.res.TypedArray;  
import android.util.AttributeSet;  
import android.view.LayoutInflater;  
import android.view.View;  
import android.widget.ImageView;  
import android.widget.LinearLayout;  
import android.widget.TextView;  
/**
 * 自定义一个关卡
 * 共有7个属性，看attr文件
 * 在程序中提供修改这7个属性的接口，
 * 一个自定义控件的任务就算完成。
 * 一个自定义控件的好处就是把一些需要模块化的
 * UI和逻辑放在一起，做到了高内聚，向其他模块提供接口并很少
 * 依赖外界，这样就是低耦合。一个自定义控件就是一个封闭的王国，
 * 这里由你掌控。
 *  
 * 编写时，如果遇到在attr里写好属性，但是在这里认不出来，
 * 就clean一下项目。切记。
 *  
 * @author linc
 *
 */  
public class LevelMenuItem extends LinearLayout &#123;  
    private TextView mTextView = null;  
    private ImageView mImageView = null;  

    public LevelMenuItem(Context context) &#123;  
        super(context);  
    &#125;  
    public LevelMenuItem(Context context, AttributeSet attrs) &#123;  
        super(context, attrs);  

        LayoutInflater layoutInflater = (LayoutInflater) context.  
                        getSystemService(Context.LAYOUT_INFLATER_SERVICE);  
        layoutInflater.inflate(R.layout.level_menu_item, this);  

        TypedArray typedArray = context.obtainStyledAttributes(attrs  
                ,R.styleable.LevelMenuItem);  

        initWidget(typedArray);  
    &#125;  
    private void initWidget(TypedArray typedArray)  
    &#123;  
        mTextView = (TextView)findViewById(R.id.tv_item);  
        String textString = typedArray.getString(R.styleable.LevelMenuItem_text);  
        int textColor = typedArray.getColor(R.styleable.LevelMenuItem_text_color,  
                0xffffffff);  
        float textSize = typedArray.getDimension(R.styleable.LevelMenuItem_text_size,  
                20);  
        mTextView.setText(textString);  
        mTextView.setTextColor(textColor);  
        mTextView.setTextSize(textSize);  

        mImageView = (ImageView)findViewById(R.id.image_item);  
        int imageHeight = (int) typedArray.getDimension(R.styleable.LevelMenuItem_image_height, 25);  
        int imageWidth = (int) typedArray.getDimension(R.styleable.LevelMenuItem_image_width, 25);  
        int imageSrc = typedArray.getResourceId(R.styleable.LevelMenuItem_image_src, 0);  
        int imageBg = typedArray.getResourceId(R.styleable.LevelMenuItem_image_bg, 0);  
        int imageAlpha = typedArray.getInt(R.styleable.LevelMenuItem_image_alpha, 255);  
        mImageView.setAlpha(imageAlpha);  
        mImageView.setImageResource(imageSrc);  
        mImageView.setBackgroundResource(imageBg);  
        LayoutParams layoutParams = new LayoutParams(imageWidth, imageHeight);  
        mImageView.setLayoutParams(layoutParams);  

        typedArray.recycle();  
    &#125;  
    /**
     * 设置此控件的文本
     * @param text
     */  
    public void setText(String text)  
    &#123;  
        mTextView.setText(text);  
    &#125;  
    /**
     * 设置文字颜色
     * @param textColor
     */  
     public void setTextColor(int textColor)  
    &#123;  
        mTextView.setTextColor(textColor);  
    &#125;  
    /**
     * 设置字体大小
     * @param textSize
     */  
     public void setTextSize(int textSize)  
    &#123;  
        mTextView.setTextSize(textSize);  
    &#125;  
    /**
     * 设置图片
     * @param resId
     */  
     public void setImageResource(int resId)  
    &#123;  
        mImageView.setImageResource(resId);  
    &#125;  
    /**
     * 设置图片背景
     */  
     public void setBackgroundResource(int resId)  
    &#123;  
        mImageView.setBackgroundResource(resId);  
    &#125;     
    /**
     * 设置图片的不透名度
     * @param alpha
     */  
    public void setImageAlpha(int alpha)  
    &#123;  
        mImageView.setAlpha(alpha);  
    &#125;  
    /**
     * 设置图片的大小
     * 这里面需要使用LayoutParams这个布局参数来设置
     * @param width
     * @param height
     */  
    public void setImageSize(int width,int height)  
    &#123;  
        LayoutParams layoutParams = new LayoutParams(width, height);  
        mImageView.setLayoutParams(layoutParams);  
    &#125;  
    /**
     * image点击事件的回调
     * @param listener
     */  
    public void setOnClickListener(OnItemClickListener listener)  
    &#123;  
        mImageView.setOnClickListener(new View.OnClickListener() &#123;  
            @Override  
            public void onClick(View v) &#123;  
                listener.onImageClick();  
            &#125;  
        &#125;);  
    &#125;  
    /**
     * 点击事件接口
     * @author linc
     *
     */  
    public interface OnItemClickListener  
    &#123;  
        public void onImageClick();  
    &#125;  
&#125;  
</code></pre>
<h3 id="组合控件的使用"><a href="#组合控件的使用" class="headerlink" title="组合控件的使用"></a>组合控件的使用</h3><p>好，一个完整的组合控件就做好了，那么，我们如何使用呢？</p>
<p>我要在 LevelMenu 中用它。xml 文件如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    xmlns:linc=&quot;http://schemas.android.com/apk/res/com.linc.game&quot;  
    android:layout_width=&quot;fill_parent&quot;  
    android:layout_height=&quot;fill_parent&quot;  
    android:orientation=&quot;horizontal&quot;&gt;      
    &lt;com.linc.game.LevelMenuItem  
        android:id=&quot;@+id/item1&quot;  
        android:layout_width=&quot;70dp&quot;  
        android:layout_height=&quot;80dp&quot;  
        linc:text=&quot;@string/item1&quot;  
        linc:text_size=&quot;14sp&quot;  
        linc:text_color=&quot;#80fa8072&quot;  
        linc:image_src=&quot;@drawable/orange_button_selector&quot;  
        linc:image_alpha=&quot;128&quot;  
        linc:image_height=&quot;48dp&quot;  
        linc:image_width=&quot;48dp&quot;  
        /&gt;  
    &lt;com.linc.game.LevelMenuItem  
        android:id=&quot;@+id/item2&quot;  
        android:layout_marginLeft=&quot;20dp&quot;  
        android:layout_width=&quot;70dp&quot;  
        android:layout_height=&quot;80dp&quot;  
        linc:text=&quot;@string/item2&quot;  
        linc:text_size=&quot;14sp&quot;  
        linc:text_color=&quot;#ffeee8aa&quot;  
        linc:image_src=&quot;@drawable/red_button_selector&quot;  
        linc:image_alpha=&quot;255&quot;  
        linc:image_height=&quot;48dp&quot;  
        linc:image_width=&quot;48dp&quot;  
        /&gt;     
    &lt;com.linc.game.LevelMenuItem  
        android:id=&quot;@+id/item3&quot;  
        android:layout_marginLeft=&quot;20dp&quot;  
        android:layout_width=&quot;70dp&quot;  
        android:layout_height=&quot;80dp&quot;  
        linc:text=&quot;@string/item3&quot;  
        linc:text_size=&quot;14sp&quot;  
        linc:text_color=&quot;#80cd853f&quot;               linc:image_src=&quot;@drawable/yellow_button_selector&quot;  
        linc:image_alpha=&quot;128&quot;  
        linc:image_height=&quot;48dp&quot;  
        linc:image_width=&quot;48dp&quot;  
        /&gt;         
&lt;/LinearLayout&gt;  
</code></pre>
<p>加入自己包名的索引</p>
<pre><code>xmlns:linc=&quot;http://schemas.android.com/apk/res/com.linc.game&quot;  
</code></pre>
<p>剩下的就一目了然了。</p>
<h3 id="用到组合控件的类文件"><a href="#用到组合控件的类文件" class="headerlink" title="用到组合控件的类文件"></a>用到组合控件的类文件</h3><p>LevelMenu.java</p>
<pre><code>package com.linc.game;  

import com.linc.game.LevelMenuItem.OnItemClickListener;  
import android.content.Context;  
import android.util.AttributeSet;  
import android.util.Log;  
import android.view.LayoutInflater;  
import android.widget.LinearLayout;  

public class LevelMenu extends LinearLayout &#123;  
    private LevelMenuItem item1,item2,item3;  

    public LevelMenu(Context context) &#123;  
        super(context);  

    &#125;  

    public LevelMenu(Context context, AttributeSet attrs) &#123;  
        super(context, attrs);  
        LayoutInflater layoutInflater = (LayoutInflater) context.  
            getSystemService(Context.LAYOUT_INFLATER_SERVICE);  
        layoutInflater.inflate(R.layout.level_menu, this);  
        initWidget();  
    &#125;  
    private void initWidget()  
    &#123;  
        item1 = (LevelMenuItem)findViewById(R.id.item1);  
        item2 = (LevelMenuItem)findViewById(R.id.item2);  
        item3 = (LevelMenuItem)findViewById(R.id.item3);  

        item1.setOnClickListener(new OnItemClickListener() &#123;  
            @Override  
            public void onImageClick() &#123;  
                Log.e(&quot;dfjdkfjd&quot;,&quot;dfdfd&quot;);  
            &#125;  
        &#125;);  
    &#125;  
&#125;  
</code></pre>
<p>在处理图片点击事件的时候，我用到了选择器（selector），这是我们实际开发中最常用的小技巧了。它能描述的状态很多，各位看官可以去查查。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;  
    &lt;item android:state_pressed=&quot;true&quot;  
        android:drawable=&quot;@drawable/button_push&quot;/&gt;  
    &lt;item android:drawable=&quot;@drawable/orange_button&quot;/&gt;  
&lt;/selector&gt;  
</code></pre>
<p>好，组合控件的例子先到这里，实际功能在下一个实战技巧中演练。</p>
<p>大家在做自定义控件时需要注意的是：</p>
<p>1、自定义控件类不能是是抽象类</p>
<p>2、要用 <code>(Context context, AttributeSet attrs)</code> 这个构造函数。  </p>
<p>否则报错：android.view.InflateException: Binary XML file line #15: Error inflating cla。。。  </p>
<h3 id="最后普及一下，attrs-xml中的属性的format（类型）说明"><a href="#最后普及一下，attrs-xml中的属性的format（类型）说明" class="headerlink" title="最后普及一下，attrs.xml中的属性的format（类型）说明"></a>最后普及一下，attrs.xml中的属性的format（类型）说明</h3><h4 id="1-reference：参考某一资源ID。"><a href="#1-reference：参考某一资源ID。" class="headerlink" title="1. reference：参考某一资源ID。"></a>1. reference：参考某一资源ID。</h4><p>（1）属性定义：</p>
<pre><code>&lt;declare-styleable name = &quot;名称&quot;&gt;
   &lt;attr name = &quot;background&quot; format = &quot;reference&quot; /&gt;
&lt;/declare-styleable&gt;
</code></pre>
<p>（2）属性使用：</p>
<pre><code>&lt;ImageView
     android:layout_width = &quot;42dip&quot;
     android:layout_height = &quot;42dip&quot;
     android:background = &quot;@drawable/图片ID&quot;
     /&gt;
</code></pre>
<h4 id="2-color：颜色值。"><a href="#2-color：颜色值。" class="headerlink" title="2. color：颜色值。"></a>2. color：颜色值。</h4><p>（1）属性定义：</p>
<pre><code>&lt;declare-styleable name = &quot;名称&quot;&gt;
    &lt;attr name = &quot;textColor&quot; format = &quot;color&quot; /&gt;
&lt;/declare-styleable&gt;
</code></pre>
<p>（2）属性使用：</p>
<pre><code>&lt;TextView
     android:layout_width = &quot;42dip&quot;
     android:layout_height = &quot;42dip&quot;
     android:textColor = &quot;#00FF00&quot;
     /&gt;
</code></pre>
<h4 id="3-boolean：布尔值。"><a href="#3-boolean：布尔值。" class="headerlink" title="3. boolean：布尔值。"></a>3. boolean：布尔值。</h4><p>（1）属性定义：</p>
<pre><code>&lt;declare-styleable name = &quot;名称&quot;&gt;
   &lt;attr name = &quot;focusable&quot; format = &quot;boolean&quot; /&gt;
&lt;/declare-styleable&gt;
</code></pre>
<p>（2）属性使用：</p>
<pre><code>&lt;Button
    android:layout_width = &quot;42dip&quot;
    android:layout_height = &quot;42dip&quot;
    android:focusable = &quot;true&quot;
    /&gt;
</code></pre>
<h4 id="4-dimension：尺寸值。"><a href="#4-dimension：尺寸值。" class="headerlink" title="4. dimension：尺寸值。"></a>4. dimension：尺寸值。</h4><p>（1）属性定义：</p>
<pre><code>&lt;declare-styleable name = &quot;名称&quot;&gt;
   &lt;attr name = &quot;layout_width&quot; format = &quot;dimension&quot; /&gt;
&lt;/declare-styleable&gt;
</code></pre>
<p>（2）属性使用：</p>
<pre><code>&lt;Button
    android:layout_width = &quot;42dip&quot;
    android:layout_height = &quot;42dip&quot;
    /&gt;
</code></pre>
<h4 id="5-float：浮点值。"><a href="#5-float：浮点值。" class="headerlink" title="5. float：浮点值。"></a>5. float：浮点值。</h4><p>（1）属性定义：</p>
<pre><code>&lt;declare-styleable name = &quot;AlphaAnimation&quot;&gt;
   &lt;attr name = &quot;fromAlpha&quot; format = &quot;float&quot; /&gt;
   &lt;attr name = &quot;toAlpha&quot; format = &quot;float&quot; /&gt;
&lt;/declare-styleable&gt;
</code></pre>
<p>（2）属性使用：</p>
<pre><code>&lt;alpha
   android:fromAlpha = &quot;1.0&quot;
   android:toAlpha = &quot;0.7&quot;
   /&gt;
</code></pre>
<h4 id="6-integer：整型值。"><a href="#6-integer：整型值。" class="headerlink" title="6. integer：整型值。"></a>6. integer：整型值。</h4><p>（1）属性定义：</p>
<pre><code>&lt;declare-styleable name = &quot;AnimatedRotateDrawable&quot;&gt;
   &lt;attr name = &quot;visible&quot; /&gt;
   &lt;attr name = &quot;frameDuration&quot; format=&quot;integer&quot; /&gt;
   &lt;attr name = &quot;framesCount&quot; format=&quot;integer&quot; /&gt;
   &lt;attr name = &quot;pivotX&quot; /&gt;
   &lt;attr name = &quot;pivotY&quot; /&gt;
   &lt;attr name = &quot;drawable&quot; /&gt;
&lt;/declare-styleable&gt;
</code></pre>
<p>（2）属性使用：</p>
<pre><code>&lt;animated-rotate
       xmlns:android = &quot;http://schemas.android.com/apk/res/android&quot;
       android:drawable = &quot;@drawable/图片ID&quot;
       android:pivotX = &quot;50%&quot;
       android:pivotY = &quot;50%&quot;
       android:framesCount = &quot;12&quot;
       android:frameDuration = &quot;100&quot;
       /&gt;
</code></pre>
<h4 id="7-string：字符串。"><a href="#7-string：字符串。" class="headerlink" title="7. string：字符串。"></a>7. string：字符串。</h4><p>（1）属性定义：  </p>
<pre><code>&lt;declare-styleable name = &quot;MapView&quot;&gt;
       &lt;attr name = &quot;apiKey&quot; format = &quot;string&quot; /&gt;
&lt;/declare-styleable&gt;
</code></pre>
<p>（2）属性使用：  </p>
<pre><code>&lt;com.google.android.maps.MapView
        android:layout_width = &quot;fill_parent&quot;
        android:layout_height = &quot;fill_parent&quot;
        android:apiKey = &quot;0jOkQ80oD1JL9C6HAja99uGXCRiS2CGjKO_bc_g&quot;
        /&gt;
</code></pre>
<h4 id="8-fraction：百分数。"><a href="#8-fraction：百分数。" class="headerlink" title="8. fraction：百分数。"></a>8. fraction：百分数。</h4><p>（1）属性定义：</p>
<pre><code>&lt;declare-styleable name=&quot;RotateDrawable&quot;&gt;
   &lt;attr name = &quot;visible&quot; /&gt;
   &lt;attr name = &quot;fromDegrees&quot; format = &quot;float&quot; /&gt;
   &lt;attr name = &quot;toDegrees&quot; format = &quot;float&quot; /&gt;
   &lt;attr name = &quot;pivotX&quot; format = &quot;fraction&quot; /&gt;
   &lt;attr name = &quot;pivotY&quot; format = &quot;fraction&quot; /&gt;
   &lt;attr name = &quot;drawable&quot; /&gt;
&lt;/declare-styleable&gt;
</code></pre>
<p>（2）属性使用：</p>
<pre><code>&lt;rotate
    xmlns:android = &quot;http://schemas.android.com/apk/res/android&quot;
    android:interpolator = &quot;@anim/动画ID&quot;
    android:fromDegrees = &quot;0&quot;
    android:toDegrees = &quot;360&quot;
    android:pivotX = &quot;200%&quot;
    android:pivotY = &quot;300%&quot;
    android:duration = &quot;5000&quot;
    android:repeatMode = &quot;restart&quot;
    android:repeatCount = &quot;infinite&quot;
    /&gt;
</code></pre>
<h4 id="9-enum：枚举值。"><a href="#9-enum：枚举值。" class="headerlink" title="9. enum：枚举值。"></a>9. enum：枚举值。</h4><p>（1）属性定义：</p>
<pre><code>&lt;declare-styleable name=&quot;名称&quot;&gt;
   &lt;attr name=&quot;orientation&quot;&gt;
      &lt;enum name=&quot;horizontal&quot; value=&quot;0&quot; /&gt;
      &lt;enum name=&quot;vertical&quot; value=&quot;1&quot; /&gt;
   &lt;/attr&gt;           
&lt;/declare-styleable&gt;
</code></pre>
<p>（2）属性使用：</p>
<pre><code>&lt;LinearLayout
    xmlns:android = &quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation = &quot;vertical&quot;
    android:layout_width = &quot;fill_parent&quot;
    android:layout_height = &quot;fill_parent&quot;
    &gt;
&lt;/LinearLayout&gt;
</code></pre>
<h4 id="10-flag：位或运算。"><a href="#10-flag：位或运算。" class="headerlink" title="10. flag：位或运算。"></a>10. flag：位或运算。</h4><p>（1）属性定义：</p>
<pre><code> &lt;declare-styleable name=&quot;名称&quot;&gt;
    &lt;attr name=&quot;windowSoftInputMode&quot;&gt;
        &lt;flag name = &quot;stateUnspecified&quot; value = &quot;0&quot; /&gt;
        &lt;flag name = &quot;stateUnchanged&quot; value = &quot;1&quot; /&gt;
        &lt;flag name = &quot;stateHidden&quot; value = &quot;2&quot; /&gt;
        &lt;flag name = &quot;stateAlwaysHidden&quot; value = &quot;3&quot; /&gt;
        &lt;flag name = &quot;stateVisible&quot; value = &quot;4&quot; /&gt;
        &lt;flag name = &quot;stateAlwaysVisible&quot; value = &quot;5&quot; /&gt;
        &lt;flag name = &quot;adjustUnspecified&quot; value = &quot;0x00&quot; /&gt;
        &lt;flag name = &quot;adjustResize&quot; value = &quot;0x10&quot; /&gt;
        &lt;flag name = &quot;adjustPan&quot; value = &quot;0x20&quot; /&gt;
        &lt;flag name = &quot;adjustNothing&quot; value = &quot;0x30&quot; /&gt;
     &lt;/attr&gt;        
 &lt;/declare-styleable&gt;
</code></pre>
<p>（2）属性使用：</p>
<pre><code>&lt;activity
   android:name = &quot;.StyleAndThemeActivity&quot;
   android:label = &quot;@string/app_name&quot;
   android:windowSoftInputMode = &quot;stateUnspecified | stateUnchanged　|　stateHidden&quot;&gt;
   &lt;intent-filter&gt;
      &lt;action android:name = &quot;android.intent.action.MAIN&quot; /&gt;
      &lt;category android:name = &quot;android.intent.category.LAUNCHER&quot; /&gt;
   &lt;/intent-filter&gt;
 &lt;/activity&gt;
</code></pre>
<h4 id="特别要注意："><a href="#特别要注意：" class="headerlink" title="特别要注意："></a>特别要注意：</h4><p>属性定义时可以指定多种类型值。</p>
<p>（1）属性定义：</p>
<pre><code>&lt;declare-styleable name = &quot;名称&quot;&gt;
   &lt;attr name = &quot;background&quot; format = &quot;reference|color&quot; /&gt;
&lt;/declare-styleable&gt;
</code></pre>
<p>（2）属性使用：</p>
<pre><code> &lt;ImageView
     android:layout_width = &quot;42dip&quot;
     android:layout_height = &quot;42dip&quot;
     android:background = &quot;@drawable/图片ID|#00FF00&quot;
     /&gt;
</code></pre>
]]></content>
      <categories>
        <category>Android教程系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android教程系列</tag>
        <tag>组合控件</tag>
      </tags>
  </entry>
  <entry>
    <title>图片加载库Glide介绍</title>
    <url>/2016/08/09/GlideAbout/</url>
    <content><![CDATA[<blockquote>
<p>英文原文 <a href="https://inthecheesefactory.com/blog/get-to-know-glide-recommended-by-google/en">Introduction to Glide, Image Loader Library for Android, recommended by Google</a><br>摘录来自：<a href="http://jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0327/2650.html">Google推荐的图片加载库Glide介绍</a>  </p>
</blockquote>
<p>在泰国举行的谷歌开发者论坛上，谷歌为我们介绍了一个名叫 Glide 的图片加载库，作者是bumptech。这个库被广泛的运用在google的开源项目中，包括2014年google I/O大会上发布的官方app。<br>它的成功让我非常感兴趣。我花了一整晚的时间把玩，决定分享一些自己的经验。在开始之前我想说，Glide和Picasso有90%的相似度，准确的说，就是Picasso的克隆版本。但是在细节上还是有不少区别的。</p>
<span id="more"></span>

<h2 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h2><p>Picasso和Glide都在jcenter上。在项目中添加依赖非常简单：</p>
<h3 id="Picasso"><a href="#Picasso" class="headerlink" title="Picasso"></a>Picasso</h3><pre><code>dependencies &#123;  
    compile &#39;com.squareup.picasso:picasso:2.5.1&#39;  
&#125;  
</code></pre>
<h3 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h3><pre><code>dependencies &#123;  
    compile &#39;com.github.bumptech.glide:glide:3.5.2&#39;  
    compile &#39;com.android.support:support-v4:22.0.0&#39;  
&#125;  
</code></pre>
<p>Glide需要依赖Support Library v4，别忘了。其实Support Library v4已经是应用程序的标配了，这不是什么问题。  </p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>就如我所说的Glide和Picasso非常相似，Glide加载图片的方法和Picasso如出一辙。  </p>
<h3 id="Picasso-1"><a href="#Picasso-1" class="headerlink" title="Picasso"></a>Picasso</h3><pre><code>Picasso.with(context)  
    .load(&quot;http://inthecheesefactory.com/uploads/source/glidepicasso/cover.jpg&quot;)  
    .into(ivImg);  
</code></pre>
<h3 id="Glide-1"><a href="#Glide-1" class="headerlink" title="Glide"></a>Glide</h3><pre><code>Glide.with(context)  
    .load(&quot;http://inthecheesefactory.com/uploads/source/glidepicasso/cover.jpg&quot;)  
    .into(ivImg);  
</code></pre>
<p>虽然两者看起来一样，但是Glide更易用，因为Glide的with方法不光接受Context，还接受Activity 和 Fragment，Context会自动的从他们获取。<br><img src="http://img.shedoor.net/glide1.png"><br>同时将Activity/Fragment作为with()参数的好处是：图片加载会和Activity/Fragment的生命周期保持一致，比如Paused状态在暂停加载，在Resumed的时候又自动重新加载。所以我建议传参的时候传递Activity 和 Fragment给Glide，而不是Context。  </p>
<h3 id="默认Bitmap格式是RGB-565"><a href="#默认Bitmap格式是RGB-565" class="headerlink" title="默认Bitmap格式是RGB_565"></a>默认Bitmap格式是RGB_565</h3><p>下面是加载图片时和Picasso的比较（1920x1080 像素的图片加载到768x432的ImageView中）<br><img src="http://img.shedoor.net/glide2.jpg"><br>可以看到Glide加载的图片质量要差于Picasso（ps：我看不出来哈），为什么？这是因为Glide默认的Bitmap格式是RGB_565 ，比ARGB_8888格式的内存开销要小一半。下面是Picasso在ARGB8888下与Glide在RGB565下的内存开销图（应用自身占用了8m，因此以8为基准线比较）：<br><img src="http://img.shedoor.net/glide3.png"><br>如果你对默认的RGB_565效果还比较满意，可以不做任何事，但是如果你觉得难以接受，可以创建一个新的GlideModule将Bitmap格式转换到ARGB_8888：  </p>
<pre><code>public class GlideConfiguration implements GlideModule &#123;  

    @Override  
    public void applyOptions(Context context, GlideBuilder builder) &#123;  
        // Apply options to the builder here.  
        builder.setDecodeFormat(DecodeFormat.PREFER_ARGB_8888);  
    &#125;  

    @Override  
    public void registerComponents(Context context, Glide glide) &#123;  
        // register ModelLoaders here.  
    &#125;  
&#125;  
</code></pre>
<p>同时在AndroidManifest.xml中将GlideModule定义为meta-data  </p>
<pre><code>&lt;meta-data  
    android:name=&quot;com.inthecheesefactory.lab.glidepicasso.GlideConfiguration&quot;  
    android:value=&quot;GlideModule&quot;/&gt;  
</code></pre>
<hr>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><img class="width-100percent" src="http://jcodecraeer.com/uploads/20150327/1427445294447874.jpg" alt="quality2" style="border:none; max-width:100%"></p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">这样看起来就会好很多。</p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">我们再来看看内存开销图，这次貌似Glide花费了两倍于上次的内存，但是Picasso的内存开销仍然远大于Glide。</p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><img class="width-100percent" src="http://jcodecraeer.com/uploads/20150327/1427445294918728.png" alt="ram2_1" style="border:none; max-width:100%"></p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">原因在于Picasso是加载了全尺寸的图片到内存，然后让GPU来实时重绘大小。而Glide加载的大小和ImageView的大小是一致的，因此更小。当然，Picasso也可以指定加载的图片大小的：</p><pre class="js" style="white-space:pre-wrap; word-wrap:break-word; color:rgb(51,51,51); font-size:14px; line-height:26px; background-color:rgb(255,255,255)" name="code">Picasso.with(this)  
    .load("http://nuuneoi.com/uploads/source/playstore/cover.jpg")  
    .resize(768, 432)  
    .into(ivImgPicasso);</pre><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">但是问题在于你需要主动计算ImageView的大小，或者说你的ImageView大小是具体的值（而不是wrap_content），你也可以这样：</p><pre class="js" style="white-space:pre-wrap; word-wrap:break-word; color:rgb(51,51,51); font-size:14px; line-height:26px; background-color:rgb(255,255,255)" name="code">Picasso.with(this)  
    .load("http://nuuneoi.com/uploads/source/playstore/cover.jpg")  
    .fit()  
    .centerCrop()  
    .into(ivImgPicasso);</pre><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">现在Picasso的内存开销就和Glide差不多了。</p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><img class="width-100percent" src="http://jcodecraeer.com/uploads/20150327/1427445294433243.png" alt="memory3" style="border:none; max-width:100%"></p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">虽然内存开销差距不到，但是在这个问题上Glide完胜Picasso。因为Glide可以自动计算出任意情况下的ImageView大小。</p><h2 style="margin:0px; padding:0px; color:rgb(51,51,51); font-family:Arial; line-height:26px"><a name="t3"></a><span class="section-heading">Image质量的细节</span></h2><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">这是将ImageView还原到真实大小时的比较。</p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><img class="width-100percent" src="http://jcodecraeer.com/uploads/20150327/1427445294704430.png" alt="quality3" style="border:none; max-width:100%"></p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">你可以看到，Glide加载的图片没有Picasso那么平滑，我还没有找到一个可以直观改变图片大小调整算法的方法。</p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">但是这并不算什么坏事，因为很难察觉。</p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><br></p><h2 style="margin:0px; padding:0px; color:rgb(51,51,51); font-family:Arial; line-height:26px"><a name="t4"></a>磁盘缓存</h2><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">Picasso和Glide在磁盘缓存策略上有很大的不同。Picasso缓存的是全尺寸的，而Glide缓存的是跟ImageView尺寸相同的。</p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><br></p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><img class="width-100percent" src="http://jcodecraeer.com/uploads/20150327/1427445294110987.jpg" alt="cache" style="border:none; max-width:100%"></p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">上面提到的平滑度的问题依然存在，而且如果加载的是RGB565图片，那么缓存中的图片也是RGB565。</p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> </p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">我尝试将ImageView调整成不同大小，但不管大小如何Picasso只缓存一个全尺寸的。Glide则不同，它会为每种大小的ImageView缓存一次。尽管一张图片已经缓存了一次，但是假如你要在另外一个地方再次以不同尺寸显示，需要重新下载，调整成新尺寸的大小，然后将这个尺寸的也缓存起来。</p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">具体说来就是：假如在第一个页面有一个200x200的ImageView，在第二个页面有一个100x100的ImageView，这两个ImageView本来是要显示同一张图片，却需要下载两次。</p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">不过，你可以改变这种行为，让<span style="color:rgb(41,128,185)">Glide</span>既缓存全尺寸又缓存其他尺寸：</p><pre class="js" style="white-space:pre-wrap; word-wrap:break-word; color:rgb(51,51,51); font-size:14px; line-height:26px; background-color:rgb(255,255,255)" name="code">Glide.with(this)  
     .load("http://nuuneoi.com/uploads/source/playstore/cover.jpg")  
     .diskCacheStrategy(DiskCacheStrategy.ALL)  
     .into(ivImgGlide);</pre><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">下次在任何ImageView中加载图片的时候，全尺寸的图片将从缓存中取出，重新调整大小，然后缓存。</p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">Glide的这种方式优点是加载显示非常快。而Picasso的方式则因为需要在显示之前重新调整大小而导致一些延迟，即便你添加了这段代码来让其立即显示：</p><pre class="js" style="white-space:pre-wrap; word-wrap:break-word; color:rgb(51,51,51); font-size:14px; line-height:26px; background-color:rgb(255,255,255)" name="code">//Picasso.noFade();</pre><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><img src="http://jcodecraeer.com/uploads/allimg/150327/163Aa632-0.gif" alt="loading3" style="border:none; max-width:100%; display:block; margin-left:auto; margin-right:auto"></p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><br></p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">Picasso和Glide各有所长，你根据自己的需求选择合适的。</p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">对我而言，我更喜欢Glide，因为它远比Picasso快，虽然需要更大的空间来缓存。</p><br/>


<h2 style="margin:0px; padding:0px; color:rgb(51,51,51); font-family:Arial; line-height:26px"><a name="t7"></a><span class="section-heading">特性<br></span></h2><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">你可以做到几乎和Picasso一样多的事情，代码也几乎一样。</p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>Image Resizing</strong></p><pre class="js" style="white-space:pre-wrap; word-wrap:break-word; color:rgb(51,51,51); font-size:14px; line-height:26px; background-color:rgb(255,255,255)" name="code">// Picasso.resize(300, 200);
// Glide.override(300, 200);</pre><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>Center Cropping</strong></p><pre class="js" style="white-space:pre-wrap; word-wrap:break-word; color:rgb(51,51,51); font-size:14px; line-height:26px; background-color:rgb(255,255,255)" name="code">// Picasso.centerCrop();
// Glide.centerCrop();</pre><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>Transforming</strong></p><pre class="js" style="white-space:pre-wrap; word-wrap:break-word; color:rgb(51,51,51); font-size:14px; line-height:26px; background-color:rgb(255,255,255)" name="code">// Picasso.transform(new CircleTransform())
// Glide.transform(new CircleTransform(context))</pre><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">设置占位图或者加载错误图：</p><pre class="js" style="white-space:pre-wrap; word-wrap:break-word; color:rgb(51,51,51); font-size:14px; line-height:26px; background-color:rgb(255,255,255)" name="code">// Picasso.placeholder(R.drawable.placeholder)
.error(R.drawable.imagenotfound)  
// Glide.placeholder(R.drawable.placeholder)
.error(R.drawable.imagenotfound)</pre><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">几乎和Picasso一样，从Picasso转换到Glide对你来说就是小菜一碟。</p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span class="section-heading"> </span></p><h2 style="margin:0px; padding:0px; color:rgb(51,51,51); font-family:Arial; line-height:26px"><a name="t8"></a><span class="section-heading">有什么Glide可以做而<span class="section-heading">Picasso</span>做不到</span></h2><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">Glide可以加在GIF动态图，而Picasso不能。</p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><img src="http://jcodecraeer.com/uploads/20150327/1427445366503084.gif" alt="gifanimation2" style="border:none; max-width:100%"></p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><br></p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">同时因为Glide和Activity/Fragment的生命周期是一致的，因此gif的动画也会自动的随着Activity/Fragment的状态暂停、重放。Glide 的缓存在gif这里也是一样，调整大小然后缓存。<br></p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">但是从我的一次测试结果来看Glide 动画会消费太多的内存，因此谨慎使用。</p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">除了gif动画之外，Glide还可以将任何的本地视频解码成一张静态图片。</p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">还有一个特性是你可以配置图片显示的动画，而Picasso只有一种动画：fading in。</p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">最后一个是可以使用<code>thumbnail()产生一个你所加载图片的<span style="color:rgb(22,160,133)">thumbnail</span>。</code></p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><code>其实还有一些特性，不过不是非常重要，比如将图像转换成字节数组等。</code></p><h2 style="margin:0px; padding:0px; color:rgb(51,51,51); font-family:Arial; line-height:26px"><a name="t9"></a><code>配置</code></h2><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">有许多可以配置的选项，比如大小，缓存的磁盘位置，最大缓存空间，位图格式等等。可以在这个页面查看这些配置 <code><a target="_blank" href="https://github.com/bumptech/glide/wiki/Configuration" style="color:rgb(51,102,153); text-decoration:none">Configuration</a></code>。<br></p><h2 style="margin:0px; padding:0px; color:rgb(51,51,51); font-family:Arial; line-height:26px"><a name="t10"></a>库的大小</h2><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">Picasso (v2.5.1)的大小约118kb，而Glide (v3.5.2)的大小约430kb。</p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><img class="width-100percent" src="http://jcodecraeer.com/uploads/20150327/1427453389115686.png" alt="librarysize" style="border:none; max-width:100%"></p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">Anyway 312KB difference might not be that significant.</p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">不过312kb的差距并不是很重要。</p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">Picasso和Glide的方法个数分别是840和2678个。</p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><img class="width-100percent" src="http://jcodecraeer.com/uploads/20150327/1427453390188737.png" alt="methodcount" style="border:none; max-width:100%"></p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">必须指出，对于DEX文件65535个方法的限制来说，2678是一个相当大的数字了。建议在使用Glide的时候开启ProGuard。</p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><br></p><h2 style="margin:0px; padding:0px; color:rgb(51,51,51); font-family:Arial; line-height:26px"><a name="t11"></a><span class="section-heading">总结<br></span></h2><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">Glide和Picasso都是非常完美的库。Glide加载图像以及磁盘缓存的方式都要优于Picasso，速度更快，并且Glide更有利于减少OutOfMemoryError的发生，GIF动画是Glide的杀手锏。不过Picasso的图片质量更高。你更喜欢哪个呢？</p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">虽然我使用了很长事件的Picasso，但是我得承认现在我更喜欢Glide。我的建议是使用Glide，但是将Bitmap格式换成 ARGB_8888、让Glide缓存同时缓存全尺寸和改变尺寸两种。</p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> </p><h2 style="margin:0px; padding:0px; color:rgb(51,51,51); font-family:Arial; line-height:26px"><a name="t12"></a>相关资源</h2><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">- <a target="_blank" href="http://google-opensource.blogspot.com/2014/09/glide-30-media-management-library-for.html" style="color:rgb(51,102,153); text-decoration:none">Glide 3.0: a media management library for Android</a></p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">- <a target="_blank" href="https://github.com/bumptech/glide/wiki" style="color:rgb(51,102,153); text-decoration:none">Glide Wiki</a></p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">- <a target="_blank" href="http://pluu.github.io/android%20study/2015/01/15/android-glide-picasso/" style="color:rgb(51,102,153); text-decoration:none">Android Picasso vs Glide</a></p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">- <a target="_blank" href="http://vardhan-justlikethat.blogspot.com/2014/09/android-image-loading-libraries-picasso.html" style="color:rgb(51,102,153); text-decoration:none">Android: Image loading libraries Picasso vs Glide</a></p><br>  
]]></content>
      <categories>
        <category>第三方框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Glide</tag>
        <tag>图片加载</tag>
        <tag>第三方框架</tag>
      </tags>
  </entry>
  <entry>
    <title>OkHttp使用教程</title>
    <url>/2016/08/09/OkHttpUseGuide/</url>
    <content><![CDATA[<blockquote>
<p>摘录来自：<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0106/2275.html">泡网OkHttp使用教程</a></p>
</blockquote>
<p>Android系统提供了两种HTTP通信类，HttpURLConnection和HttpClient。<br><a href="http://android-developers.blogspot.com/2011/09/androids-http-clients.html">关于HttpURLConnection和HttpClient的选择&gt;&gt;官方博客</a><br>尽管Google在大部分安卓版本中推荐使用HttpURLConnection，但是这个类相比HttpClient实在是太难用，太弱爆了。<br>OkHttp是一个相对成熟的解决方案，据说Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp实现了。所以我们更有理由相信OkHttp的强大。</p>
<span id="more"></span>

<p>OkHttp 处理了很多网络疑难杂症：会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP。OkHttp还处理了代理服务器问题和SSL握手失败问题。</p>
<p>使用 OkHttp 无需重写您程序中的网络代码。OkHttp实现了几乎和java.net.HttpURLConnection一样的API。如果你用了 Apache HttpClient，则OkHttp也提供了一个对应的okhttp-apache 模块。</p>
<blockquote>
<p>注：在国内使用OkHttp会因为这个问题导致部分酷派手机用户无法联网，所以对于大众app来说，需要等待这个bug修复后再使用。或者尝试使用OkHttp的老版本。<br>截止到目前，OkHttp一直没有修复，并把修复计划延迟到了OkHttp2.3中。不是所有设备都能重现，仅少量设备会出现这个问题。（如果问题这么明显，OkHttp早就修复了）</p>
</blockquote>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="官方资料"><a href="#官方资料" class="headerlink" title="官方资料"></a>官方资料</h3><p><a href="http://square.github.io/okhttp/">官方介绍</a><br><a href="https://github.com/square/okhttp">github源码</a></p>
<h3 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h3><p>OkHttp支持Android 2.3及其以上版本。<br>对于Java, JDK1.7以上。</p>
<h3 id="jar包准备"><a href="#jar包准备" class="headerlink" title="jar包准备"></a>jar包准备</h3><p>官方介绍页面有链接位置。这里把下载链接也写在下面。<br><a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.okhttp&a=okhttp&v=LATEST">OkHttp</a><br><a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.okio&a=okio&v=LATEST">Okio</a></p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><strong>HTTP GET</strong></p>
<pre><code>OkHttpClient client = new OkHttpClient();

String run(String url) throws IOException &#123;
    Request request = new Request.Builder().url(url).build();
    Response response = client.newCall(request).execute();    
    if (response.isSuccessful()) &#123;        
        return response.body().string();
        &#125; else &#123;
            throw new IOException(&quot;Unexpected code &quot; + response);
        &#125;
    &#125;
</code></pre>
<p>Request是OkHttp中访问的请求，Builder是辅助类。Response即OkHttp中的响应。</p>
<p><strong>Response类：</strong></p>
<pre><code>public boolean isSuccessful()
Returns true if the code is in [200..300),
 which means the request was successfully received, understood, and accepted.
</code></pre>
<p><strong>response.body()返回ResponseBody类</strong><br>可以方便的获取string</p>
<pre><code>public final String string() throws IOException
Returns the response as a string decoded with the charset of the Content-Type header. If that header is either absent or lacks a charset,
 this will attempt to decode the response body as UTF-8.Throws:
IOException
</code></pre>
<p>当然也能获取到流的形式：</p>
<pre><code>public final InputStream byteStream()
</code></pre>
<p><strong>HTTP POST</strong><br><strong>POST提交Json数据</strong></p>
<pre><code>public static final MediaType JSON = MediaType.parse(&quot;application/json; charset=utf-8&quot;);
OkHttpClient client = new OkHttpClient();
String post(String url, String json) throws IOException &#123;
 RequestBody body = RequestBody.create(JSON, json);
  Request request = new Request.Builder()
  .url(url)
  .post(body)
  .build();
  Response response = client.newCall(request).execute();
f (response.isSuccessful()) &#123;
    return response.body().string();
&#125; else &#123;
    throw new IOException(&quot;Unexpected code &quot; + response);
&#125;
&#125;
</code></pre>
<p>使用Request的post方法来提交请求体RequestBody</p>
<p><strong>POST提交键值对</strong><br>很多时候我们会需要通过POST方式把键值对数据传送到服务器。 OkHttp提供了很方便的方式来做这件事情。</p>
<p>OkHttpClient client = new OkHttpClient();<br>String post(String url, String json) throws IOException {</p>
<pre><code> RequestBody formBody = new FormEncodingBuilder()
.add(&quot;platform&quot;, &quot;android&quot;)
.add(&quot;name&quot;, &quot;bug&quot;)
.add(&quot;subject&quot;, &quot;XXXXXXXXXXXXXXX&quot;)
.build();

  Request request = new Request.Builder()
  .url(url)
  .post(body)
  .build();

  Response response = client.newCall(request).execute();
if (response.isSuccessful()) &#123;
    return response.body().string();
&#125; else &#123;
    throw new IOException(&quot;Unexpected code &quot; + response);
&#125;
&#125;
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的例子我们可以发现，OkHttp在很多时候使用都是很方便的，而且很多代码也有重复，因此特地整理了下面的工具类。<br>注意：</p>
<ul>
<li><p>OkHttp官方文档并不建议我们创建多个OkHttpClient，因此全局使用一个。 如果有需要，可以使用clone方法，再进行自定义。这点在后面的高级教程里会提到。</p>
</li>
<li><p>enqueue为OkHttp提供的异步方法，入门教程中并没有提到，后面的高级教程里会有解释。  </p>
<pre><code>  import java.io.IOException;
  import java.util.List;
  import java.util.concurrent.TimeUnit;
  import org.apache.http.client.utils.URLEncodedUtils;
  import org.apache.http.message.BasicNameValuePair;
  import cn.wiz.sdk.constant.WizConstant;
  import com.squareup.okhttp.Callback;
  import com.squareup.okhttp.OkHttpClient;
  import com.squareup.okhttp.Request;
  import com.squareup.okhttp.Response;

  public class OkHttpUtil &#123;
  private static final OkHttpClient mOkHttpClient = new OkHttpClient();
  static&#123;
  mOkHttpClient.setConnectTimeout(30, TimeUnit.SECONDS);
  &#125;
  /**
   * 该不会开启异步线程。
   * @param request
   * @return
   * @throws IOException
       */
      public static Response execute(Request request) throws IOException&#123;
      return mOkHttpClient.newCall(request).execute();
      &#125;
      /**
       * 开启异步线程访问网络
       * @param request
       * @param responseCallback
       */
  public static void enqueue(Request request, Callback responseCallback)&#123;
  mOkHttpClient.newCall(request).enqueue(responseCallback);
  &#125;
  /**
   * 开启异步线程访问网络, 且不在意返回结果（实现空callback）
   * @param request
   */
  public static void enqueue(Request request)&#123;
  mOkHttpClient.newCall(request).enqueue(new Callback() &#123;

  @Override
  public void onResponse(Response arg0) throws IOException &#123;

  &#125;

  @Override
  public void onFailure(Request arg0, IOException arg1) &#123;

  &#125;
  &#125;);
  &#125;
  public static String getStringFromServer(String url) throws IOException&#123;
  Request request = new Request.Builder().url(url).build();
  Response response = execute(request);
  if (response.isSuccessful()) &#123;
  String responseUrl = response.body().string();
  return responseUrl;
  &#125; else &#123;
  throw new IOException(&quot;Unexpected code &quot; + response);
  &#125;
  &#125;
  private static final String CHARSET_NAME = &quot;UTF-8&quot;;
  /**
   * 这里使用了HttpClinet的API。只是为了方便
   * @param params
   * @return
   */
  public static String formatParams(List&lt;BasicNameValuePair&gt; params)&#123;
  return URLEncodedUtils.format(params, CHARSET_NAME);
  &#125;
  /**
   * 为HttpGet 的 url 方便的添加多个name value 参数。
   * @param url
   * @param params
   * @return
   */
  public static String attachHttpGetParams(String url, List&lt;BasicNameValuePair&gt; params)&#123;
  return url + &quot;?&quot; + formatParams(params);
  &#125;
  /**
   * 为HttpGet 的 url 方便的添加1个name value 参数。
   * @param url
   * @param name
   * @param value
   * @return
   */
  public static String attachHttpGetParam(String url, String name, String value)&#123;
  return url + &quot;?&quot; + name + &quot;=&quot; + value;
  &#125;
  &#125;  
</code></pre>
</li>
</ul>
<h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><p>高级属性其实用的不多，这里主要是对OkHttp github官方教程进行了翻译。</p>
<h3 id="同步get"><a href="#同步get" class="headerlink" title="同步get"></a><strong>同步get</strong></h3><p>下载一个文件，打印他的响应头，以string形式打印响应体。<br>响应体的 string() 方法对于小文档来说十分方便、高效。但是如果响应体太大（超过1MB），应避免适应 string()方法 ，因为他会将把整个文档加载到内存中。<br>对于超过1MB的响应body，应使用流的方式来处理body。</p>
<pre><code>private final OkHttpClient client = new OkHttpClient();

public void run() throws Exception &#123;
Request request = new Request.Builder()
    .url(&quot;http://publicobject.com/helloworld.txt&quot;)
    .build();

Response response = client.newCall(request).execute();
if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);

Headers responseHeaders = response.headers();
for (int i = 0; i &lt; responseHeaders.size(); i++) &#123;
  System.out.println(responseHeaders.name(i) + &quot;: &quot; + responseHeaders.value(i));
&#125;

System.out.println(response.body().string());
&#125;
</code></pre>
<h3 id="异步get"><a href="#异步get" class="headerlink" title="异步get"></a><strong>异步get</strong></h3><p>在一个工作线程中下载文件，当响应可读时回调Callback接口。读取响应时会阻塞当前线程。OkHttp现阶段不提供异步api来接收响应体。</p>
<pre><code>private final OkHttpClient client = new OkHttpClient();

public void run() throws Exception &#123;
Request request = new Request.Builder()
    .url(&quot;http://publicobject.com/helloworld.txt&quot;)
    .build();

client.newCall(request).enqueue(new Callback() &#123;
  @Override public void onFailure(Request request, Throwable throwable) &#123;
    throwable.printStackTrace();
  &#125;

  @Override public void onResponse(Response response) throws IOException &#123;
    if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);

    Headers responseHeaders = response.headers();
    for (int i = 0; i &lt; responseHeaders.size(); i++) &#123;
      System.out.println(responseHeaders.name(i) + &quot;: &quot; + responseHeaders.value(i));
    &#125;

    System.out.println(response.body().string());
  &#125;
&#125;);
&#125;
</code></pre>
<h3 id="提取响应头"><a href="#提取响应头" class="headerlink" title="提取响应头"></a><strong>提取响应头</strong></h3><p>典型的HTTP头 像是一个 Map&lt;String, String&gt; :每个字段都有一个或没有值。但是一些头允许多个值，像Guava的Multimap。例如：HTTP响应里面提供的Vary响应头，就是多值的。OkHttp的api试图让这些情况都适用。<br>当写请求头的时候，使用header(name, value)可以设置唯一的name、value。如果已经有值，旧的将被移除，然后添加新的。使用addHeader(name, value)可以添加多值（添加，不移除已有的）。<br>当读取响应头时，使用header(name)返回最后出现的name、value。通常情况这也是唯一的name、value。如果没有值，那么header(name)将返回null。如果想读取字段对应的所有值，使用headers(name)会返回一个list。<br>为了获取所有的Header，Headers类支持按index访问。  </p>
<pre><code>private final OkHttpClient client = new OkHttpClient();

public void run() throws Exception &#123;
Request request = new Request.Builder()
    .url(&quot;https://api.github.com/repos/square/okhttp/issues&quot;)
    .header(&quot;User-Agent&quot;, &quot;OkHttp Headers.java&quot;)
    .addHeader(&quot;Accept&quot;, &quot;application/json; q=0.5&quot;)
    .addHeader(&quot;Accept&quot;, &quot;application/vnd.github.v3+json&quot;)
    .build();

Response response = client.newCall(request).execute();
if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);

System.out.println(&quot;Server: &quot; + response.header(&quot;Server&quot;));
System.out.println(&quot;Date: &quot; + response.header(&quot;Date&quot;));
System.out.println(&quot;Vary: &quot; + response.headers(&quot;Vary&quot;));
&#125;
</code></pre>
<h3 id="Post方式提交String"><a href="#Post方式提交String" class="headerlink" title="Post方式提交String"></a><strong>Post方式提交String</strong></h3><p>使用HTTP POST提交请求到服务。这个例子提交了一个markdown文档到web服务，以HTML方式渲染markdown。因为整个请求体都在内存中，因此避免使用此api提交大文档（大于1MB）。</p>
<pre><code>public static final MediaType MEDIA_TYPE_MARKDOWN
  = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;);

private final OkHttpClient client = new OkHttpClient();

public void run() throws Exception &#123;
String postBody = &quot;&quot;
    + &quot;Releases\n&quot;
    + &quot;--------\n&quot;
    + &quot;\n&quot;
    + &quot; * _1.0_ May 6, 2013\n&quot;
    + &quot; * _1.1_ June 15, 2013\n&quot;
    + &quot; * _1.2_ August 11, 2013\n&quot;;

Request request = new Request.Builder()
    .url(&quot;https://api.github.com/markdown/raw&quot;)
    .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))
    .build();

Response response = client.newCall(request).execute();
if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);

System.out.println(response.body().string());
&#125;
</code></pre>
<h3 id="Post方式提交流"><a href="#Post方式提交流" class="headerlink" title="Post方式提交流"></a><strong>Post方式提交流</strong></h3><p>以流的方式POST提交请求体。请求体的内容由流写入产生。这个例子是流直接写入Okio的BufferedSink。你的程序可能会使用OutputStream，你可以使用BufferedSink.outputStream()来获取。</p>
<pre><code>public static final MediaType MEDIA_TYPE_MARKDOWN
  = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;);

private final OkHttpClient client = new OkHttpClient();

public void run() throws Exception &#123;
RequestBody requestBody = new RequestBody() &#123;
  @Override public MediaType contentType() &#123;
    return MEDIA_TYPE_MARKDOWN;
  &#125;

  @Override public void writeTo(BufferedSink sink) throws IOException &#123;
    sink.writeUtf8(&quot;Numbers\n&quot;);
    sink.writeUtf8(&quot;-------\n&quot;);
    for (int i = 2; i &lt;= 997; i++) &#123;
      sink.writeUtf8(String.format(&quot; * %s = %s\n&quot;, i, factor(i)));
    &#125;
  &#125;

  private String factor(int n) &#123;
    for (int i = 2; i &lt; n; i++) &#123;
      int x = n / i;
      if (x * i == n) return factor(x) + &quot; × &quot; + i;
    &#125;
    return Integer.toString(n);
  &#125;
&#125;;

Request request = new Request.Builder()
    .url(&quot;https://api.github.com/markdown/raw&quot;)
    .post(requestBody)
    .build();

Response response = client.newCall(request).execute();
if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);

System.out.println(response.body().string());
&#125;
</code></pre>
<h3 id="Post方式提交文件"><a href="#Post方式提交文件" class="headerlink" title="Post方式提交文件"></a><strong>Post方式提交文件</strong></h3><p>以文件作为请求体是十分简单的。</p>
<pre><code>public static final MediaType MEDIA_TYPE_MARKDOWN
    = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;);

private final OkHttpClient client = new OkHttpClient();

public void run() throws Exception &#123;
File file = new File(&quot;README.md&quot;);

Request request = new Request.Builder()
    .url(&quot;https://api.github.com/markdown/raw&quot;)
    .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))
    .build();

Response response = client.newCall(request).execute();
if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);

System.out.println(response.body().string());
&#125;
</code></pre>
<h3 id="Post方式提交表单"><a href="#Post方式提交表单" class="headerlink" title="Post方式提交表单"></a><strong>Post方式提交表单</strong></h3><p>使用FormEncodingBuilder来构建和HTML<form>标签相同效果的请求体。键值对将使用一种HTML兼容形式的URL编码来进行编码。</p>
<pre><code>private final OkHttpClient client = new OkHttpClient();

public void run() throws Exception &#123;
RequestBody formBody = new FormEncodingBuilder()
    .add(&quot;search&quot;, &quot;Jurassic Park&quot;)
    .build();
Request request = new Request.Builder()
    .url(&quot;https://en.wikipedia.org/w/index.php&quot;)
    .post(formBody)
    .build();

Response response = client.newCall(request).execute();
if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);

System.out.println(response.body().string());
&#125;
</code></pre>
<h3 id="Post方式提交分块请求"><a href="#Post方式提交分块请求" class="headerlink" title="Post方式提交分块请求"></a><strong>Post方式提交分块请求</strong></h3><p>MultipartBuilder可以构建复杂的请求体，与HTML文件上传形式兼容。多块请求体中每块请求都是一个请求体，可以定义自己的请求头。这些请求头可以用来描述这块请求，例如他的Content-Disposition。如果Content-Length和Content-Type可用的话，他们会被自动添加到请求头中。</p>
<pre><code>private static final String IMGUR_CLIENT_ID = &quot;...&quot;;
private static final MediaType MEDIA_TYPE_PNG = MediaType.parse(&quot;image/png&quot;);

private final OkHttpClient client = new OkHttpClient();

public void run() throws Exception &#123;
// Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image
RequestBody requestBody = new MultipartBuilder()
    .type(MultipartBuilder.FORM)
    .addPart(
        Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name=\&quot;title\&quot;&quot;),
        RequestBody.create(null, &quot;Square Logo&quot;))
    .addPart(
        Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name=\&quot;image\&quot;&quot;),
        RequestBody.create(MEDIA_TYPE_PNG, new File(&quot;website/static/logo-square.png&quot;)))
    .build();

Request request = new Request.Builder()
    .header(&quot;Authorization&quot;, &quot;Client-ID &quot; + IMGUR_CLIENT_ID)
    .url(&quot;https://api.imgur.com/3/image&quot;)
    .post(requestBody)
    .build();

Response response = client.newCall(request).execute();
if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);

System.out.println(response.body().string());
&#125;
</code></pre>
<h3 id="使用Gson来解析JSON响应"><a href="#使用Gson来解析JSON响应" class="headerlink" title="使用Gson来解析JSON响应"></a><strong>使用Gson来解析JSON响应</strong></h3><p>Gson是一个在JSON和Java对象之间转换非常方便的api。这里我们用Gson来解析Github API的JSON响应。  </p>
<blockquote>
<p>注意：ResponseBody.charStream()使用响应头Content-Type指定的字符集来解析响应体。默认是UTF-8。  </p>
</blockquote>
<pre><code>private final OkHttpClient client = new OkHttpClient();
private final Gson gson = new Gson();

public void run() throws Exception &#123;
Request request = new Request.Builder()
    .url(&quot;https://api.github.com/gists/c2a7c39532239ff261be&quot;)
    .build();
Response response = client.newCall(request).execute();
if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);

Gist gist = gson.fromJson(response.body().charStream(), Gist.class);
for (Map.Entry&lt;String, GistFile&gt; entry : gist.files.entrySet()) &#123;
  System.out.println(entry.getKey());
  System.out.println(entry.getValue().content);
&#125;
&#125;

static class Gist &#123;
Map&lt;String, GistFile&gt; files;
&#125;

static class GistFile &#123;
String content;
&#125;
</code></pre>
<h3 id="响应缓存"><a href="#响应缓存" class="headerlink" title="响应缓存"></a><strong>响应缓存</strong></h3><p>为了缓存响应，你需要一个你可以读写的缓存目录，和缓存大小的限制。这个缓存目录应该是私有的，不信任的程序应不能读取缓存内容。<br>一个缓存目录同时拥有多个缓存访问是错误的。大多数程序只需要调用一次new OkHttp()，在第一次调用时配置好缓存，然后其他地方只需要调用这个实例就可以了。否则两个缓存示例互相干扰，破坏响应缓存，而且有可能会导致程序崩溃。<br>响应缓存使用HTTP头作为配置。你可以在请求头中添加Cache-Control: max-stale=3600 ,OkHttp缓存会支持。你的服务通过响应头确定响应缓存多长时间，例如使用Cache-Control: max-age=9600。  </p>
<pre><code>private final OkHttpClient client;

public CacheResponse(File cacheDirectory) throws Exception &#123;
int cacheSize = 10 * 1024 * 1024; // 10 MiB
Cache cache = new Cache(cacheDirectory, cacheSize);

client = new OkHttpClient();
client.setCache(cache);
&#125;

public void run() throws Exception &#123;
Request request = new Request.Builder()
    .url(&quot;http://publicobject.com/helloworld.txt&quot;)
    .build();

Response response1 = client.newCall(request).execute();
if (!response1.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response1);

String response1Body = response1.body().string();
System.out.println(&quot;Response 1 response:          &quot; + response1);
System.out.println(&quot;Response 1 cache response:    &quot; + response1.cacheResponse());
System.out.println(&quot;Response 1 network response:  &quot; + response1.networkResponse());

Response response2 = client.newCall(request).execute();
if (!response2.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response2);

String response2Body = response2.body().string();
System.out.println(&quot;Response 2 response:          &quot; + response2);
System.out.println(&quot;Response 2 cache response:    &quot; + response2.cacheResponse());
System.out.println(&quot;Response 2 network response:  &quot; + response2.networkResponse());

System.out.println(&quot;Response 2 equals Response 1? &quot; + response1Body.equals(response2Body));
&#125;
</code></pre>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a><strong>扩展</strong></h2><p>在这一节还提到了下面一句：<br>    There are cache headers to force a cached response, force a network response, or force the network response to be validated with a conditional GET.  </p>
<p>我不是很懂cache，平时用到的也不多，所以把Google在Android Developers一段相关的解析放到这里吧。  </p>
<p><strong>Force a Network Response</strong><br>In some situations, such as after a user clicks a ‘refresh’ button, it may be necessary to skip the cache, and fetch data directly from the server. To force a full refresh, add the no-cache directive:</p>
<pre><code>connection.addRequestProperty(&quot;Cache-Control&quot;, &quot;no-cache&quot;);
</code></pre>
<p>If it is only necessary to force a cached response to be validated by the server, use the more efficient max-age=0 instead:</p>
<pre><code>connection.addRequestProperty(&quot;Cache-Control&quot;, &quot;max-age=0&quot;);
</code></pre>
<p><strong>Force a Cache Response</strong><br>Sometimes you’ll want to show resources if they are available immediately, but not otherwise. This can be used so your application can show something while waiting for the latest data to be downloaded. To restrict a request to locally-cached resources, add the only-if-cached directive:</p>
<pre><code>try &#123;
 connection.addRequestProperty(&quot;Cache-Control&quot;, &quot;only-if-cached&quot;);
 InputStream cached = connection.getInputStream();
 // the resource was cached! show it
catch (FileNotFoundException e) &#123;
 // the resource was not cached
 &#125;
&#125;
</code></pre>
<p>This technique works even better in situations where a stale response is better than no response. To permit stale cached responses, use the max-stale directive with the maximum staleness in seconds:</p>
<pre><code>int maxStale = 60 * 60 * 24 * 28; // tolerate 4-weeks staleconnection.addRequestProperty(&quot;Cache-Control&quot;, &quot;max-stale=&quot; + maxStale);
</code></pre>
<blockquote>
<p>以上信息来自：<a href="http://developer.android.com/reference/android/net/http/HttpResponseCache.html">HttpResponseCache - Android SDK | Android Developers</a>  </p>
</blockquote>
<h3 id="取消一个Call"><a href="#取消一个Call" class="headerlink" title="取消一个Call"></a><strong>取消一个Call</strong></h3><p>使用Call.cancel()可以立即停止掉一个正在执行的call。如果一个线程正在写请求或者读响应，将会引发IOException。当call没有必要的时候，使用这个api可以节约网络资源。例如当用户离开一个应用时。不管同步还是异步的call都可以取消。<br>你可以通过tags来同时取消多个请求。当你构建一请求时，使用RequestBuilder.tag(tag)来分配一个标签。之后你就可以用OkHttpClient.cancel(tag)来取消所有带有这个tag的call。</p>
<pre><code>private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
private final OkHttpClient client = new OkHttpClient();

public void run() throws Exception &#123;
Request request = new Request.Builder()
    .url(&quot;http://httpbin.org/delay/2&quot;) // This URL is served with a 2 second delay.
    .build();

final long startNanos = System.nanoTime();
final Call call = client.newCall(request);

// Schedule a job to cancel the call in 1 second.
executor.schedule(new Runnable() &#123;
  @Override public void run() &#123;
    System.out.printf(&quot;%.2f Canceling call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f);
    call.cancel();
    System.out.printf(&quot;%.2f Canceled call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f);
  &#125;
&#125;, 1, TimeUnit.SECONDS);

try &#123;
  System.out.printf(&quot;%.2f Executing call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f);
  Response response = call.execute();
  System.out.printf(&quot;%.2f Call was expected to fail, but completed: %s%n&quot;,
      (System.nanoTime() - startNanos) / 1e9f, response);
&#125; catch (IOException e) &#123;
  System.out.printf(&quot;%.2f Call failed as expected: %s%n&quot;,
      (System.nanoTime() - startNanos) / 1e9f, e);
&#125;
&#125;
</code></pre>
<h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a><strong>超时</strong></h3><p>没有响应时使用超时结束call。没有响应的原因可能是客户点链接问题、服务器可用性问题或者这之间的其他东西。OkHttp支持连接，读取和写入超时。</p>
<pre><code>private final OkHttpClient client;

public ConfigureTimeouts() throws Exception &#123;
client = new OkHttpClient();
client.setConnectTimeout(10, TimeUnit.SECONDS);
client.setWriteTimeout(10, TimeUnit.SECONDS);
client.setReadTimeout(30, TimeUnit.SECONDS);
&#125;

public void run() throws Exception &#123;
Request request = new Request.Builder()
    .url(&quot;http://httpbin.org/delay/2&quot;) // This URL is served with a 2 second delay.
    .build();

Response response = client.newCall(request).execute();
System.out.println(&quot;Response completed: &quot; + response);
&#125;
</code></pre>
<h3 id="每个call的配置"><a href="#每个call的配置" class="headerlink" title="每个call的配置"></a><strong>每个call的配置</strong></h3><p>使用OkHttpClient，所有的HTTP Client配置包括代理设置、超时设置、缓存设置。当你需要为单个call改变配置的时候，clone 一个 OkHttpClient。这个api将会返回一个浅拷贝（shallow copy），你可以用来单独自定义。下面的例子中，我们让一个请求是500ms的超时、另一个是3000ms的超时。</p>
<pre><code>private final OkHttpClient client = new OkHttpClient();

public void run() throws Exception &#123;
Request request = new Request.Builder()
    .url(&quot;http://httpbin.org/delay/1&quot;) // This URL is served with a 1 second delay.
    .build();

try &#123;
  Response response = client.clone() // Clone to make a customized OkHttp for this request.
      .setReadTimeout(500, TimeUnit.MILLISECONDS)
      .newCall(request)
      .execute();
  System.out.println(&quot;Response 1 succeeded: &quot; + response);
&#125; catch (IOException e) &#123;
  System.out.println(&quot;Response 1 failed: &quot; + e);
&#125;

try &#123;
  Response response = client.clone() // Clone to make a customized OkHttp for this request.
      .setReadTimeout(3000, TimeUnit.MILLISECONDS)
      .newCall(request)
      .execute();
  System.out.println(&quot;Response 2 succeeded: &quot; + response);
&#125; catch (IOException e) &#123;
  System.out.println(&quot;Response 2 failed: &quot; + e);
&#125;
&#125;
</code></pre>
<h3 id="处理验证"><a href="#处理验证" class="headerlink" title="处理验证"></a><strong>处理验证</strong></h3><p>这部分和HTTP AUTH有关。  </p>
<blockquote>
<p>相关资料：<a href="http://blog.csdn.net/wwwsq/article/details/7255062">HTTP AUTH 那些事 - 王绍全的博客 - 博客频道 - CSDN.NET</a></p>
</blockquote>
<p>OkHttp会自动重试未验证的请求。当响应是401 Not Authorized时，Authenticator会被要求提供证书。Authenticator的实现中需要建立一个新的包含证书的请求。如果没有证书可用，返回null来跳过尝试。</p>
<pre><code>public List&lt;Challenge&gt; challenges()
Returns the authorization challenges appropriate for this response&#39;s code.
If the response code is 401 unauthorized,
this returns the &quot;WWW-Authenticate&quot; challenges.
If the response code is 407 proxy unauthorized, this returns the &quot;Proxy-Authenticate&quot; challenges.
Otherwise this returns an empty list of challenges.
</code></pre>
<p>当需要实现一个Basic challenge， 使用Credentials.basic(username, password)来编码请求头。</p>
<pre><code>private final OkHttpClient client = new OkHttpClient();

public void run() throws Exception &#123;
client.setAuthenticator(new Authenticator() &#123;
  @Override public Request authenticate(Proxy proxy, Response response) &#123;
    System.out.println(&quot;Authenticating for response: &quot; + response);
    System.out.println(&quot;Challenges: &quot; + response.challenges());
    String credential = Credentials.basic(&quot;jesse&quot;, &quot;password1&quot;);
    return response.request().newBuilder()
        .header(&quot;Authorization&quot;, credential)
        .build();
  &#125;

  @Override public Request authenticateProxy(Proxy proxy, Response response) &#123;
    return null; // Null indicates no attempt to authenticate.
  &#125;
&#125;);

Request request = new Request.Builder()
    .url(&quot;http://publicobject.com/secrets/hellosecret.txt&quot;)
    .build();

Response response = client.newCall(request).execute();
if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);

System.out.println(response.body().string());
&#125;
</code></pre>
<blockquote>
<p>转自 <a href="http://www.cnblogs.com/ct2011/p/4001708.html">OkHttp使用介绍</a> 同时整合了 <a href="http://www.cnblogs.com/ct2011/p/3997368.html">OkHttp使用进阶</a> 这篇文章以及其中的评论。</p>
</blockquote>
]]></content>
      <categories>
        <category>第三方框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>第三方框架</tag>
        <tag>OkHttp</tag>
      </tags>
  </entry>
  <entry>
    <title>ORMLite框架实践详解</title>
    <url>/2016/08/12/OrmLiteAbout/</url>
    <content><![CDATA[<p>大家在Android项目中或多或少的都会使用数据库，为了提高我们的开发效率，当然少不了数据库ORM框架了，尤其是某些数据库操作特别频繁的app；本篇博客将通过一个实例来详细介绍ORMLite  </p>
<span id="more"></span>

<h2 id="1、下载-ORMLite-Jar"><a href="#1、下载-ORMLite-Jar" class="headerlink" title="1、下载 ORMLite Jar"></a>1、下载 ORMLite Jar</h2><p>首先去<a href="http://ormlite.com/releases/">ORMLite官网</a>下载jar包，对于Android为：ormlite-android-5.0.jar 和 ormlite-core-5.0.jar；<br>如果你使用的开发工具是Eclipse的话，有了jar,然后把jar拷贝到libs下，然后右键点击jar包点击add Libary(即添加依赖)。<br>如果你使用的开发工具是Android Studio的话，只需要在build.gradle文件里引入包就行了：  </p>
<pre><code>compile &#39;com.j256.ormlite:ormlite-android:5.0&#39;
compile &#39;com.j256.ormlite:ormlite-core:5.0&#39;
</code></pre>
<blockquote>
<p>访问不了的朋友，这里会把jar、源码、doc与本篇博客例子一起打包提供给大家<a href="http://img.shedoor.net/zhy_ormlite.rar">下载</a>。</p>
</blockquote>
<h2 id="2、配置Bean类"><a href="#2、配置Bean类" class="headerlink" title="2、配置Bean类"></a>2、配置Bean类</h2><p>我们直接新建一个项目为：zhy_ormlite。<br>然后新建一个包：com.zhy.zhy_ormlite.bean专门用于存放项目中的Bean，首先新建一个User.java</p>
<pre><code>package com.zhy.zhy_ormlite.bean;

import java.util.Collection;

import com.j256.ormlite.field.DatabaseField;
import com.j256.ormlite.field.ForeignCollectionField;
import com.j256.ormlite.table.DatabaseTable;

@DatabaseTable(tableName = &quot;tb_user&quot;)
public class User
&#123;
    @DatabaseField(generatedId = true)
    private int id;
    @DatabaseField(columnName = &quot;name&quot;)
    private String name;

    @ForeignCollectionField
    private Collection&lt;Article&gt; articles;

    public Collection&lt;Article&gt; getArticles()
    &#123;
        return articles;
    &#125;

    public void setArticles(Collection&lt;Article&gt; articles)
    &#123;
        this.articles = articles;
    &#125;

    public User()
    &#123;
    &#125;

    public int getId()
    &#123;
        return id;
    &#125;

    public void setId(int id)
    &#123;
        this.id = id;
    &#125;

    public String getName()
    &#123;
        return name;
    &#125;

    public void setName(String name)
    &#123;
        this.name = name;
    &#125;

    @Override
    public String toString()
    &#123;
        return &quot;User [id=&quot; + id + &quot;, name=&quot; + name + &quot;, articles=&quot; + articles
                + &quot;]&quot;;
    &#125;

&#125;
</code></pre>
<ul>
<li>首先在User类上添加@DatabaseTable(tableName = “tb_user”)，标明这是数据库中的一张表，标明为tb_user</li>
<li>然后分别在属性上添加@DatabaseField(columnName = “name”) ，columnName的值为该字段在数据中的列名</li>
<li>@DatabaseField(generatedId = true) ，generatedId 表示id为主键且自动生成</li>
</ul>
<h2 id="3、ORMLite外键引用"><a href="#3、ORMLite外键引用" class="headerlink" title="3、ORMLite外键引用"></a>3、ORMLite外键引用</h2><p>现在我们有两张表一张User，一张Article；<br>Article中当然需要存储User的主键，作为关联~~那么在ORMLite中如何做到呢？<br>可能有人会直接在Article中声明一个int类型userId属性，当作普通属性处理搞定，这种做法并没有做，但是没有体现出面向对象的思想。<br>面向对象是这样的：Article属于某个User<br>类这么定义：</p>
<pre><code>  1. package com.zhy.zhy_ormlite.bean;  
  2.   
  3. import com.j256.ormlite.field.DatabaseField;  
  4. import com.j256.ormlite.table.DatabaseTable;  
  5.   
  6. @DatabaseTable(tableName = &quot;tb_article&quot;)  
  7. public class Article  
  8. &#123;  
  9.     @DatabaseField(generatedId = true)  
  10.     private int id;  
  11.     @DatabaseField  
  12.     private String title;  
  13.     @DatabaseField(canBeNull = true, foreign = true, columnName = &quot;user_id&quot;)  
  14.     private User user;  
  15.   
  16.     public int getId()  
  17.     &#123;  
  18.         return id;  
  19.     &#125;  
  20.   
  21.     public void setId(int id)  
  22.     &#123;  
  23.         this.id = id;  
  24.     &#125;  
  25.   
  26.     public String getTitle()  
  27.     &#123;  
  28.         return title;  
  29.     &#125;  
  30.   
  31.     public void setTitle(String title)  
  32.     &#123;  
  33.         this.title = title;  
  34.     &#125;  
  35.   
  36.     public User getUser()  
  37.     &#123;  
  38.         return user;  
  39.     &#125;  
  40.   
  41.     public void setUser(User user)  
  42.     &#123;  
  43.         this.user = user;  
  44.     &#125;  
  45.   
  46.     @Override  
  47.     public String toString()  
  48.     &#123;  
  49.         return &quot;Article [id=&quot; + id + &quot;, title=&quot; + title + &quot;, user=&quot; + user  
  50.                 + &quot;]&quot;;  
  51.     &#125;  
  52.   
  53. &#125;  
</code></pre>
<p>不会去定义一个int类型的userId，而是直接定义一个User成员变量，表示本Article属于该User;<br>然后在User user属性上添加：</p>
<pre><code>@DatabaseField(canBeNull = true, foreign = true, columnName = &quot;user_id&quot;)
</code></pre>
<blockquote>
<ul>
<li>canBeNull表示不能为null；</li>
<li>foreign=true表示是一个外键;</li>
<li>columnName 列名</li>
</ul>
</blockquote>
<h2 id="4、编写DAO类"><a href="#4、编写DAO类" class="headerlink" title="4、编写DAO类"></a>4、编写DAO类</h2><p>我们可能会有很多表嘛，每个表一般我们都会单独写个Dao用于操作</p>
<pre><code>public class UserDao
&#123;
    private Context context;
    private Dao&lt;User, Integer&gt; userDaoOpe;
    private DatabaseHelper helper;

    public UserDao(Context context)
    &#123;
        this.context = context;
        try
        &#123;
            helper = DatabaseHelper.getHelper(context);
            userDaoOpe = helper.getDao(User.class);
        &#125; catch (SQLException e)
        &#123;
            e.printStackTrace();
        &#125;
    &#125;

    /**
     * 增加一个用户
     *
     * @param user
     * @throws SQLException
     */
    public void add(User user)
    &#123;
        /*//事务操作
        TransactionManager.callInTransaction(helper.getConnectionSource(),
                new Callable&lt;Void&gt;()
                &#123;

                    @Override
                    public Void call() throws Exception
                    &#123;
                        return null;
                    &#125;
                &#125;);*/
        try
        &#123;
            userDaoOpe.create(user);
        &#125; catch (SQLException e)
        &#123;
            e.printStackTrace();
        &#125;

    &#125;

    public User get(int id)
    &#123;
        try
        &#123;
            return userDaoOpe.queryForId(id);
        &#125; catch (SQLException e)
        &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;

&#125;
</code></pre>
<p>我们的所有的XXXDao遵循以上的风格~</p>
<pre><code>public class ArticleDao &#123;
    private Dao&lt;Article, Integer&gt; articleDaoOpe;
    private DatabaseHelper helper;

    @SuppressWarnings(&quot;unchecked&quot;)
    public ArticleDao(Context context) &#123;
        try &#123;
            helper = DatabaseHelper.getHelper(context);
            articleDaoOpe = helper.getDao(Article.class);
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    /**
     * 添加一个Article
     *
     * @param article
     */
    public void add(Article article) &#123;
        try &#123;
            articleDaoOpe.create(article);
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    /**
     * 通过Id得到一个Article
     *
     * @param id
     * @return
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public Article getArticleWithUser(int id) &#123;
        Article article = null;
        try &#123;
            article = articleDaoOpe.queryForId(id);
            helper.getDao(User.class).refresh(article.getUser());

        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
        return article;
    &#125;

    /**
     * 通过Id得到一篇文章
     *
     * @param id
     * @return
     */
    public Article get(int id) &#123;
        Article article = null;
        try &#123;
            article = articleDaoOpe.queryForId(id);

        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
        return article;
    &#125;

    /**
     * 通过UserId获取所有的文章
     *
     * @param userId
     * @return
     */
    public List&lt;Article&gt; listByUserId(int userId) &#123;
        try &#123;
            return articleDaoOpe.queryBuilder().where().eq(&quot;user_id&quot;, userId)
                    .query();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;
</code></pre>
<hr>
<h2 id="4、DatabaseHelper"><a href="#4、DatabaseHelper" class="headerlink" title="4、DatabaseHelper"></a>4、DatabaseHelper</h2><p>我们使用ORMLite，需要自己写一个DatabaseHelper去继承OrmLiteSqliteOpenHelper，下面我们首先给出一个我认为比较靠谱的Helper的写法：</p>
<pre><code>  1. package com.zhy.zhy_ormlite.db;  
  2.   
  3. import java.sql.SQLException;  
  4. import java.util.HashMap;  
  5. import java.util.Map;  
  6.   
  7. import android.content.Context;  
  8. import android.database.sqlite.SQLiteDatabase;  
  9.   
  10. import com.j256.ormlite.android.apptools.OrmLiteSqliteOpenHelper;  
  11. import com.j256.ormlite.dao.Dao;  
  12. import com.j256.ormlite.support.ConnectionSource;  
  13. import com.j256.ormlite.table.TableUtils;  
  14. import com.zhy.zhy_ormlite.bean.Article;  
  15. import com.zhy.zhy_ormlite.bean.Student;  
  16. import com.zhy.zhy_ormlite.bean.User;  
  17.   
  18. public  class DatabaseHelper extends OrmLiteSqliteOpenHelper  
  19. &#123;  
  20.     private static final String TABLE_NAME = &quot;sqlite-test.db&quot;;  
  21.   
  22.     private Map&lt;String, Dao&gt; daos = new HashMap&lt;String, Dao&gt;();  
  23.   
  24.     private DatabaseHelper(Context context)  
  25.     &#123;  
  26.         super(context, TABLE_NAME, null, 4);  
  27.     &#125;  
  28.   
  29.     @Override  
  30.     public void onCreate(SQLiteDatabase database,  
  31.             ConnectionSource connectionSource)  
  32.     &#123;  
  33.         try  
  34.         &#123;  
  35.             TableUtils.createTable(connectionSource, User.class);  
  36.             TableUtils.createTable(connectionSource, Article.class);  
  37.             TableUtils.createTable(connectionSource, Student.class);  
  38.         &#125; catch (SQLException e)  
  39.         &#123;  
  40.             e.printStackTrace();  
  41.         &#125;  
  42.     &#125;  
  43.   
  44.     @Override  
  45.     public void onUpgrade(SQLiteDatabase database,  
  46.             ConnectionSource connectionSource, int oldVersion, int newVersion)  
  47.     &#123;  
  48.         try  
  49.         &#123;  
  50.             TableUtils.dropTable(connectionSource, User.class, true);  
  51.             TableUtils.dropTable(connectionSource, Article.class, true);  
  52.             TableUtils.dropTable(connectionSource, Student.class, true);  
  53.             onCreate(database, connectionSource);  
  54.         &#125; catch (SQLException e)  
  55.         &#123;  
  56.             e.printStackTrace();  
  57.         &#125;  
  58.     &#125;  
  59.   
  60.     private static DatabaseHelper instance;  
  61.   
  62.     /**
  63.      * 单例获取该Helper
  64.      *  
  65.      * @param context
  66.      * @return
  67.      */  
  68.     public static synchronized DatabaseHelper getHelper(Context context)  
  69.     &#123;  
  70.         context = context.getApplicationContext();  
  71.         if (instance == null)  
  72.         &#123;  
  73.             synchronized (DatabaseHelper.class)  
  74.             &#123;  
  75.                 if (instance == null)  
  76.                     instance = new DatabaseHelper(context);  
  77.             &#125;  
  78.         &#125;  
  79.   
  80.         return instance;  
  81.     &#125;  
  82.   
  83.     public synchronized Dao getDao(Class clazz) throws SQLException  
  84.     &#123;  
  85.         Dao dao = null;  
  86.         String className = clazz.getSimpleName();  
  87.   
  88.         if (daos.containsKey(className))  
  89.         &#123;  
  90.             dao = daos.get(className);  
  91.         &#125;  
  92.         if (dao == null)  
  93.         &#123;  
  94.             dao = super.getDao(clazz);  
  95.             daos.put(className, dao);  
  96.         &#125;  
  97.         return dao;  
  98.     &#125;  
  99.   
  100.     /**
  101.      * 释放资源
  102.      */  
  103.     @Override  
  104.     public void close()  
  105.     &#123;  
  106.         super.close();  
  107.   
  108.         for (String key : daos.keySet())  
  109.         &#123;  
  110.             Dao dao = daos.get(key);  
  111.             dao = null;  
  112.         &#125;  
  113.     &#125;  
  114.   
  115. &#125;  
</code></pre>
<ol>
<li>整个DatabaseHelper使用单例只对外公布出一个对象，保证app中只存在一个SQLite Connection。 <a href="http://www.touchlab.co/2011/10/single-sqlite-connection/">参考文章</a>  </li>
<li>我们对每个Bean创建一个XXXDao来处理当前Bean的数据库操作，当然真正去和数据库打交道的对象，通过上面代码中的getDao（T t）进行获取<br>getDao为一个泛型方法，会根据传入Class对象进行创建Dao，并且使用一个Map来保持所有的Dao对象，只有第一次调用时才会去调用底层的getDao()。</li>
</ol>
<h2 id="5、我们的测试类："><a href="#5、我们的测试类：" class="headerlink" title="5、我们的测试类："></a>5、我们的测试类：</h2><pre><code>  1. public class OrmLiteDbTest extends AndroidTestCase  
  2. &#123;  
  3.     public void testAddArticle()  
  4.     &#123;  
  5.         User u = new User();  
  6.         u.setName(&quot;张鸿洋&quot;);  
  7.         new UserDao(getContext()).add(u);  
  8.         Article article = new Article();  
  9.         article.setTitle(&quot;ORMLite的使用&quot;);  
  10.         article.setUser(u);  
  11.         new ArticleDao(getContext()).add(article);  
  12.   
  13.     &#125;  
  14.   
  15.     public void testGetArticleById()  
  16.     &#123;  
  17.         Article article = new ArticleDao(getContext()).get(1);  
  18.         L.e(article.getUser() + &quot; , &quot; + article.getTitle());  
  19.     &#125;  
  20.   
  21.     public void testGetArticleWithUser()  
  22.     &#123;  
  23.   
  24.         Article article = new ArticleDao(getContext()).getArticleWithUser(1);  
  25.         L.e(article.getUser() + &quot; , &quot; + article.getTitle());  
  26.     &#125;  
  27.       
  28.     public void testListArticlesByUserId()  
  29.     &#123;  
  30.   
  31.         List&lt;Article&gt; articles = new ArticleDao(getContext()).listByUserId(1);  
  32.         L.e(articles.toString());  
  33.     &#125;  
</code></pre>
<p>分别测试，添加一个Article；通过Id获取一个Article；通过Id获取一个Article且携带User；通过userId获取所有的Article；<br>主要看第三个：通过Id获取一个Article且携带User，testGetArticleWithUser（id）<br>如何值传一个Article的Id，然后能够拿到Article对象，且内部的user属性直接赋值呢？<br>两种方式：</p>
<ul>
<li><p>1、即上述写法</p>
<pre><code>  1. article = articleDaoOpe.queryForId(id);  
  2.  helper.getDao(User.class).refresh(article.getUser());  
</code></pre>
</li>
<li><p>2、在user属性的注解上：</p>
<pre><code>  @DatabaseField(canBeNull = true, foreign = true, columnName = &quot;user_id&quot;, foreignAutoRefresh = true)
</code></pre>
</li>
</ul>
<p>添加foreignAutoRefresh =true，这样；当调用queryForId时，拿到Article对象则直接携带了user；</p>
<h2 id="6、关联一个集合"><a href="#6、关联一个集合" class="headerlink" title="6、关联一个集合"></a>6、关联一个集合</h2><p>每个User关联一个或多个Article，如果我在User中声明一个Collection<Article> articles，我能否在查询User的时候，一并能够获取到articles的值呢？<br>答案是可以的。在User中添加如下属性，且注解如下：<br>@ForeignCollectionField<br>private Collection<Article> articles;<br>我们在UserDao中书写查询User的代码：</p>
<pre><code>  1. public User get(int id)  
  2.     &#123;  
  3.         try  
  4.         &#123;  
  5.             return userDaoOpe.queryForId(id);  
  6.         &#125; catch (SQLException e)  
  7.         &#123;  
  8.             e.printStackTrace();  
  9.         &#125;  
  10.         return null ;  
  11.     &#125;  
</code></pre>
<p>测试代码：</p>
<pre><code>  1. public void testGetUserById()  
  2.     &#123;  
  3.         User user = new UserDao(getContext()).get(1);  
  4.         L.e(user.getName());  
  5.         if (user.getArticles() != null)  
  6.             for (Article article : user.getArticles())  
  7.             &#123;  
  8.                 L.e(article.toString());  
  9.             &#125;  
  10.     &#125;  
</code></pre>
<p>输出：</p>
<pre><code>  1. 09-07 22:49:06.484: E/zhy(7293): 欧神  
  2. 09-07 22:49:06.484: E/zhy(7293): Article [id=1, title=ORMLite的使用]  
</code></pre>
<p>可以看到，我们通过一个queryForId，成功的获取了User，以及User关联的所有的Articles；</p>
<h2 id="7、条件查询QueryBuilder的使用"><a href="#7、条件查询QueryBuilder的使用" class="headerlink" title="7、条件查询QueryBuilder的使用"></a>7、条件查询QueryBuilder的使用</h2><p>上述代码其实已经用到了简单的条件查询了：</p>
<ul>
<li><p>简单的where等于<br>articleDaoOpe.queryBuilder().where().eq(“user_id”, userId).query();直接返回Article的列表</p>
</li>
<li><p>where and</p>
<pre><code>    1. QueryBuilder&lt;Article, Integer&gt; queryBuilder = articleDaoOpe  
    2.                 .queryBuilder();  
    3.         Where&lt;Article, Integer&gt; where = queryBuilder.where();  
    4.         where.eq(&quot;user_id&quot;, 1);  
    5.         where.and();  
    6.         where.eq(&quot;name&quot;, &quot;xxx&quot;);  
    7.   
    8.         //或者  
    9.         articleDaoOpe.queryBuilder().//  
    10.                 where().//  
    11.                 eq(&quot;user_id&quot;, 1).and().//  
    12.                 eq(&quot;name&quot;, &quot;xxx&quot;);  
</code></pre>
</li>
</ul>
<p>上述两种都相当与：select * from tb_article where user_id = 1 and name = ‘xxx’ ;</p>
<ul>
<li><p>更复杂的查询</p>
<pre><code>    1. where.or(  
    2.                     //  
    3.                     where.and(//  
    4.                             where.eq(&quot;user_id&quot;, 1), where.eq(&quot;name&quot;, &quot;xxx&quot;)),  
    5.                     where.and(//  
    6.                             where.eq(&quot;user_id&quot;, 2), where.eq(&quot;name&quot;, &quot;yyy&quot;)));  
</code></pre>
</li>
</ul>
<p>select * from tb_article where ( user_id = 1 and name = ‘xxx’ )  or ( user_id = 2 and name = ‘yyy’ )  ;<br>好了，再复杂的查询估计也能够凑出来了~~</p>
<h2 id="8、updateBuilder、deleteBuilder"><a href="#8、updateBuilder、deleteBuilder" class="headerlink" title="8、updateBuilder、deleteBuilder"></a>8、updateBuilder、deleteBuilder</h2><p>使用queryBuilder是因为我们希望执行完成查询直接返回List<Bean>集合；<br>对于Update我们并不关注返回值，直接使用<br>articleDaoOpe.updateRaw(statement, arguments);传入sql和参数即可~~<br>何必在那<br>articleDaoOpe.updateBuilder().updateColumnValue(“name”,”zzz”).where().eq(“user_id”, 1);这样的痛苦呢~~~<br>同理还有deleteBuilder还是建议直接拼写sql，当然很简单的除外，直接使用它的API~</p>
<h2 id="9、事务操作"><a href="#9、事务操作" class="headerlink" title="9、事务操作"></a>9、事务操作</h2><p>在我们的Dao中直接写如下代码：</p>
<pre><code>      1. //事务操作  
      2.         TransactionManager.callInTransaction(helper.getConnectionSource(),  
      3.                 new Callable&lt;Void&gt;()  
      4.                 &#123;  
      5.   
      6.                     @Override  
      7.                     public Void call() throws Exception  
      8.                     &#123;  
      9.                         return null;  
      10.                     &#125;  
      11.                 &#125;);  
</code></pre>
<h2 id="10、其他操作"><a href="#10、其他操作" class="headerlink" title="10、其他操作"></a>10、其他操作</h2><ul>
<li><p>1、当Bean继承BaseDaoEnabled时，可以使用bean.create(bean)；bean.update(bean)一类操作<br>例如：  </p>
<pre><code>  Student extends BaseDaoEnabled&lt;Student, Integer&gt;
  Dao dao = DatabaseHelper.getHelper(getContext()).getDao(Student.class);
  Student student = new Student();
  student.setDao(dao);
  student.setName(&quot;张鸿洋&quot;);
  student.create();
</code></pre>
</li>
</ul>
<p>前提dao需要手动设置，如果dao为null会报错，尼玛，我觉得一点用没有。。。</p>
<ul>
<li><p>2、Join</p>
<pre><code>1. QueryBuilder&lt;Article, Integer&gt; articleBuilder = articleDaoOpe  
2.                     .queryBuilder();  
3.             QueryBuilder userBuilder = helper.getDao(User.class).queryBuilder();  
4.             articleBuilder.join(userBuilder);  
</code></pre>
</li>
</ul>
<p>Article与User做Join操作；</p>
<p>本篇主要想介绍在项目中如何写DataBaseHelper已经如何写BeanDao，以及列出了在项目中可能会用到的ORMLite的功能，如果需要详细了解，还请看ORMLite官方文档，源码中也会提供~~</p>
<blockquote>
<p><a href="http://img.shedoor.net/zhy_ormlite.rar">源码点击下载</a></p>
</blockquote>
<blockquote>
<p>装载来自：张鸿洋的博客<br><a href="http://blog.csdn.net/lmj623565791/article/details/39121377">Android ORMLite 框架的入门用法</a><br><a href="http://blog.csdn.net/lmj623565791/article/details/39122981">Android ORMLite 框架最佳实践</a>  </p>
</blockquote>
]]></content>
      <categories>
        <category>第三方框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>第三方框架</tag>
        <tag>ORMLite</tag>
      </tags>
  </entry>
  <entry>
    <title>RecyclerView 梳理：点击&amp;长按事件、分割线、拖曳排序、滑动删除</title>
    <url>/2017/08/03/Recycle/</url>
    <content><![CDATA[<p>这次主要是把 RecyclerView 比较常用的基本的点，在这里集中整理一下。从这篇文章主要梳理以下几点：  </p>
<ul>
<li>优雅的实现：item 点击事件 &amp; item 长点击事件</li>
<li>RecyclerView 添加 divider 的标准姿势</li>
<li>RecyclerView 实k现 item 的拖曳排序和滑动删除</li>
<li>拖曳排序时，限制首个 item 固定的实现</li>
</ul>
<span id="more"></span>

<p>先看一下最终的效果图：  </p>
<p><img src="http://img.shedoor.net/github/recyclerviewevent/recy_swipanddrag.gif?imageView2/2/w/300" alt="swipe and drag"> <img src="http://img.shedoor.net/github/recyclerviewevent/recy_drag.gif?imageView2/2/w/300" alt="drag">  </p>
<p>自从 RecyclerView 发布以来，由于其高度的可交互性被广泛使用。相信大家肯定对它的使用方法已经非常熟练了，今天主要是为大家总结一下较正常用法更加优雅的方式。  </p>
<blockquote>
<p>如果你想再回顾一下 RecyclerView 的基本使用方法，推荐鸿洋的这篇文章：<br><a href="http://blog.csdn.net/lmj623565791/article/details/45059587">Android RecyclerView 使用完全解析 体验艺术般的控件</a>  </p>
</blockquote>
<h2 id="优雅的实现：item-点击事件-amp-item-长点击事件"><a href="#优雅的实现：item-点击事件-amp-item-长点击事件" class="headerlink" title="优雅的实现：item 点击事件 &amp; item 长点击事件"></a>优雅的实现：item 点击事件 &amp; item 长点击事件</h2><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>RecyclerView 的 api 虽然没有提供 onItemClickListener 但是提供了 addOnItemTouchListener() 方法，既然可以添加触摸监听，那么我们完全可以获取触摸手势来识别点击事件，然后通过触摸坐标来判断点击的是哪一个item。  </p>
<pre><code>mRecyclerView.addOnItemTouchListener(new OnRecyclerItemClickListener(mRecyclerView) &#123;
            @Override
            public void onItemClick(RecyclerView.ViewHolder viewHolder) &#123;
                //TODO item 点击事件
            &#125;

            @Override
            public void onLongClick(RecyclerView.ViewHolder viewHolder) &#123;
                //TODO item 长按事件
            &#125;
        &#125;);
</code></pre>
<p>其中 OnRecyclerItemClickListener 是自定义的一个触摸监听器，代码如下：  </p>
<pre><code>public abstract class OnRecyclerItemClickListener implements RecyclerView.OnItemTouchListener&#123;
    private GestureDetectorCompat mGestureDetectorCompat;//手势探测器
    private RecyclerView mRecyclerView;

    public OnRecyclerItemClickListener(RecyclerView recyclerView) &#123;
        mRecyclerView = recyclerView;
        mGestureDetectorCompat = new GestureDetectorCompat(mRecyclerView.getContext(),
                new ItemTouchHelperGestureListener());
    &#125;

    @Override
    public boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e) &#123;
        mGestureDetectorCompat.onTouchEvent(e);
        return false;
    &#125;

    @Override
    public void onTouchEvent(RecyclerView rv, MotionEvent e) &#123;
        mGestureDetectorCompat.onTouchEvent(e);
    &#125;

    @Override
    public void onRequestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123;
    &#125;

    public abstract void onItemClick(RecyclerView.ViewHolder viewHolder);
    public abstract void onLongClick(RecyclerView.ViewHolder viewHolder);
&#125;
</code></pre>
<p>GestureDetectorCompat 中传入了一个 ItemTouchHelperGestureListener，代码如下：  </p>
<pre><code>private class ItemTouchHelperGestureListener extends GestureDetector.SimpleOnGestureListener&#123;
            //一次单独的轻触抬起手指操作，就是普通的点击事件
            @Override
            public boolean onSingleTapUp(MotionEvent e) &#123;
                View childViewUnder = mRecyclerView.findChildViewUnder(e.getX(), e.getY());
                if (childViewUnder != null) &#123;
                    RecyclerView.ViewHolder childViewHolder = mRecyclerView.getChildViewHolder(childViewUnder);
                    onItemClick(childViewHolder);
                &#125;
                return true;
            &#125;

            //长按屏幕超过一定时长，就会触发，就是长按事件
            @Override
            public void onLongPress(MotionEvent e) &#123;
                View childViewUnder = mRecyclerView.findChildViewUnder(e.getX(), e.getY());
                if (childViewUnder != null) &#123;
                    RecyclerView.ViewHolder childViewHolder = mRecyclerView.getChildViewHolder(childViewUnder);
                    onLongClick(childViewHolder);
                &#125;
            &#125;
        &#125;
</code></pre>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>上面的代码很简单没什么复杂的地方，就是通过一个手势探测器 GestureDetectorCompat 来探测屏幕事件，然后通过手势监听器 SimpleOnGestureListener 来识别手势事件的种类，然后调用我们设置的对应的回调方法。这里值得说的是：当获取到了 RecyclerView 的点击事件和触摸事件数据 MotionEvent，那么如何才能知道点击的是哪一个 item 呢？  </p>
<p>RecyclerView已经为我们提供了这样的方法：<code>findChildViewUnder()</code>。</p>
<p>我们可以通过这个方法获得点击的 item ，同时我们调用 RecyclerView 的另一个方法 <code>getChildViewHolder()</code>，可以获得该 item 的 ViewHolder，最后再回调我们定义的虚方法 onItemClick() 就ok了，这样我们就可以在外部实现该方法来获得 item 的点击事件了。  </p>
<h2 id="RecyclerView-添加-divider-的标准姿势"><a href="#RecyclerView-添加-divider-的标准姿势" class="headerlink" title="RecyclerView 添加 divider 的标准姿势"></a>RecyclerView 添加 divider 的标准姿势</h2><p>当你想给条目间添加 divider 时，你可能自然而然的去尝试这种方式：  </p>
<pre><code>&lt;android.support.v7.widget.RecyclerView
    android:divider=&quot;#ffff0000&quot;
    android:dividerHeight=&quot;10dp&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot; /&gt;
</code></pre>
<p>其实 RecyclerView 是没有这两个属性的，就算你写上也不会有任何效果。<br>当然你还可以通过给 item 的最外层布局设置一个 margin 值，甚至你还可以专门在 item 布局中的适当地方添加一个高度/宽度为 1 的带背景的 View 作为 divider，这两种方法呢，确实有效果，但是不够优雅，有时还可能带来一些想不到的问题。  </p>
<p>其实官方还是为我们提供了为 RecyclerView 添加分割线的方式的，那就是方法： <code>mRecyclerView.addItemDecoration()</code> 。该方法的参数为 RecyclerView.ItemDecoration，该类为抽象类，且官方目前并没有提供默认的实现类，我们只能自己来实现。</p>
<h3 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h3><p><strong>列表布局的分割线实例：</strong>  </p>
<pre><code>public class DividerListItemDecoration extends RecyclerView.ItemDecoration &#123;
    private static final int[] ATTRS = new int[]&#123;
            android.R.attr.listDivider
    &#125;;

    public static final int HORIZONTAL_LIST = LinearLayoutManager.HORIZONTAL;

    public static final int VERTICAL_LIST = LinearLayoutManager.VERTICAL;

    private Drawable mDivider;

    private int mOrientation;

    public DividerListItemDecoration(Context context, int orientation) &#123;
        final TypedArray a = context.obtainStyledAttributes(ATTRS);
        mDivider = a.getDrawable(0);
        a.recycle();
        setOrientation(orientation);
    &#125;

    public DividerListItemDecoration(Context context, int orientation, int drawableId) &#123;
        mDivider = ContextCompat.getDrawable(context, drawableId);
        setOrientation(orientation);
    &#125;

    public void setOrientation(int orientation) &#123;
        if (orientation != HORIZONTAL_LIST &amp;&amp; orientation != VERTICAL_LIST) &#123;
            throw new IllegalArgumentException(&quot;invalid orientation&quot;);
        &#125;
        mOrientation = orientation;
    &#125;

    //画线 &gt; 就是画出你想要的分割线样式
    @Override
    public void onDraw(Canvas c, RecyclerView parent) &#123;
        if (mOrientation == VERTICAL_LIST) &#123;
            drawVertical(c, parent);
        &#125; else &#123;
            drawHorizontal(c, parent);
        &#125;

    &#125;


    public void drawVertical(Canvas c, RecyclerView parent) &#123;
        final int left = parent.getPaddingLeft();
        final int right = parent.getWidth() - parent.getPaddingRight();

        final int childCount = parent.getChildCount();
        for (int i = 0; i &lt; childCount; i++) &#123;
            final View child = parent.getChildAt(i);
            android.support.v7.widget.RecyclerView v = new android.support.v7.widget.RecyclerView(parent.getContext());
            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child
                    .getLayoutParams();
            final int top = child.getBottom() + params.bottomMargin;
            final int bottom = top + mDivider.getIntrinsicHeight();
            mDivider.setBounds(left, top, right, bottom);
            mDivider.draw(c);
        &#125;
    &#125;

    public void drawHorizontal(Canvas c, RecyclerView parent) &#123;
        final int top = parent.getPaddingTop();
        final int bottom = parent.getHeight() - parent.getPaddingBottom();

        final int childCount = parent.getChildCount();
        for (int i = 0; i &lt; childCount; i++) &#123;
            final View child = parent.getChildAt(i);
            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child
                    .getLayoutParams();
            final int left = child.getRight() + params.rightMargin;
            final int right = left + mDivider.getIntrinsicHeight();
            mDivider.setBounds(left, top, right, bottom);
            mDivider.draw(c);
        &#125;
    &#125;

    //设置条目周边的偏移量
    @Override
    public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) &#123;
        if (mOrientation == VERTICAL_LIST) &#123;
            outRect.set(0, 0, 0, mDivider.getIntrinsicHeight());
        &#125; else &#123;
            outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0);
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>网格布局分割线实例：</strong>  </p>
<pre><code>public class DividerGridItemDecoration extends RecyclerView.ItemDecoration &#123;

    private static final int[] ATTRS = new int[]&#123;android.R.attr.listDivider&#125;;
    private Drawable mDivider;
    private int lineWidth = 1;

    public DividerGridItemDecoration(Context context) &#123;
        final TypedArray a = context.obtainStyledAttributes(ATTRS);
        mDivider = a.getDrawable(0);
        a.recycle();
    &#125;

    public DividerGridItemDecoration(int color) &#123;
        mDivider = new ColorDrawable(color);
    &#125;

    public DividerGridItemDecoration() &#123;
        this(Color.parseColor(&quot;#cccccc&quot;));
    &#125;

    @Override
    public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123;
        drawHorizontal(c, parent);
        drawVertical(c, parent);
    &#125;

    private int getSpanCount(RecyclerView parent) &#123;
        // 列数
        int spanCount = -1;
        RecyclerView.LayoutManager layoutManager = parent.getLayoutManager();
        if (layoutManager instanceof GridLayoutManager) &#123;

            spanCount = ((GridLayoutManager) layoutManager).getSpanCount();
        &#125; else if (layoutManager instanceof StaggeredGridLayoutManager) &#123;
            spanCount = ((StaggeredGridLayoutManager) layoutManager)
                    .getSpanCount();
        &#125;
        return spanCount;
    &#125;

    public void drawHorizontal(Canvas c, RecyclerView parent) &#123;
        int childCount = parent.getChildCount();
        for (int i = 0; i &lt; childCount; i++) &#123;
            final View child = parent.getChildAt(i);
            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child
                    .getLayoutParams();
            final int left = child.getLeft() - params.leftMargin;
            final int right = child.getRight() + params.rightMargin
                    + lineWidth;
            final int top = child.getBottom() + params.bottomMargin;
            final int bottom = top + lineWidth;
            mDivider.setBounds(left, top, right, bottom);
            mDivider.draw(c);
        &#125;
    &#125;

    public void drawVertical(Canvas c, RecyclerView parent) &#123;
        final int childCount = parent.getChildCount();
        for (int i = 0; i &lt; childCount; i++) &#123;
            final View child = parent.getChildAt(i);

            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();
            final int top = child.getTop() - params.topMargin;
            final int bottom = child.getBottom() + params.bottomMargin;
            final int left = child.getRight() + params.rightMargin;
            final int right = left + lineWidth;

            mDivider.setBounds(left, top, right, bottom);
            mDivider.draw(c);
        &#125;
    &#125;

    private boolean isLastColum(RecyclerView parent, int pos, int spanCount, int childCount) &#123;
        RecyclerView.LayoutManager layoutManager = parent.getLayoutManager();
        if (layoutManager instanceof GridLayoutManager) &#123;
            if ((pos + 1) % spanCount == 0)// 如果是最后一列，则不需要绘制右边
            &#123;
                return true;
            &#125;
        &#125; else if (layoutManager instanceof StaggeredGridLayoutManager) &#123;
            int orientation = ((StaggeredGridLayoutManager) layoutManager)
                    .getOrientation();
            if (orientation == StaggeredGridLayoutManager.VERTICAL) &#123;
                if ((pos + 1) % spanCount == 0)// 如果是最后一列，则不需要绘制右边
                &#123;
                    return true;
                &#125;
            &#125; else &#123;
                childCount = childCount - childCount % spanCount;
                if (pos &gt;= childCount)// 如果是最后一列，则不需要绘制右边
                    return true;
            &#125;
        &#125;
        return false;
    &#125;

    private boolean isLastRaw(RecyclerView parent, int pos, int spanCount, int childCount) &#123;
        LayoutManager layoutManager = parent.getLayoutManager();
        if (layoutManager instanceof GridLayoutManager) &#123;
            childCount = childCount - childCount % spanCount;
            if (pos &gt;= childCount)// 如果是最后一行，则不需要绘制底部
                return true;
        &#125; else if (layoutManager instanceof StaggeredGridLayoutManager) &#123;
            int orientation = ((StaggeredGridLayoutManager) layoutManager)
                    .getOrientation();
            // StaggeredGridLayoutManager 且纵向滚动
            if (orientation == StaggeredGridLayoutManager.VERTICAL) &#123;
                childCount = childCount - childCount % spanCount;
                // 如果是最后一行，则不需要绘制底部
                if (pos &gt;= childCount)
                    return true;
            &#125; else
            // StaggeredGridLayoutManager 且横向滚动
            &#123;
                // 如果是最后一行，则不需要绘制底部
                if ((pos + 1) % spanCount == 0) &#123;
                    return true;
                &#125;
            &#125;
        &#125;
        return false;
    &#125;

    @Override
    public void getItemOffsets(Rect outRect, View view, RecyclerView parent, State state) &#123;
        boolean b = state.willRunPredictiveAnimations();
        int itemPosition = ((RecyclerView.LayoutParams) view.getLayoutParams()).getViewLayoutPosition();
        int spanCount = getSpanCount(parent);
        int childCount = parent.getAdapter().getItemCount();
//        if (isLastRaw(parent, itemPosition, spanCount, childCount))// 如果是最后一行，则不需要绘制底部
//        &#123;
//            outRect.set(0, 0, lineWidth, 0);
//        &#125;
//        else if (isLastColum(parent, itemPosition, spanCount, childCount))// 如果是最后一列，则不需要绘制右边
//        &#123;
////            if (b)&#123;
////                outRect.set(0, 0, lineWidth, lineWidth);
////            &#125;else &#123;
//                outRect.set(0, 0, 0, lineWidth);
////            &#125;
//        &#125;
//        else &#123;
        outRect.set(0, 0, lineWidth, lineWidth);
//        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p>上面给出的两个实例都是最简单的一条线的分割。这里的分割线你是可以自由的去自定义它的，具体如何实现也不是太复杂，这里不再做详细介绍了，推荐一篇文章：  </p>
<blockquote>
<p><a href="http://www.10tiao.com/html/227/201705/2650239745/1.html">RecyclerView之ItemDecoration 讲解及高级特性实践</a>  </p>
</blockquote>
<h2 id="RecyclerView-实现-item-的拖曳排序和滑动删除"><a href="#RecyclerView-实现-item-的拖曳排序和滑动删除" class="headerlink" title="RecyclerView 实现 item 的拖曳排序和滑动删除"></a>RecyclerView 实现 item 的拖曳排序和滑动删除</h2><p>下面就主要为大家梳理一下拖曳排序和滑动删除的实现，具体实现效果看文章首部效果图，这里就不再重复放图了。  </p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>主要就要使用到 ItemTouchHelper，ItemTouchHelper 一个帮助开发人员处理拖拽和滑动删除的实现类，它能够让你非常容易实现侧滑删除、拖拽的功能。（ItemTouchHelper 的使用并不仅仅局限于 RecyclerView 的滑动删除，你同意可以用在其他需要拖曳滑动的地方。当然，今天我们不涉及其他地方的使用）  </p>
<p>实现的代码并关联到 RecyclerView 非常简单，代码如下：  </p>
<pre><code>ItemTouchHelper itemTouchHelper = new ItemTouchHelper(new ItemTouchHelper.Callback());
itemTouchHelper.attachToRecyclerView(mRecyclerView);
</code></pre>
<p>代码很简单，没什么好说的。需要我们关注的是创建 ItemTouchHelper 时传入的参数  ItemTouchHelper.Callback() 。ItemTouchHelper 会在拖拽的时候回调 Callback 中相应的方法，我们只需在 Callback 中实现自己的逻辑。</p>
<p>自定义一个类继承实现 ItemTouchHelper.Callback 接口，需要实现以下方法：  </p>
<pre><code>//通过返回值来设置是否处理某次拖曳或者滑动事件
public abstract int getMovementFlags(RecyclerView recyclerView,
                ViewHolder viewHolder);

//当长按并进入拖曳状态时，拖曳的过程中不断的回调此方法
public abstract boolean onMove(RecyclerView recyclerView,
                ViewHolder viewHolder, ViewHolder target);

//滑动删除的回调
public abstract void onSwiped(ViewHolder viewHolder, int direction);
</code></pre>
<p>getMovementFlags() 用于设置是否处理拖拽事件和滑动事件，以及拖拽和滑动操作的方向，有以下两种情况：</p>
<ul>
<li>如果是列表类型的 RecyclerView，拖拽只有 UP、DOWN 两个方向</li>
<li>如果是网格类型的则有 UP、DOWN、LEFT、RIGHT 四个方向</li>
</ul>
<p>该方法需要编写的代码如下：  </p>
<pre><code>@Override
public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123;
    if (recyclerView.getLayoutManager() instanceof GridLayoutManager) &#123;
        int dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN |
                ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;
        int swipeFlags = 0;
        return makeMovementFlags(dragFlags, swipeFlags);
    &#125; else &#123;
        int dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN;
        int swipeFlags = 0;
        return makeMovementFlags(dragFlags, swipeFlags);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>dragFlags 是拖拽标志，<br>swipeFlags 是滑动标志，<br>swipeFlags 都设置为0，暂时不考虑滑动相关操作。</p>
</blockquote>
<p>如果设置了相关的 dragFlags，那么当长按 item 的时候就会进入拖拽并在拖拽过程中不断回调 onMove() 方法，我们就在这个方法里获取当前拖拽的 item 和已经被拖拽到所处位置的 item 的ViewHolder，有了这2个 ViewHolder，我们就可以交换他们的数据集并调用 Adapter 的notifyItemMoved 方法来刷新 item。  </p>
<pre><code>@Override
public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) &#123;
    //拖动的 item 的下标
    int fromPosition = viewHolder.getAdapterPosition();
    //目标 item 的下标，目标 item 就是当拖曳过程中，不断和拖动的 item 做位置交换的条目。
    int toPosition = target.getAdapterPosition();
    if (fromPosition &lt; toPosition) &#123;
        for (int i = fromPosition; i &lt; toPosition; i++) &#123;
            Collections.swap(((RecyAdapter) mAdapter).getDataList(), i, i + 1);
        &#125;
    &#125; else &#123;
        for (int i = fromPosition; i &gt; toPosition; i--) &#123;
            Collections.swap(((RecyAdapter) mAdapter).getDataList(), i, i - 1);
        &#125;
    &#125;
    mAdapter.notifyItemMoved(fromPosition, toPosition);
    return true;
&#125;
</code></pre>
<p>只要重写完上面这两个方法，RecyclerView 就能实现拖曳的效果了。是不是很简单？但是虽然拖曳是没什么问题了，但是并不能达到下图的效果，因为你正在拖曳的 item 并没有阴影效果。  </p>
<p><img src="http://img.shedoor.net/github/recyclerviewevent/onlydrag.gif?imageView2/2/w/300" alt="拖曳 item">  </p>
<p>那怎么才能实现被拖曳的 item 有背景颜色加深起到强调的视觉效果呢？这是需要重写下面两个方法：  </p>
<pre><code>//当长按 item 刚开始拖曳的时候调用
@Override
public void onSelectedChanged(RecyclerView.ViewHolder viewHolder, int actionState) &#123;
    if (actionState != ItemTouchHelper.ACTION_STATE_IDLE) &#123;
        //给被拖曳的 item 设置一个深颜色背景
        viewHolder.itemView.setBackgroundColor(Color.LTGRAY);
    &#125;
    super.onSelectedChanged(viewHolder, actionState);
&#125;

//当完成拖曳手指松开的时候调用
@Override
public void clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123;
    super.clearView(recyclerView, viewHolder);
    //给已经完成拖曳的 item 恢复开始的背景。
    //这里我们设置的颜色尽量和你 item 在 xml 中设置的颜色保持一致
    viewHolder.itemView.setBackgroundColor(Color.WHITE);
&#125;
</code></pre>
<p>这样就能完全达到上面图片的效果了。  </p>
<p><strong>滑动删除</strong>  </p>
<p>如何实现滑动删除呢？我们只需要实现第三个方法 onSwipe() 就行了。代码如下：  </p>
<pre><code>@Override
public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) &#123;
    int adapterPosition = viewHolder.getAdapterPosition();
    mAdapter.notifyItemRemoved(adapterPosition);
    ((RecyAdapter) mAdapter).getDataList().remove(adapterPosition);
&#125;
</code></pre>
<p>同时也不要忘了修改一下 getMovementFlags() 方法，以便能够相应滑动事件：  </p>
<pre><code>@Override
public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123;
    if (recyclerView.getLayoutManager() instanceof GridLayoutManager) &#123;
        int dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN |
                ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;
        int swipeFlags = 0;
        return makeMovementFlags(dragFlags, swipeFlags);
    &#125; else &#123;
        int dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN;
        //注意：和拖曳的区别就是在这里
        int swipeFlags = ItemTouchHelper.START | ItemTouchHelper.END;
        return makeMovementFlags(dragFlags, swipeFlags);
    &#125;
&#125;
</code></pre>
<p>那目前你就能完美的实现拖曳排序和滑动删除了。  </p>
<p><strong>拖曳排序，首个固定</strong>  </p>
<p>有时我们希望首个 item 不能被拖曳排序。比如我们在新闻 App 中常见当我们进行新闻分类时，“热门”新闻这个分类总是第一个且不能被拖曳修改，类似下面的效果：  </p>
<p><img src="http://img.shedoor.net/github/recyclerviewevent/recy_drag.gif?imageView2/2/w/300" alt="首个固定不能被拖曳">  </p>
<p>那么怎么才能达到上面的效果呢？在上面我们的 Callback 类中有一个方法：  </p>
<pre><code>public boolean isLongPressDragEnabled() &#123;
    return true;
&#125;
</code></pre>
<p>这个方法是为了告诉 ItemTouchHelper 是否需要 RecyclerView 支持长按拖拽，默认返回是 ture，理所当然我们要支持，所以我们没有重写，因为默认true。但是这样做是默认全部的item都可以拖拽，怎么实现部分item拖拽呢，在 isLongPressDragEnabled 方法的源码中有提示说，如果想自定义拖曳 view,那么就使用 startDrag(ViewHolder) 方法。  </p>
<p><strong>第一步：</strong>那么我们就先重写 isLongPressDragEnabled() 方法，返回 false 让它控制所有的 item 都不能拖曳。  </p>
<pre><code>public boolean isLongPressDragEnabled() &#123;
    return false;
&#125;
</code></pre>
<p><strong>第二步：</strong>我们给 RecyclerView 设置 item 的长按监听事件，然后判断这个 item 是不是第一个（或者最后一个，如果你不想让最后一个被拖曳的话），如果不是我们就手动调用 startDrag(ViewHolder) 让 item 开始被拖曳。<br>结合上面我们提供的给 item 设置点击和长按事件的方法，我们可以这样：  </p>
<pre><code>mRecyclerView.addOnItemTouchListener(new OnRecyclerItemClickListener(mRecyclerView) &#123;
    @Override
    public void onItemClick(RecyclerView.ViewHolder viewHolder) &#123;
        //TODO:点击事件
    &#125;

    @Override
    public void onLongClick(RecyclerView.ViewHolder viewHolder) &#123;
        //当 item 被长按且不是第一个时，开始拖曳这个 item
        if (viewHolder.getLayoutPosition() != 0) &#123;
            itemTouchHelper.startDrag(viewHolder);
        &#125;
    &#125;
&#125;);
</code></pre>
<p><strong>第三步：</strong>如果你以为上面两步你就达到首个 item 固定不被拖曳的话，恭喜你，答对了！首个 item 确实固定不能被拖曳了，可是看看下图，就会令你大跌眼睛：   </p>
<p><img src="http://img.shedoor.net/github/recyclerviewevent/firstguding.gif?imageView2/2/w/300" alt="首个固定，不能被拖曳，却能被挤动">  </p>
<p>虽然我们通过上面两步控制了首个 item 不能被长按拖曳，但是我们并没有处理，别的 item 被拖曳到首个 item 的情况。那么如何才能让首个 item 不被挤掉呢，这个也很简单，只需要在 Callback 的 onMove() 方法中处理首个 item 被当着目标 item 的情况就行了。  </p>
<pre><code>@Override
public boolean onMove（...) &#123;
    int fromPosition = viewHolder.getAdapterPosition();
    int toPosition = target.getAdapterPosition();
    //其他地方代码都和上面的一样，这个就直接省略了
    //这里判断如果目标 item 是首个 item，那么就直接返回false，表示不响应此次拖曳移动
    if (toPosition == 0) &#123;
        return false;
    &#125;
    ...
    return true;
&#125;
</code></pre>
<p>好了，到这里就大功告成了。  </p>
<p>本文源代码地址：<a href="https://github.com/OCNYang/RecyclerViewEvent">https://github.com/OCNYang/RecyclerViewEvent</a>  </p>
<blockquote>
<p>参考文章：<br><a href="http://chuansong.me/n/400690551872">http://chuansong.me/n/400690551872</a><br><a href="http://chuansong.me/n/400690851058">http://chuansong.me/n/400690851058</a><br><a href="http://www.10tiao.com/html/227/201705/2650239745/1.html">http://www.10tiao.com/html/227/201705/2650239745/1.html</a>  </p>
</blockquote>
]]></content>
      <categories>
        <category>Android控件</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title>Retrofit2完全教程</title>
    <url>/2016/10/10/Retrofit2/</url>
    <content><![CDATA[<p> Retrofit2的详细用法</p>
<span id="more"></span>

<blockquote>
<p>作者： @怪盗kidou<br>Retrofit版本: 2.0.2  </p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文中的Retrofit均指代Retrofit2.0。<br>本文涉及到的代码以及测试使用的接口可在<a href="https://github.com/ikidou/Retrofit2Demo">Github</a>上找到。<br>测试接口服务器在 server 项目下，直接运行 RESTServer.main() 即可启动测试服务器，所面代码示例均使用该接口(接口地址 <a href="http://localhost:4567/">http://localhost:4567/</a> ).<br>当然你也可以自己借助 <a href="https://github.com/typicode/json-server">json-server</a> 或 最新开源的Parse 搭建一个REST API，不过都需要安装Node.js，有兴趣的可以去试试。  </p>
<p>接口列表：  </p>
<p><img src="http://img.shedoor.net/retrofit2/retrofit1.png">  </p>
<p>注：以上的接口的{id}和{page}均代表一个纯数字，/blog/{id} 可以用 /blog?id=XXX 代替，page同理。</p>
<p>前面写了<a href="http://www.jianshu.com/p/e544b7a76dac">你应该知道的HTTP基础知识</a> 介绍了HTTP的相关知识，不知道那些想了解Retrofit的同鞋是不是去看了<a href="http://square.github.io/retrofit/">Retrofit的官方教程</a>，曾经我在你真的会用Gson吗?<a href="http://www.jianshu.com/p/3108f1e44155">Gson使用指南（四）</a> 中说当你了解了注解、反射、泛型、HTTP的内容只需要看一篇Retrofit的代码示例就可以轻松玩转Retrofit，不知道你玩转了没?<br>当然注解、反射、泛型的内容还没有写，Retrofit的内容却先来了！毕竟看懂Retrofit也只需要会使就行，你准备好了吗？  </p>
<h2 id="1、Retrofit入门"><a href="#1、Retrofit入门" class="headerlink" title="1、Retrofit入门"></a>1、Retrofit入门</h2><p>Retrofit 其实相当简单，简单到源码只有37个文件，其中22个文件是注解还都和HTTP有关，真正暴露给用户的类并不多,所以我看了一遍 官方教程 大多数情景就可以无障碍使用，如果你还没有看过，可以先去看看,虽然是英文，但代码才是最好的教程不是么?当然本篇文章会介绍得详细一点，不能写一篇水文。</p>
<h3 id="1-1、创建Retrofit实例"><a href="#1-1、创建Retrofit实例" class="headerlink" title="1.1、创建Retrofit实例"></a>1.1、创建Retrofit实例</h3><pre><code>Retrofit retrofit = new Retrofit.Builder()
        .baseUrl(&quot;http://localhost:4567/&quot;)
        .build();  
</code></pre>
<p>创建Retrofit实例时需要通过Retrofit.Builder,并调用baseUrl方法设置URL。  </p>
<blockquote>
<p>注： Retrofit2 的baseUlr 必须以 /（斜线） 结束，不然会抛出一个IllegalArgumentException,所以如果你看到别的教程没有以 / 结束，那么多半是直接从Retrofit 1.X 照搬过来的。  </p>
</blockquote>
<h3 id="1-2、接口定义"><a href="#1-2、接口定义" class="headerlink" title="1.2、接口定义"></a>1.2、接口定义</h3><p>以获取指定id的Blog为例:  </p>
<pre><code>public interface BlogService &#123;
    @GET(&quot;blog/&#123;id&#125;&quot;)
    Call&lt;ResponseBody&gt; getFirstBlog(@Path(&quot;id&quot;) int id);
&#125;  
</code></pre>
<p>注意，这里是interface不是class，所以我们是无法直接调用该方法，我们需要用Retrofit创建一个BlogService的代理对象。  </p>
<pre><code>BlogService service = retrofit.create(BlogService.class);  
</code></pre>
<p>拿到代理对象之后，就可以调用该方法啦。  </p>
<h3 id="1-3、接口调用"><a href="#1-3、接口调用" class="headerlink" title="1.3、接口调用"></a>1.3、接口调用</h3><pre><code>Call&lt;ResponseBody&gt; call = service.getFirstBlog(2);
// 用法和OkHttp的call如出一辙,
// 不同的是如果是Android系统回调方法执行在主线程
call.enqueue(new Callback&lt;ResponseBody&gt;() &#123;
    @Override
    public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) &#123;
        try &#123;
            System.out.println(response.body().string());
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    @Override
    public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) &#123;
        t.printStackTrace();
    &#125;
&#125;);  
</code></pre>
<p>打印结果:  </p>
<pre><code>&#123;
  &quot;code&quot;: 200,
  &quot;msg&quot;: &quot;OK&quot;,
  &quot;data&quot;: &#123;
    &quot;id&quot;: 2,
    &quot;date&quot;: &quot;2016-04-15 03:17:50&quot;,
    &quot;author&quot;: &quot;怪盗kidou&quot;,
    &quot;title&quot;: &quot;Retrofit2 测试2&quot;,
    &quot;content&quot;: &quot;这里是 Retrofit2 Demo 测试服务器2&quot;
  &#125;,
  &quot;count&quot;: 0,
  &quot;page&quot;: 0
&#125;   
</code></pre>
<p>示例源码见 <a href="https://github.com/ikidou/Retrofit2Demo/blob/master/client/src/main/java/com/github/ikidou/Example01.java">Example01.java</a>  </p>
<h2 id="2、Retrofit注解详解"><a href="#2、Retrofit注解详解" class="headerlink" title="2、Retrofit注解详解"></a>2、Retrofit注解详解</h2><p>上面提到Retrofit 共22个注解，这节就专门介绍这22个注解，为帮助大家更好理解我将这22个注解分为三类，并用表格的形式展现出来,表格上说得并不完整，具体的见源码上的例子注释。  </p>
<h3 id="第一类：HTTP请求方法"><a href="#第一类：HTTP请求方法" class="headerlink" title="第一类：HTTP请求方法"></a>第一类：HTTP请求方法</h3><p><img src="http://img.shedoor.net/retrofit2/retrofit2.png" alt="HTTP请求方法注解"></p>
<p>以上表格中的除HTTP以外都对应了HTTP标准中的请求方法，而HTTP注解则可以代替以上方法中的任意一个注解,有3个属性：method、path,hasBody,下面是用HTTP注解实现上面 Example01.java 的例子。</p>
<pre><code>public interface BlogService &#123;
    /**
     * method 表示请的方法，不区分大小写
     * path表示路径
     * hasBody表示是否有请求体
     */
    @HTTP(method = &quot;get&quot;, path = &quot;blog/&#123;id&#125;&quot;, hasBody = false)
    Call&lt;ResponseBody&gt; getFirstBlog(@Path(&quot;id&quot;) int id);
&#125;  
</code></pre>
<p>示例源码见 <a href="https://github.com/ikidou/Retrofit2Demo/blob/master/client/src/main/java/com/github/ikidou/Example02.java">Example02.java</a>  </p>
<h3 id="第二类：标记类"><a href="#第二类：标记类" class="headerlink" title="第二类：标记类"></a>第二类：标记类</h3><p><img src="http://img.shedoor.net/retrofit2/retrofit3.png" alt="标记类注解"></p>
<p>示例源码见 <a href="https://github.com/ikidou/Retrofit2Demo/blob/master/client/src/main/java/com/github/ikidou/Example03.java">Example03.java</a>  </p>
<h3 id="第三类：参数类"><a href="#第三类：参数类" class="headerlink" title="第三类：参数类"></a>第三类：参数类</h3><p><img src="http://img.shedoor.net/retrofit2/retrofit4.png" alt="参数类注解">  </p>
<p><strong>注1：</strong>{占位符}和PATH尽量只用在URL的path部分，url中的参数使用Query和QueryMap 代替，保证接口定义的简洁<br><strong>注2：</strong>Query、Field和Part这三者都支持数组和实现了Iterable接口的类型，如List，Set等，方便向后台传递数组。  </p>
<pre><code>Call&lt;ResponseBody&gt; foo(@Query(&quot;ids[]&quot;) List&lt;Integer&gt; ids);
//结果：ids[]=0&amp;ids[]=1&amp;ids[]=2  
</code></pre>
<p>Path 示例源码见 Example01.java<br>Field、FieldMap、Part和PartMap 示例源码见 Example03.java<br>Header和Headers 示例源码见 <a href="https://github.com/ikidou/Retrofit2Demo/blob/master/client/src/main/java/com/github/ikidou/Example04.java">Example04.java</a><br>Query、QueryMap、Url 示例源码见 <a href="https://github.com/ikidou/Retrofit2Demo/blob/master/client/src/main/java/com/github/ikidou/Example05.java">Example05.java</a>  </p>
<h2 id="3、Gson与Converter"><a href="#3、Gson与Converter" class="headerlink" title="3、Gson与Converter"></a>3、Gson与Converter</h2><p>在默认情况下Retrofit只支持将HTTP的响应体转换换为ResponseBody,<br>这也是什么我在前面的例子接口的返回值都是 Call<ResponseBody>，<br>但如果响应体只是支持转换为ResponseBody的话何必要引用泛型呢，<br>返回值直接用一个Call就行了嘛，既然支持泛型，那说明泛型参数可以是其它类型的，<br>而Converter就是Retrofit为我们提供用于将ResponseBody转换为我们想要的类型，<br>有了Converter之后我们就可以写把我们的第一个例子的接口写成这个样子了：</p>
<pre><code>public interface BlogService &#123;
  @GET(&quot;blog/&#123;id&#125;&quot;) //这里的&#123;id&#125; 表示是一个变量
  Call&lt;Result&lt;Blog&gt;&gt; getFirstBlog(/** 这里的id表示的是上面的&#123;id&#125; */@Path(&quot;id&quot;) int id);
&#125;  
</code></pre>
<p>当然只改变泛型的类型是不行的，我们在创建Retrofit时需要明确告知用于将ResponseBody转换我们泛型中的类型时需要使用的Converter  </p>
<p>引入Gson支持:  </p>
<pre><code>compile &#39;com.squareup.retrofit2:converter-gson:2.0.2&#39;  
</code></pre>
<p>通过GsonConverterFactory为Retrofit添加Gson支持：</p>
<pre><code>Gson gson = new GsonBuilder()
      //配置你的Gson
      .setDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;)
      .create();

Retrofit retrofit = new Retrofit.Builder()
      .baseUrl(&quot;http://localhost:4567/&quot;)
      //可以接收自定义的Gson，当然也可以不传
      .addConverterFactory(GsonConverterFactory.create(gson))
      .build();  
</code></pre>
<p>示例源码见 <a href="https://github.com/ikidou/Retrofit2Demo/blob/master/client/src/main/java/com/github/ikidou/Example06.java">Example06.java</a>  </p>
<p>这样Retrofit就会使用Gson将ResponseBody转换我们想要的类型。  </p>
<p>这是时候我们终于可以演示如使创建一个Blog了！  </p>
<pre><code>@POST(&quot;blog&quot;)
Call&lt;Result&lt;Blog&gt;&gt; createBlog(@Body Blog blog);  
</code></pre>
<p>被@Body注解的的Blog将会被Gson转换成RequestBody发送到服务器。  </p>
<pre><code>BlogService service = retrofit.create(BlogService.class);
Blog blog = new Blog();
blog.content = &quot;新建的Blog&quot;;
blog.title = &quot;测试&quot;;
blog.author = &quot;怪盗kidou&quot;;
Call&lt;Result&lt;Blog&gt;&gt; call = service.createBlog(blog);  
</code></pre>
<p>结果：  </p>
<pre><code>Result&#123;
  code=200,
  msg=&#39;OK&#39;,
  data=Blog&#123;
    id=20,
    date=&#39;2016-04-21 05:29:58&#39;,
    author=&#39;怪盗kidou&#39;,
    title=&#39;测试&#39;,
    content=&#39;新建的Blog&#39;
  &#125;,
  count=0,
  page=0
&#125;  
</code></pre>
<p>示例源码见 (Example07.java)[<a href="https://github.com/ikidou/Retrofit2Demo/blob/master/client/src/main/java/com/github/ikidou/Example07.java]">https://github.com/ikidou/Retrofit2Demo/blob/master/client/src/main/java/com/github/ikidou/Example07.java]</a>  </p>
<p>如果你对Gson不熟悉可以参考我写的<a href="http://www.jianshu.com/p/e740196225a4">《你真的会用Gson吗?Gson使用指南》</a> 系列。</p>
<h2 id="4、RxJava与CallAdapter"><a href="#4、RxJava与CallAdapter" class="headerlink" title="4、RxJava与CallAdapter"></a>4、RxJava与CallAdapter</h2><p>说到Retrofit就不得说到另一个火到不行的库RxJava，网上已经不少文章讲如何与Retrofit结合，但这里还是会有一个RxJava的例子，不过这里主要目的是介绍使用CallAdapter所带来的效果。  </p>
<p>第3节介绍的Converter是对于Call<T>中T的转换，而CallAdapter则可以对Call转换，这样的话Call<T>中的Call也是可以被替换的，而返回值的类型就决定你后续的处理程序逻辑，同样Retrofit提供了多个CallAdapter，这里以RxJava的为例，用Observable代替Call：  </p>
<p>引入RxJava支持:  </p>
<pre><code>compile &#39;com.squareup.retrofit2:adapter-rxjava:2.0.2&#39;  
</code></pre>
<p>通过RxJavaCallAdapterFactory为Retrofit添加RxJava支持：  </p>
<pre><code>Retrofit retrofit = new Retrofit.Builder()
      .baseUrl(&quot;http://localhost:4567/&quot;)
      .addConverterFactory(GsonConverterFactory.create())
      .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
      .build();  
</code></pre>
<p>接口设计：  </p>
<pre><code>public interface BlogService &#123;
  @POST(&quot;/blog&quot;)
  Observable&lt;Result&lt;List&lt;Blog&gt;&gt;&gt; getBlogs();
&#125;  
</code></pre>
<p>使用：  </p>
<pre><code>BlogService service = retrofit.create(BlogService.class);
service.getBlogs(1)
  .subscribeOn(Schedulers.io())
  .subscribe(new Subscriber&lt;Result&lt;List&lt;Blog&gt;&gt;&gt;() &#123;
      @Override
      public void onCompleted() &#123;
        System.out.println(&quot;onCompleted&quot;);
      &#125;

      @Override
      public void onError(Throwable e) &#123;
        System.err.println(&quot;onError&quot;);
      &#125;

      @Override
      public void onNext(Result&lt;List&lt;Blog&gt;&gt; blogsResult) &#123;
        System.out.println(blogsResult);
      &#125;
  &#125;);  
</code></pre>
<p>结果：</p>
<pre><code>Result&#123;
  code=200,
  msg=&#39;OK&#39;,
  data=[
    Blog&#123;
      id=1,
      date=&#39;2016-04-15 03:17:50&#39;,
      author=&#39;怪盗kidou&#39;,
      title=&#39;Retrofit2 测试1&#39;,
      content=&#39;这里是 Retrofit2 Demo 测试服务器1&#39;
    &#125;,
    .....
  ],
  count=20,
  page=1
&#125;    
</code></pre>
<p>示例源码见 <a href="https://github.com/ikidou/Retrofit2Demo/blob/master/client/src/main/java/com/github/ikidou/Example08.java">Example08.java</a>  </p>
<blockquote>
<p>「补充」：像上面的这种情况最后我们无法获取到返回的Header和响应码的，如果我们需要这两者，提供两种方案：  </p>
</blockquote>
<ol>
<li>用Observable&lt;Response<T>&gt;``Observable<T> ,这里的Response指retrofit2.Response</li>
<li>用Observable&lt;Result<T>&gt; 代替Observable<T>，这里的Result是指retrofit2.adapter.rxjava.Result,这个Result中包含了Response的实例  </li>
</ol>
<h2 id="5、自定义Converter"><a href="#5、自定义Converter" class="headerlink" title="5、自定义Converter"></a>5、自定义Converter</h2><p>本节的内容是教大家实现在一简易的Converter，这里以返回格式为Call<String>为例。  </p>
<p>在此之前先了解一下Converter接口及其作用：  </p>
<pre><code>public interface Converter&lt;F, T&gt; &#123;
  // 实现从 F(rom) 到 T(o)的转换
  T convert(F value) throws IOException;

  // 用于向Retrofit提供相应Converter的工厂
  abstract class Factory &#123;
    // 这里创建从ResponseBody其它类型的Converter，如果不能处理返回null
    // 主要用于对响应体的处理
    public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations,
    Retrofit retrofit) &#123;
      return null;
    &#125;

    // 在这里创建 从自定类型到ResponseBody 的Converter,不能处理就返回null，
    // 主要用于对Part、PartMap、Body注解的处理
    public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type,
    Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;
      return null;
    &#125;

    // 这里用于对Field、FieldMap、Header、Path、Query、QueryMap注解的处理
    // Retrfofit对于上面的几个注解默认使用的是调用toString方法
    public Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations,
    Retrofit retrofit) &#123;
      return null;
    &#125;

  &#125;
&#125;  
</code></pre>
<p>我们要想从Call<ResponseBody> 转换为 Call<String> 那么对应的F和T则分别对应ResponseBody和String，我们定义一个StringConverter并实现Converter接口。  </p>
<pre><code>public static class StringConverter implements Converter&lt;ResponseBody, String&gt; &#123;

  public static final StringConverter INSTANCE = new StringConverter();

  @Override
  public String convert(ResponseBody value) throws IOException &#123;
    return value.string();
  &#125;
&#125;  
</code></pre>
<p>我们需要一个Fractory来向Retrofit注册StringConverter  </p>
<pre><code>public static class StringConverterFactory extends Converter.Factory &#123;

  public static final StringConverterFactory INSTANCE = new StringConverterFactory();

  public static StringConverterFactory create() &#123;
    return INSTANCE;
  &#125;

  // 我们只关实现从ResponseBody 到 String 的转换，所以其它方法可不覆盖
  @Override
  public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123;
    if (type == String.class) &#123;
      return StringConverter.INSTANCE;
    &#125;
    //其它类型我们不处理，返回null就行
    return null;
  &#125;
&#125;  
</code></pre>
<p>使用Retrofit.Builder.addConverterFactory向Retrofit注册我们StringConverterFactory：  </p>
<pre><code>Retrofit retrofit = new Retrofit.Builder()
      .baseUrl(&quot;http://localhost:4567/&quot;)
      // 如是有Gson这类的Converter 一定要放在其它前面
      .addConverterFactory(StringConverterFactory.create())
      .addConverterFactory(GsonConverterFactory.create())
      .build();  
</code></pre>
<p><strong>注：</strong>addConverterFactory是有先后顺序的，如果有多个ConverterFactory都支持同一种类型，那么就是只有第一个才会被使用，而GsonConverterFactory是不判断是否支持的，所以这里交换了顺序还会有一个异常抛出，原因是类型不匹配。   </p>
<p>只要返回值类型的泛型参数就会由我们的StringConverter处理,不管是Call<String>还是Observable<String>  </p>
<p>有没有很简单?如果你有其它的需求处理的就自己实现吧。  </p>
<p>示例源码见 <a href="https://github.com/ikidou/Retrofit2Demo/blob/master/client/src/main/java/com/github/ikidou/Example09.java">Example09.java</a>  </p>
<h2 id="6、自定义CallAdapter"><a href="#6、自定义CallAdapter" class="headerlink" title="6、自定义CallAdapter"></a>6、自定义CallAdapter</h2><p>本节将介绍如何自定一个CallAdapter，并验证是否所有的String都会使用我们第5节中自定义的Converter。  </p>
<p>先看一下CallAdapter接口定义及各方法的作用：  </p>
<pre><code>public interface CallAdapter&lt;T&gt; &#123;

  // 直正数据的类型 如Call&lt;T&gt; 中的 T
  // 这个 T 会作为Converter.Factory.responseBodyConverter 的第一个参数
  // 可以参照上面的自定义Converter
  Type responseType();

  &lt;R&gt; T adapt(Call&lt;R&gt; call);

  // 用于向Retrofit提供CallAdapter的工厂类
  abstract class Factory &#123;
    // 在这个方法中判断是否是我们支持的类型，returnType 即Call&lt;Requestbody&gt;和`Observable&lt;Requestbody&gt;`
    // RxJavaCallAdapterFactory 就是判断returnType是不是Observable&lt;?&gt; 类型
    // 不支持时返回null
    public abstract CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations,
    Retrofit retrofit);

    // 用于获取泛型的参数 如 Call&lt;Requestbody&gt; 中 Requestbody
    protected static Type getParameterUpperBound(int index, ParameterizedType type) &#123;
      return Utils.getParameterUpperBound(index, type);
    &#125;

    // 用于获取泛型的原始类型 如 Call&lt;Requestbody&gt; 中的 Call
    // 上面的get方法需要使用该方法。
    protected static Class&lt;?&gt; getRawType(Type type) &#123;
      return Utils.getRawType(type);
    &#125;
  &#125;
&#125;  
</code></pre>
<p>了解了CallAdapter的结构和其作用之后，我们就可以开始自定义我们的CallAdapter了，本节以CustomCall<String>为例。  </p>
<p>在此我们需要定义一个CustomCall，不过这里的CustomCall作为演示只是对Call的一个包装，并没有实际的用途。  </p>
<pre><code>public static class CustomCall&lt;R&gt; &#123;

  public final Call&lt;R&gt; call;

  public CustomCall(Call&lt;R&gt; call) &#123;
    this.call = call;
  &#125;

  public R get() throws IOException &#123;
    return call.execute().body();
  &#125;
&#125;  
</code></pre>
<p>有了CustomCall，我们还需要一个CustomCallAdapter来实现 Call<T> 到 CustomCall<T>的转换，这里需要注意的是最后的泛型，是我们要返回的类型。  </p>
<pre><code>public static class CustomCallAdapter implements CallAdapter&lt;CustomCall&lt;?&gt;&gt; &#123;

  private final Type responseType;

  // 下面的 responseType 方法需要数据的类型
  CustomCallAdapter(Type responseType) &#123;
    this.responseType = responseType;
  &#125;

  @Override
  public Type responseType() &#123;
    return responseType;
  &#125;

  @Override
  public &lt;R&gt; CustomCall&lt;R&gt; adapt(Call&lt;R&gt; call) &#123;
    // 由 CustomCall 决定如何使用
    return new CustomCall&lt;&gt;(call);
  &#125;
&#125;  
</code></pre>
<p>提供一个CustomCallAdapterFactory用于向Retrofit提供CustomCallAdapter：  </p>
<pre><code>public static class CustomCallAdapterFactory extends CallAdapter.Factory &#123;
  public static final CustomCallAdapterFactory INSTANCE = new CustomCallAdapterFactory();

  @Override
  public CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;
    // 获取原始类型
    Class&lt;?&gt; rawType = getRawType(returnType);
    // 返回值必须是CustomCall并且带有泛型
    if (rawType == CustomCall.class &amp;&amp; returnType instanceof ParameterizedType) &#123;
      Type callReturnType = getParameterUpperBound(0, (ParameterizedType) returnType);
      return new CustomCallAdapter(callReturnType);
    &#125;
    return null;
  &#125;
&#125;  
</code></pre>
<p>使用addCallAdapterFactory向Retrofit注册CustomCallAdapterFactory  </p>
<pre><code>Retrofit retrofit = new Retrofit.Builder()
      .baseUrl(&quot;http://localhost:4567/&quot;)
      .addConverterFactory(Example09.StringConverterFactory.create())
      .addConverterFactory(GsonConverterFactory.create())
      .addCallAdapterFactory(CustomCallAdapterFactory.INSTANCE)
      .build();  
</code></pre>
<p>注： addCallAdapterFactory与addConverterFactory同理，也有先后顺序。</p>
<p>示例源码见 <a href="https://github.com/ikidou/Retrofit2Demo/blob/master/client/src/main/java/com/github/ikidou/Example10.java">Example10.java</a>  </p>
<h2 id="7、其它说明"><a href="#7、其它说明" class="headerlink" title="7、其它说明"></a>7、其它说明</h2><h3 id="7-1-Retrofit-Builder"><a href="#7-1-Retrofit-Builder" class="headerlink" title="7.1 Retrofit.Builder"></a>7.1 Retrofit.Builder</h3><p>前面用到了 Retrofit.Builder 中的baseUrl、addCallAdapterFactory、addConverterFactory、build方法，还有callbackExecutor、callFactory、client、validateEagerly这四个方法没有用到，这里简单的介绍一下。  </p>
<p><img src="http://img.shedoor.net/retrofit2/retrofit5.png">  </p>
<h3 id="7-2-Retrofit的Url组合规则"><a href="#7-2-Retrofit的Url组合规则" class="headerlink" title="7.2 Retrofit的Url组合规则"></a>7.2 Retrofit的Url组合规则</h3><p><img src="http://img.shedoor.net/retrofit2/retrofit6.png">  </p>
<p>从上面不能难看出以下规则：</p>
<ul>
<li>如果你在注解中提供的url是完整的url，则url将作为请求的url。</li>
<li>如果你在注解中提供的url是不完整的url，且不以 / 开头，则请求的url为baseUrl+注解中提供的值</li>
<li>如果你在注解中提供的url是不完整的url，且以 / 开头，则请求的url为baseUrl的主机部分+注解中提供的值  </li>
</ul>
<h3 id="7-3-Retrofit提供的Converter"><a href="#7-3-Retrofit提供的Converter" class="headerlink" title="7.3 Retrofit提供的Converter"></a>7.3 Retrofit提供的Converter</h3><p><img src="http://img.shedoor.net/retrofit2/retrofit7.png">  </p>
<h3 id="7-4-Retrofit提供的CallAdapter："><a href="#7-4-Retrofit提供的CallAdapter：" class="headerlink" title="7.4 Retrofit提供的CallAdapter："></a>7.4 Retrofit提供的CallAdapter：</h3><p><img src="http://img.shedoor.net/retrofit2/retrofit8.png">   </p>
<h3 id="7-5-关于源码"><a href="#7-5-关于源码" class="headerlink" title="7.5 关于源码"></a>7.5 关于源码</h3><p>看到这儿可能有小伙伴要问为什么源码没有把类拆分到单独的文件，命名也不能体现其用途，这里主要是因为方便大家看源码，而不是将注意力放在反复跳转上，另一方面也是因为同一个例子中不可避免的使用其它小节要介绍的内容，所以就直接用了ExampleXX的形式，不过在项目中千万不要使用这种方式，一定要好好命名，做到见名知意。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其它本博客的内容早就已经完成好了，但由于当时HTTP、反射、注解的博客一篇也没有写，所以一直没有发，期间也有不少的博主写了Retrofit2的博文，不过呢没有自定义相关的内容也没有对各个注解进行详解，所以我还是决定发出来帮助一下那此对Retrofit2无从下手同鞋。</p>
<p>这次Retrofit2的内容就到这里啦，下次再见。</p>
]]></content>
      <categories>
        <category>第三方框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>第三方框架</tag>
        <tag>Retrofit2</tag>
      </tags>
  </entry>
  <entry>
    <title>ViewPager 超详解：玩出十八般花样</title>
    <url>/2018/01/26/ViewPager/</url>
    <content><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/2625875-ad56b6b0150bd32b.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">  </p>
<p>虽然没有 RecyclerView 这种列表控件常用些，但是在开发中你ViewPager 肯定也是不可或缺的控件，引导页、轮播图、卡片画廊等效果总是缺少不了 ViewPager 的身影。<br>相信每一位朋友对 ViewPager 的基础使用都已经很熟练了，今天在这里就从简至繁将 ViewPager 的每个用法都梳理一边。  </p>
<p>主要包括以下内容：   </p>
<ul>
<li>ViewPager 基本使用（简介、适配器）  </li>
<li>ViewPager + TabLayout + Fragment 的使用  </li>
<li>ViewPager 轮播图的使用（指示器、标题、自动轮播、首尾循环）  </li>
<li>ViewPager 的切换效果（PageTransformer）</li>
<li>ViewPager 切换效果进阶</li>
</ul>
<span id="more"></span>

<h2 id="ViewPager-的基础使用"><a href="#ViewPager-的基础使用" class="headerlink" title="ViewPager 的基础使用"></a>ViewPager 的基础使用</h2><p>对于 ViewPager ，官方的描述大概是这样的：页面允许左右滑动的布局管理器，而不同页面带有不同的数据。  </p>
<blockquote>
<p>这里简单归结如下：</p>
<ul>
<li>ViewPager 是 v4 包中的一个类。</li>
<li>ViewPager 类直接继承了 ViewGroup 类，它是一个容器类，可以在其中添加其他的 view 。</li>
<li>类似于 ListView，也有自己的适配器，用来填充数据页面。</li>
</ul>
</blockquote>
<p>关于 ViewPager 在布局文件中的声明，这里就不再说了。其实是没什么好说的，并没有什么可以直接声明的特殊属性，由于继承于 ViewGroup 有的也都是些 ViewGroup 的属性。  </p>
<p>这里值得介绍的也就是几个可以动态设置方法了，常用的有以下几个：  </p>
<ul>
<li><code>setAdapter(PagerAdapter adapter) </code> 设置适配器</li>
<li><code>setOffscreenPageLimit(int limit) </code> 设置缓存的页面个数,默认是 1</li>
<li><code>setCurrentItem(int item) </code> 跳转到特定的页面</li>
<li><code>setOnPageChangeListener(..)</code> 设置页面滑动时的监听器（现在API中建议使用 <code>addOnPageChangeListener(..)</code>）</li>
<li><code>setPageTransformer(..PageTransformer) </code> 设置页面切换时的动画效果</li>
<li><code>setPageMargin(int marginPixels) </code> 设置不同页面之间的间隔</li>
<li><code>setPageMarginDrawable(..)</code> 设置不同页面间隔之间的装饰图也就是 divide ，要想显示设置的图片，需要同时设置 <code>setPageMargin()</code></li>
</ul>
<blockquote>
<p><strong>谨记上面这几个方法，玩转 ViewPager 其实都是围绕它们进行的，能不能玩出花样，就看你把它们运用的怎么样了。</strong></p>
</blockquote>
<p>上面的方面大多一看说明就明白了，这里值得一提的就是 ViewPager 的适配器了。  </p>
<h3 id="PagerAdapter"><a href="#PagerAdapter" class="headerlink" title="PagerAdapter"></a>PagerAdapter</h3><p>PagerAdapter 是抽象的类，所以使用时只能使用它的子类，实现子类必须要实现以下四个方法:  </p>
<ul>
<li><code>getCount();</code> 是获取当前窗体界面数，也就是数据的个数。</li>
<li><code>isViewFromObject(View view, Object object);</code> 这个方法用于判断是否由对象生成界面，官方建议直接返回 <code>return view == object;</code>。</li>
<li><code>instantiateItem(View container, int position);</code> 要显示的页面或需要缓存的页面，会调用这个方法进行布局的初始化。</li>
<li><code>destroyItem(ViewGroup container, int position, Object object);</code> 如果页面不是当前显示的页面也不是要缓存的页面，会调用这个方法，将页面销毁。</li>
</ul>
<p>相信大家对上面这些方法的实现并不陌生，这里就不详细介绍了。另外我们知道官方给我们提供的还有 PagerAdapter 的两个直接子类 FragmentPagerAdapter 和 FragmentStatePagerAdapter 。而我们常常会在 ViewPager 和 Fragment 结合使用的时候来使用这两个适配器。具体的用法和它们之间的区别，我们在下个章节讲。  </p>
<h2 id="ViewPager-TabLayout-Fragment-的结合使用"><a href="#ViewPager-TabLayout-Fragment-的结合使用" class="headerlink" title="ViewPager + TabLayout + Fragment 的结合使用"></a>ViewPager + TabLayout + Fragment 的结合使用</h2><p>在引导页中我们常常用 ViewPager 和 Fragment 结合使用，而像新闻分类的页面我们会再加上一个 TabLayout 三者联动使用。而此时，我们不会再使用 PagerAdapter 了，而是直接使用官方提供的专门用于与 Fragment 结合使用的 FragmentPagerAdapter。  </p>
<p>FragmentPagerAdapter 它将每一个页面表示为一个 Fragment，并且每一个 Fragment 都将会保存到 FragmentManager 当中。而且，当用户没可能再次回到页面的时候，FragmentManager 才会将这个 Fragment 销毁。  </p>
<p>使用 FragmentPagerAdapter 需要实现两个方法：  </p>
<ul>
<li><code>public Fragment getItem(int position)</code> 返回的是对应的 Fragment 实例，一般我们在使用时，会通过构造传入一个要显示的 Fragment 的集合，我们只要在这里把对应的 Fragment 返回就行了。</li>
<li><code>public int getCount()</code> 这个上面介绍过了返回的是页面的个数，我们只要返回传入集合的长度就行了。</li>
</ul>
<p>使用起来是非常简单的，FragmentStatePagerAdapter 的使用也和上面一样，那两者到底有什么区别呢？  </p>
<p>区别如下：</p>
<ul>
<li><strong>FragmentPagerAdapter</strong>：对于不再需要的 fragment，选择调用 onDetach() 方法，仅销毁视图，并不会销毁 fragment 实例。</li>
<li><strong>FragmentStatePagerAdapter</strong>：会销毁不再需要的 fragment，当当前事务提交以后，会彻底的将 fragmeng 从当前 Activity 的FragmentManager 中移除，state 标明，销毁时，会将其 <code>onSaveInstanceState(Bundle outState)</code> 中的 bundle 信息保存下来，当用户切换回来，可以通过该 bundle 恢复生成新的 fragment，也就是说，你可以在 <code>onSaveInstanceState(Bundle outState)</code> 方法中保存一些数据，在 onCreate 中进行恢复创建。</li>
</ul>
<blockquote>
<p>由上总结：<br>使用 FragmentStatePagerAdapter 更省内存，但是销毁后新建也是需要时间的。一般情况下，如果你是制作主页面，就 3、4 个 Tab，那么可以选择使用 FragmentPagerAdapter，如果你是用于 ViewPager 展示数量特别多的条目时，那么建议使用 FragmentStatePagerAdapter。</p>
</blockquote>
<p>那 Tablayout 如何和 Viewpager 联动呢？由于我们这里主要是讲解 ViewPager 的，所谓 “术业有专攻” 所以关于 TabLayout 的使用我们就不再掺和了。<br>第一步，初始化 TabLayout 和 ViewPager 后只要通过调用 TabLayout 的 <code>tabLayout.setupWithViewPager(viewPager)</code> 方法就将两者绑定在一起了。<br>第二步，重写 PagerAdapter 的 <code>public CharSequence getPageTitle(int position)</code> 方法，而 TabLayout 也正是通过 <code>setupWithViewPager()</code> 方法底部会调用 PagerAdapter 中的<code>getPageTitle()</code> 方法来实现联动的。  </p>
<h2 id="ViewPager-轮播图的使用"><a href="#ViewPager-轮播图的使用" class="headerlink" title="ViewPager 轮播图的使用"></a>ViewPager 轮播图的使用</h2><p>关于此章本想给大家细细到来，才写上面两章都这么多篇幅了，我们还有给下面两章重点讲的部分留点空间呢。如果非得想看还不嫌我啰嗦，那我有时间再把这段给不出来。  </p>
<p>这章就这样结束，当然没有，虽然不负责任，但是也不能撩完妹子就闪人啊！这里还是要基本原理给大家论道论道的。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/2625875-01a8f9ee5ebfc2f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Banner 元素组成图">  </p>
<p>从上图我们可以知道，一般我们使用 ViewPager 做 Banner 时主要有以上几个元素：  </p>
<p><strong>标题 &amp; 指示器</strong>：<br>我们可以把标题和指示器直接写在我们 Banner 的 item 的布局中，这样通过在 PageAdapter 的 <code>instantiateItem()</code> 方法初始化页面时，直接设置。但是一般我们不会这样做（如果标题没有阴影的话，可以如上面说的那样），因为这样在页面滑动的时候，会显得特别生硬，尤其是指示器。<br>那该如何呢？一般我们会在 ViewPager 所在的布局文件中，声明指示器和标题布局，如下：  </p>
<pre><code>&lt;FrameLayout
     ...&gt;

    &lt;android.support.v4.view.ViewPager
        android:id=&quot;@+id/viewPager&quot;
        ...&quot;/&gt;

    &lt;LinearLayout
        android:layout_gravity=&quot;bottom&quot;
        ...&gt;
        &lt;!--指示器布局，因为不知道 item 的个数，所以会动态的把指示器的View添加到这里--&gt;
        &lt;LinearLayout
            android:id=&quot;@+id/bannerIndicators&quot;
            .../&gt;
        &lt;!--标题--&gt;
        &lt;TextView
            android:id=&quot;@+id/bannerTitle&quot;
            .../&gt;
    &lt;/LinearLayout&gt;

&lt;/FrameLayout&gt;
</code></pre>
<p>那如何才能实现当页面滑动时，标题和指示器伴随改变呢？还记不记得，一开始介绍 ViewPager 时，它有一个可以设置监听页面改变的方法 <code>addOnPageChangeListener()</code>，在 OnPageChangeListener 监听器中有一个页面滑动结束时的回调方法 <code>onPageSelected(int position)</code> ,我们只需要在这个方法中，来设置标题和指示器跟随变化就行了。  </p>
<p><strong>自动轮播</strong>：<br>实现自动轮播的原理其实更简单，只要我们每隔一定时间发送一个切换页面的事件就行了。实现这个功能有很多种方法，相信作为 Android 开发者，你最快想到的就是 <code>Handler.sendEmptyMessageDelayed(int what, long delayMillis)</code> 了吧。  </p>
<pre><code>Handler mHandler = new Handler() &#123;
        @Override
        public void handleMessage(Message msg) &#123;
            if (mAutoPlay) &#123;
                //mViewPager.setCurrentItem(mViewPager.getCurrentItem() + 1);//无限轮播时
                mViewPager.setCurrentItem((mViewPager.getCurrentItem()+1) % mViewPagerItemCount)
                this.sendEmptyMessageDelayed(MSG_WHAT, delayMillis);
            &#125;
        &#125;
    &#125;;
</code></pre>
<p>当然不要忘了在外部，初始化完成后调用一次<code>mHandler.sendEmptyMessageDelayed(MSG_WHAT, delayMillis);</code>。  </p>
<p><strong>首尾循环无限轮播</strong>：<br>当然，我们在设置自动轮播时，已经做到了首尾循环无限轮播了呀。</p>
<p>其实这里所说的无限轮播是指：当我们手动滑到最后一个页面时，依然可以向后伴随手指滑动，并跳转显示的是第一个页面；反之滑到首个页面也是一样。<br>旁边那位脑子灵光的大兄弟又说了，那还不简单，在页面监听器 OnPageChangeListener 里，通过 position 分辨滑动的是不是首页或者最后一页，然后通过 setCurrentItem() 设置一下不就行了，还那么麻烦。<br>大胸弟，你且消消气！这里并不使用这种方式是因为，这种方式的跳转是十分生硬的，同时是不能实现“伴随手指滑动”这个条件的。  </p>
<p>那究竟如何如何才能实现呢？目前江湖流传的有一下两种方法：  </p>
<ol>
<li>使 adapter 的 getCount() 返回 Integer.MAX_VALUE，再在初始化时设置当前页面为几千页(如：<code>ViewPager.setCurrentItem(1000*data.size)</code>),其实就是障眼法，大爷心情好的话，向前滑动几千页也不是不可能的;</li>
<li>通过监听 viewpager 的滑动来设置页面。如当前有数据 123，则设置页面为 31231，当页面滑动到第一个 3 时，设置当前页面为第二个 3，那么左右都可以滑动，当其滑动到第二个 1 时同理。</li>
</ol>
<p>关于第一种是目前流行最广的方法，如果大家想查看详细的说明可以参考下面这篇文章(网上随便找的，对可靠性不作担保啊)：<br><a href="http://blog.csdn.net/zhiyuan0932/article/details/52673169">ViewPager真正的无限轮播</a>  </p>
<p>关于第二种方式，严格意义上分析是会在滑动过程中产生生硬的跳动的。不过有位江湖义士声称已经解决了这种不和谐情况的发生，附上文章地址（可靠性更不作担保啊）：<br><a href="http://blog.csdn.net/anyfive/article/details/52525262">打造真正的无限循环viewpager</a> (不负责的我真的没有测试这个可靠性，大家闲的测试下，如果效果不好的话，告诉我，我赶快把这个链接删除~~)  </p>
<h2 id="自定义-ViewPager-的切换效果"><a href="#自定义-ViewPager-的切换效果" class="headerlink" title="自定义 ViewPager 的切换效果"></a>自定义 ViewPager 的切换效果</h2><p>本来最近封装一个了 ViewPager 十八般花样、样样都有的 PageTransformer 动效库，想着前面少啰嗦点，然后把这章作为重点来讲的。没想到前面还是啰里啰嗦这么多（恍然间，我好像找到自己一直撩妹不成功单身的原因了~），好了，步入正题。  </p>
<p>关于 ViewPager 的切换动画，官方提供了一个内部接口 ViewPager.PageTransformer 来供我们实现自定义切换动效。这个接口里只提供了一个方法 <code>public void transformPage(View view, float position)</code>,但是千万不要小看了这两个方法，这里面的道道有很多呢。  </p>
<p>transformPage 方法两个参数，一个是 View ，这个好理解就是当前要设置动效的页面。这个页面并不单单是指当前显示的页面，即将滑出的页面、即将滑入的页面、已经隐藏的页面，也就是说这个 View 是指所有的页面。那如何分辨 View 到底是指哪个页面呢，这个需要根据第二个参数 position 来辨别。  </p>
<p>你千万不要把 position 理解成了 ViewPager 页面的下标，一定要看仔细，这个 position 可是 float 类型，下标怎么可能是浮点型呢！  </p>
<p>从 doc 注释来看，当前选中的 item 的 position 永远是 0 ，被选中 item 的前一个为 -1，被选中 item 的后一个为 1。  </p>
<blockquote>
<p>其实这里文档的描述并不是完全正确的，前后 item position 为 -1 和 1 的前提是你没有给 ViewPager 设置 pageMargin。<br>如果你设置了 pageMargin，前后 item 的 position 需要分别加上（或减去，前减后加）一个偏移量（偏移量的计算方式为 pageMargin / pageWidth）。</p>
</blockquote>
<p>在用户滑动界面的时候，position 是动态变化的，下面以左滑为例（以向左为正方向）:  </p>
<ul>
<li>选中 item 的 position：<code>从 0 渐至 -1 - offset (pageMargin / pageWidth)</code></li>
<li>前一个 item 的 position：<code>从 -1 渐至 -1 - offset (pageMargin / pageWidth)</code></li>
<li>前两个 item 的 position：<code>从 -2 渐至 -2 - offset (pageMargin / pageWidth)</code>，再往前就以此类推</li>
<li>后一个 item 的 position：<code>从 1 + offset (pageMargin / pageWidth) 渐至 0</code>，再往后就以此类推</li>
</ul>
<p>每一次滑动，每个 View 对应的 position 是一个在一个区间范围内动态渐变的过程，所以我们可以将 position 的值应用于 setAlpha(), setTranslationX(), 或者 setScaleY() 等等方法，从而实现自定义的切换动画有一个渐变的效果。  </p>
<p>这里给大家举一个视差切换动效的实现方式，我们先来看一下效果：  </p>
<p><img src="">  </p>
<p>其实实现起来很简单，就是滑动时给页面再设置一个页面横向滑动的动画，让页面实现滑动的速度慢于手指滑动的速度，这样就会有种视差的效果：  </p>
<pre><code>@Override
public void transformPage(View page, float position) &#123;
    int width = page.getWidth();
    //我们给不同状态的页面设置不同的效果
    //通过position的值来分辨页面所处于的状态
    if (position &lt; -1) &#123;//滑出的页面
        page.setScrollX((int) (width * 0.75 * -1));
    &#125; else if (position &lt;= 1) &#123;//[-1,1]
        if (position &lt; 0) &#123;//[-1,0]
            page.setScrollX((int) (width * 0.75 * position));
        &#125; else &#123;//[0,1]
            page.setScrollX((int) (width * 0.75 * position));
        &#125;
    &#125; else &#123;//即将滑入的页面
        page.setScrollX((int) (width * 0.75));
    &#125;
&#125;
</code></pre>
<p>其实这里处于大于1或者小于-1的状态的页面都好理解。需要详细讲解的就是 [-1,1] 这个区间状态的页面。大家可以想象一下：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/2625875-baad38875b79d28e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="像左滑动">  </p>
<p>由上图可以看出，当滑动时，（如果没有偏移量）界面上最多出现两个 item，一个即将滑出即将隐藏的页面（postion变化为：从0渐到-1），一个滑入即将完全显示的页面（postion变化为：从1渐到0）。  </p>
<p>这样给每个不同状态的页面设置不同的动效就达到我们想要的目的了。回到上面例子中的代码，刚才那位大兄弟又说话了，你的代码明明 [0 -&gt; -1] 和 [1 -&gt; 0] 两个状态的 item 设置的是一样的动效啊。这里只是代码一样，动效实际上是不一样的，因为一个position 是大于 0 的，一个 position 是小于 0 的，滑动的方向自然是相反的。难道你非得让我写成 <code>page.setScrollX((int) (width * -0.75 * -position))</code> 这样吗？  </p>
<p>想实现更多炫酷的动效，可以查看为大家封装好的 <a href="https://github.com/OCNYang/PageTransformerHelp">PageTransformerHelp</a> 库，GitHub地址：<a href="https://github.com/OCNYang/PageTransformerHelp">https://github.com/OCNYang/PageTransformerHelp</a>  </p>
<h2 id="ViewPager-切换效果进阶"><a href="#ViewPager-切换效果进阶" class="headerlink" title="ViewPager 切换效果进阶"></a>ViewPager 切换效果进阶</h2><p>其实上面已经把该讲的自定义的方面都讲的很清楚了；整个梳理下来，上面一开始给大家列举的着重强调的几个 ViewPager 的动态设置的方法就剩 <code>setPageMargin(int marginPixels)</code> 没有说了，那么这个方法又会给我们带来什么样的神奇效果呢？  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/2625875-2943a568192d49d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="界面能够同时看到多个 item">  </p>
<p>那是如何实现上面这种效果呢，可以肯定的是：两边两个 item 被缩小且透明度变低，是通过设置上面所说的自定义动效完成的。那如何在一个界面能够同时看到 3 个 item 呢？那么就通过下图的分析和解释告诉实现的原理：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/2625875-1adab76ec6530b6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="卡片式轮播效果实现原理分析">  </p>
<p>看了上面的解释有没有一种恍然大悟，迫不及待想试试的冲动？如果通过上图仍然略有疑惑可以看看鸿洋大神的这篇文章，可以说是很全面了：<br><a href="http://blog.csdn.net/lmj623565791/article/details/51339751">巧用ViewPager 打造不一样的广告轮播切换效果</a>  </p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>到此，ViewPager 的基本使用方式已经讲的差不多了。想查看更多 切换动画 的效果，可以到本文的源码地址进行查看。  </p>
<p><strong>源码地址</strong>：<br><a href="https://github.com/OCNYang/PageTransformerHelp">https://github.com/OCNYang/PageTransformerHelp</a>  </p>
<p>参考文章：<br><a href="http://blog.csdn.net/lmj623565791/article/details/51339751">http://blog.csdn.net/lmj623565791/article/details/51339751</a><br><a href="http://blog.csdn.net/qq_30716173/article/details/51589251">http://blog.csdn.net/qq_30716173/article/details/51589251</a>  </p>
]]></content>
      <categories>
        <category>Android教程系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ViewPager</tag>
      </tags>
  </entry>
  <entry>
    <title>常用电脑软件你选对了吗？</title>
    <url>/2017/01/05/WindowSoftware/</url>
    <content><![CDATA[<p><img src="http://img.shedoor.net/ocnyang/windows/window.jpg" alt="常用电脑软件你选对了吗？"></p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在公司同事们都认为我是电脑高手，每当有新同事加入，总会找到我让我帮忙在办公桌上组装新的机器使用。同事平时也会找到我修理一下电脑什么的，可是我真的只是一个敬业的程序员啊。  </p>
<p>昨天，一女同事又找到我，抱怨她的电脑不知怎么了最近几天卡的要死，让我帮忙看看。其实我的内心对修电脑是拒绝的，但是毕竟是女同事更何况自己还是单身狗，从这方面出发我对帮女同事内心还是接受的。嘿嘿嘿~~~  </p>
<p>经过我仔细查看一番，其实没什么大的问题，一方面是电脑每次关开机都会更新系统，直接禁止；一方面是开机自启动程序过多，造成开机速度变慢；另一方面，电脑中安装了很多垃圾软件（大多是一些流氓软件捆绑式的软件）；妹纸毕竟是妹纸，对软件的安装和卸载没有一个完善的概念，一个电脑上光电脑管家就安装了3个：腾讯电脑管家，360全家桶，金山管家杀毒等等，一开机全在后台运行，电脑不卡才怪呢！  </p>
<p>其实自己呢，真的不是什么大牛，只是我这个人使用电脑有一点洁癖，垃圾软件、没什么用没必要的软件一概卸载，不然存在电脑里心里总是感觉不爽。同时自己安装软件什么的都会安装到特定的地方，电脑稍显零乱自己都会感到别扭。  </p>
<p>这篇文章以实用高效为出发点对电脑使用时工具集合的一个总结，从如何选择属于自己的电脑机器及选择自己要安装的操作系统，到 Windows 系统最常用最高效的必备软件，最后到开发人员必备的高效工具。下面让我们一起来寻找一些适合自己的好用软件。</p>
<h2 id="硬件购买"><a href="#硬件购买" class="headerlink" title="硬件购买"></a>硬件购买</h2><p><strong>笔记本</strong>  </p>
<p>这里只从开发机器的方向提供几种选择：  </p>
<ol>
<li>MacBook Pro （同样是图形工作者首选）；</li>
<li>Dell XPS 系列；</li>
<li>ThinkPad T 系列；  </li>
</ol>
<p>如果你是从玩游戏的方向出发选择笔记本的话，钱多任性就 <code>Alienware</code>，没钱还追求配置的就 <code>神舟战神Z系</code>,综合考虑就 <code>惠普暗影</code> 或其他。  </p>
<p>如果你是图形或者视频工作者，MacBook Pro、苹果垃圾桶、ThinkPad工作站、微软 Surface Studio也出来了、等等，你们对配置有自己独特的追求，相信你们比我更懂得选择。  </p>
<p><strong>台式机</strong>  </p>
<p>开发的话苹果 iMac 一体机相信你一定会考虑的。  </p>
<p>另外提供几个组装机的平台，希望大家别掉到深水里了，至少避开奸商偷袭的吧：</p>
<ol>
<li>京东装机大师 - <a href="http://diy.jd.com/">http://diy.jd.com/</a>  </li>
<li>萌叔装机好福哟 - <a href="https://shironeko.taobao.com/">https://shironeko.taobao.com</a></li>
<li>ZOL中关村在线模拟攒机 - <a href="http://zj.zol.com.cn/">http://zj.zol.com.cn/</a> （这里还有很多网友提供的完美配置单大家可以参考）  </li>
</ol>
<blockquote>
<p>对于<a href="http://detail.zol.com.cn/">中关村在线</a>这个数码产品报价网站，虽然它已不复当年的辉煌，也几经易主，对于我个人来说，对它还是很信赖的。  </p>
</blockquote>
<p><strong>配件</strong>  </p>
<p>鼠标、机械键盘、座椅、显示器等等大家对应自己的癖好选择吧。  </p>
<p>这里值得一提的机器配置方面的，无论你选择哪款笔记本或台式机，或者你想让自己战斗多年的机器能够满血复活重现昔日风采，目前来说对机器提升最大的就是 **<code>SSD 固态硬盘</code>**。性能提升一倍那绝对不是空谈，大家可以自主动手给自己的机器添加一块SSD,一般来说 256G 的就足够使用了。另外现在来看，内存方面大家一般比较青睐 16G，8G 也基本上能够满足需求。  </p>
<blockquote>
<p><strong>SSD固态硬盘注意点</strong>：目前固态硬盘有多种规格，如果大家考虑自主添加的话  </p>
<ul>
<li>添加位置：首先大家要考虑的是机器本身有没有带 SSD硬盘接口位。另外可以考虑添加到光驱位。  </li>
<li>规格型号：确定好添加位置后，可以上网查询一下，自己的机器支持的是哪种规格的SSD，如果不提前计划好，买了不能不适合的规格到时候肯定有不少麻烦。  </li>
</ul>
</blockquote>
<p><strong>操作系统</strong>  </p>
<p>机器什么都准备好了，那就是选择使用什么系统了，这里提供各种系统的选择：  </p>
<ol>
<li><strong>Windows 7</strong> 普通用户或公司办公追求稳定的选择<br>MSDN资源地址：<a href="http://itellyou.cn/">http://itellyou.cn/</a></li>
<li><strong>Windows 10</strong> 说实话，这是一个不错的系统，值得尝试<br>官方 Windows 10 下载安装器：<a href="https://www.microsoft.com/zh-cn/software-download/windows10">https://www.microsoft.com/zh-cn/software-download/windows10</a><br>Windows 10教程：<a href="https://www.zhihu.com/question/32129337">如何优雅地使用 Windows 10 ？</a>  </li>
<li><strong>Ubuntu</strong> 其实尝试一个新系统，只是你一个决心的事情<br>下载 Ubuntu：<a href="http://cn.ubuntu.com/download/">http://cn.ubuntu.com/download/</a><br>Linux 发行版本太多了，Ubuntu 的衍生版本就很多，至于选择那种版本，老鸟们都有自己的看法，小白都是一脸懵逼的表情。这里个人推荐原生 <strong><code>Ubuntu 16.04 LTS(长期支持)版本</code></strong>,一点也不想折腾的可以选择 **<code>优麒麟 16.04 LTS(长期支持)版本</code>**。  </li>
<li><strong>macOS</strong> 用苹果笔记本你可以走了，这里要说的是黑苹果的安装<br>其实现在的机器对苹果的兼容性已经很好了，一般情况下不会出现太多问题。这里给大家推荐一家国外专门为 <code>安装黑苹果</code> 提供指导的网站。<br>网站地址（英文）：<a href="https://www.tonymacx86.com/">tonymacx86.com</a><br>这里提供了安装黑苹果的详细教程，及其遇到各种问题的解决方案，真个不能再详细了。<br>值得一提的是，这个网站还向大家提供了很多安装黑苹果的台式机采购单（配置单）。如果自己通过组装机来安装苹果系统，基本上是全面兼容的，并且你完全可以给自己的机器配置上一个强大的显卡，那性能肯定完爆 Mac 等啊，想想是不是就很激动。  </li>
</ol>
<h2 id="常用软件（这里针对-Windows）"><a href="#常用软件（这里针对-Windows）" class="headerlink" title="常用软件（这里针对 Windows）"></a>常用软件（这里针对 Windows）</h2><h3 id="效率神器"><a href="#效率神器" class="headerlink" title="效率神器"></a>效率神器</h3><p>这里先推荐一款特色的软件。  </p>
<p><strong>Listary</strong><br>如果Mac下的Alfred作为排名第一的效率工具类神器，那 Listary 享此盛誉也不为过，正在使用 <strong>Launchy / Everything / Total Commander</strong> 的真的可以尝试一下。有人还推荐 **<a href="http://www.jeffjade.com/2016/03/11/2016-03-11-autohotkey/">AutoHotKey</a>**，本人没使用过，大家有兴趣的可以尝试下。<br>下载地址：<a href="http://www.listary.com/">http://www.listary.com/</a>  </p>
<h3 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h3><p><strong>Atom</strong><br>开源的新一代编码写文章神器。支持markdown语法。<br>下载地址：<a href="https://atom.io/">https://atom.io/</a><br>使用教程：<a href="http://www.jeffjade.com/2016/03/03/2016-03-02-how-to-use-atom/">新编码神器Atom使用纪要</a></p>
<p><strong>Sublime Text 3</strong><br>这个大家再熟悉不过了，全平台支持，同样是编码垒字的神器，还支持文件对比、查看图片等。<br>下载地址：<a href="https://www.sublimetext.com/3">https://www.sublimetext.com/3</a><br>使用教程：<a href="http://blinkfox.com/atom-geng-xian-dai-hua-de-bian-ji-qi/">Atom-更现代化的编辑器</a>  </p>
<p><strong>NotePad2</strong><br>系统记事本代替软件。  </p>
<p><strong>Markdown</strong><br>语法说明：<a href="http://wowubuntu.com/markdown/">http://wowubuntu.com/markdown/</a><br>编辑器推荐：<a href="https://www.zhihu.com/question/19637157">知乎：用 Markdown 写作用什么文本编辑器？</a><br>在线编辑器：<a href="https://www.zybuluo.com/mdeditor">Cmd Markdown</a> 作业部落也推出客户端了 &amp; <a href="http://www.jianshu.com/u/e61d05cbf47e">简书</a>  </p>
<h3 id="邮件客户端"><a href="#邮件客户端" class="headerlink" title="邮件客户端"></a>邮件客户端</h3><p><strong>Foxmail</strong><br>下载地址：<a href="http://foxmail.com.cn/">http://foxmail.com.cn/</a>  </p>
<p>个人日常在线邮箱建议使用QQ邮箱。<br>投简历还是尽量选择Gmail，实在不行也得选择163邮箱。  </p>
<blockquote>
<p>大家不喜欢 Foxmail 的，并且想收发 Gmail 的可以选择网易邮箱大师客户端（自家的代理服务器）。</p>
</blockquote>
<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p><strong>Google Chrome</strong><br>官方下载地址：<a href="http://chrome.google.com/">http://chrome.google.com/</a><br>由于被墙，使用官方的下载器一般难以下载成功，下面提供国内一位良心网友提供的下载地址：<a href="http://www.chromeliulanqi.com/">http://www.chromeliulanqi.com/</a>  </p>
<p>简洁的界面和精益求精的内核是核心，插件丰富，版本飙得够快。</p>
<blockquote>
<p>Chrome 插件：<a href="https://www.zhihu.com/question/19594682">你极力推荐的 Chrome 扩展有哪些？</a>  </p>
</blockquote>
<p><strong>Firefox 火狐浏览器</strong><br>经久不衰，插件丰富，多平台，同时是Ubuntu默认浏览器。  </p>
<h3 id="媒体处理"><a href="#媒体处理" class="headerlink" title="媒体处理"></a>媒体处理</h3><p><strong>2345看图王</strong><br>速度最快的看图软件<br>ACDSee臃肿，Picasa乏力，专业制图请使用PS<br>下载地址：<a href="http://pic.2345.com/">http://pic.2345.com/</a>  </p>
<p><strong>网易云音乐</strong><br>借用网友的话：“初遇QQ音乐,处过天天动听,恋过酷狗，上过酷我，一夜情过千千静听,移情过虾米，和豆瓣FM好过，同百度随心听约过,最后，发现音乐的世界,还得是你～网易云音乐。”<br>网易再一次用优秀的产品体验为自己赢得了口碑,同时也为 Ubuntu 开发了相应版本，实属业界良心。<br>下载地址：<a href="http://music.163.com/">http://music.163.com</a>  </p>
<p><strong>完美解码</strong><br>高清全能解码播放,基本上没有不能播放的格式。<br>下载地址：<a href="http://jm.wmzhe.com/">http://jm.wmzhe.com/</a>  </p>
<p><strong>格式工厂</strong><br>经常音视频转码必备之一吧。<br>下载地址：<a href="http://www.pcfreetime.com/">http://www.pcfreetime.com/</a>  </p>
<h3 id="数据同步共享-云笔记"><a href="#数据同步共享-云笔记" class="headerlink" title="数据同步共享/云笔记"></a>数据同步共享/云笔记</h3><p><strong>金山快盘</strong><br>百度网盘统一文件共享，360不时捅其菊花，金山不断深耕协同办公，腾讯继续保持蛋疼状态<br>下载地址：<a href="http://www.kuaipan.cn/">http://www.kuaipan.cn/</a>  </p>
<p><strong>Evernote印象笔记</strong><br>笔记类应用除了onenote我只认可它<br>建议搭配金山快盘和Evernote，提高工作效率<br>能通过 Chrome 插件一键保存，同时支持微信公众号、新浪微博、等等第三方分享保存  </p>
<p>下载地址：<a href="http://www.evernote.com/">http://www.evernote.com/</a>  </p>
<blockquote>
<p>现在云笔记有很多，比较各个云笔记各有优缺点：<br><strong>印象笔记</strong>：功能丰富，保存文章格式准确，但是有些功能需要购买高级账号，比如手机本地同步文章。<br><strong>有道云笔记</strong>：分享方便，同时能够分享整个文件夹，整体功能都有，但是各个功能都不完美，网页一键保存格式容易乱。同时笔记保存容易，导出迁移难，只进不出很不地道。<br><strong>为知笔记</strong>：支持 Ubuntu 平台的客户端。功能方面没有太大的亮点，分享比较难。</p>
</blockquote>
<p><strong>有道云协作</strong><br>跨平台支持多人实时协作，可以极大提升团队效率<br>虽然没有直接推荐有道云笔记但对于文字编辑类工作者来说整合使用还是很方便的<br>下载地址：<a href="http://note.youdao.com/groupintro.html">http://note.youdao.com/groupintro.html</a>  </p>
<p><strong>FileGee</strong><br>国内优秀的个人免费本地同步工具<br>下载地址：<a href="http://cn.filegee.com/">http://cn.filegee.com/</a>  </p>
<p><strong>自同步</strong><br>局域网最高效的文件同步、共享工具<br>下载地址：<a href="http://www.zisync.com/">http://www.zisync.com/</a>  </p>
<h3 id="功能软件"><a href="#功能软件" class="headerlink" title="功能软件"></a>功能软件</h3><p><strong>有道词典</strong><br>越做越强，短期内无人能超越<br>下载地址：<a href="http://cidian.youdao.com/">http://cidian.youdao.com/</a>  </p>
<p><strong>好压</strong><br>简单方便，自带虚拟光驱<br>WinRAR，7zip，360压缩也许都很优秀，个人更青睐这个。<br>下载地址：<a href="http://haozip.2345.com/">http://haozip.2345.com/</a>  </p>
<p><strong>Faststone Capture 截图、取色、标尺</strong><br>截图神器+录屏工具<br>下载地址：<a href="http://www.portablesoft.org/faststone-capture/">http://www.portablesoft.org/faststone-capture/</a>  </p>
<p><strong>Mark Man马克鳗</strong><br>高效的设计稿标注、测量工具<br>下载地址：<a href="http://www.getmarkman.com/">http://www.getmarkman.com/</a></p>
<p><strong>MathType</strong><br>最佳数学公式编辑器<br>参考地址：<a href="http://fengqingwuhen.blog.163.com/blog/static/17747406320141019104445935/">Office绿色插件小集</a>  </p>
<p><strong>PDF阅读器</strong>  </p>
<ol>
<li>福昕PDF<br>优秀的个人免费PDF阅读软件<br>简单小巧够用  </li>
<li>Adobe Acrobat<br>需要使用专业功能朋友还是坚持Acrobat吧</li>
</ol>
<p><strong>驱动精灵</strong><br>不重装电脑或者驱动异常，别没事升级驱动，用时下载，用完卸载掉。<br>下载地址：<a href="http://www.drivergenius.com/">http://www.drivergenius.com/</a>  </p>
<p><strong>远程控制</strong>  </p>
<ol>
<li><p>TeamViewer<br>远程控制，内网穿透，VPN共享，跨平台<br>对个人免费，业界良心啊，QQ表示继续努力<br>下载地址：<a href="https://www.teamviewer.com/zhCN/?pid=google.tv_ex.s.cn&gclid=CjwKEAiA17LDBRDElqOGq8vR7m8SJAA1AC0_XgN-32LpaMm8kQCZWHnmMkDcIoSbP2ePpc5fYmXF3hoC67Dw_wcB">www.teamviewer.com</a>  </p>
</li>
<li><p>AnyDesk<br>远程控制效果或许会超出你的想象，作为TeamViewer备用方案<br>下载地址：<a href="http://anydesk.com/">http://anydesk.com/</a>  </p>
</li>
</ol>
<p><strong>Clover 3</strong><br>为您的 Windows Explorer 插上翅膀！<br>Clover 是 Windows Explorer 资源管理器的一个扩展，为其增加类似谷歌 Chrome 浏览器的多标签页功能。<br>下载地址：<a href="http://cn.ejie.me/">http://cn.ejie.me/</a>  </p>
<h3 id="数据备份恢复"><a href="#数据备份恢复" class="headerlink" title="数据备份恢复"></a>数据备份恢复</h3><p><strong>易数一键还原</strong><br>以DiskGenius为内核开发，安全易用靠谱<br>同时推荐ORM一键还原系统<br>下载地址：<a href="http://www.onekeyrestore.cn/">http://www.onekeyrestore.cn/</a>  </p>
<p><strong>DiskGenius</strong><br>国内磁盘分区和数据恢复的佼佼者<br>下载地址：<a href="http://pan.baidu.com/s/1kTj3b75">http://pan.baidu.com/s/1kTj3b75</a>  </p>
<h3 id="广告屏蔽"><a href="#广告屏蔽" class="headerlink" title="广告屏蔽"></a>广告屏蔽</h3><p><strong>阿呆猫</strong><br>ADSafe名气太响受到制约，移动端去广告可继续使用<br>发现上网异常请自觉停用此类去广告软件<br>下载地址：<a href="http://www.admflt.com/">http://www.admflt.com/</a>  </p>
<p><strong>ADSafe净网大师</strong><br>目前国内强大的去广告软件,不仅可以去除网页广告,更重要的是可以过滤视频广告，但是人怕出名猪怕壮，下载很多视频网站虽然能够屏蔽广告，但是广告读秒依然在。有时候对电脑上网造成异常。<br>下载地址：<a href="www.ad-safe.com/">www.ad-safe.com/</a>  </p>
<p><strong>AdBlock Chrome浏览器广告屏蔽插件</strong><br>Chrome 必备插件之一  </p>
<h2 id="专业软件"><a href="#专业软件" class="headerlink" title="专业软件"></a>专业软件</h2><p><strong>FreeMind</strong><br>免费简单好用的思维脑图工具<br>XMind，Mindjet MindManager或许更专业<br>下载地址：<a href="http://sourceforge.net/projects/freemind/">http://sourceforge.net/projects/freemind/</a>  </p>
<p><strong>Cmder</strong><br>windows下cmd的替换工具,支持 PowerShell;同比还有 PowerShell，ConEmu 等。<br>下载地址：<a href="https://github.com/cmderdev/cmder/releases">https://github.com/cmderdev/cmder/releases</a>  </p>
<p><strong>Git</strong><br>分散式版本控制工具，无需多说。<br>下载地址：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>  </p>
<p><strong>Git for Windows</strong><br>官网下载安装真的很难，打包好了，直接使用；Git 一族必备。<br>下载地址：<a href="https://git-for-windows.github.io/">https://git-for-windows.github.io/</a>  </p>
<p><strong>Nodejs</strong><br>可以辅助让Sublime编译Js；可以做Web开发，REST开发，Web聊天室/爬虫，Web博客(Hexo)，Web论坛等等，可参见<a href="http://www.nodejs.net/a/20141016/233306.html">分享十五个NodeJS应用场景</a>；还可以利用Nodejs的包管理器Npm 安装Gulp Webpack等屌炸天工具～做大多你可以想到的东东；Web端必备。<br>下载地址：<a href="https://nodejs.org/">https://nodejs.org/</a>  </p>
<p><strong>Hexo</strong><br>搭建个人博客网站框架。<br>官方地址：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a><br>个人推荐 <a href="https://github.com/iissnan/hexo-theme-next">NexT</a> 主题,网站效果可以查看：<a href="http://ocnyang.com/">http://ocnyang.com/</a>  </p>
<p><strong>Beyond Compare</strong><br>对比两个版别的软件源代码在哪些地方有修正，用它就对了。可谓是程序员至必备工具。<br>下载地址：<a href="www.beyondcompare.cc/xiazai.html">www.beyondcompare.cc/xiazai.html</a>  </p>
<p><strong>Navicat</strong><br>Navicat是一个可多重连接的数据库管理工具，它可以连接到MySQL、Oracle、PostgreSQL、SQLite、SQL Server和/或MariaDB数据库，让数据库管理更加方便。它在程序员中的应用就不错说了。<br>官方地址：<a href="https://www.navicat.com.cn/">https://www.navicat.com.cn/</a>  </p>
<p><strong>VMware</strong><br>VMware虚拟机软件，提供服务器、桌面虚拟化的解决方案，支持一个虚拟机同时使用四个物理处理器，和VMFS,它能使多个ESX服务器分享块存储器。<br>官方地址：<a href="www.vmware.com/">www.vmware.com/</a>  </p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>终于写完了，中间肯定还遗漏很多。想起来后续会逐渐更新上去。  </p>
<blockquote>
<p>参考文章：<br><a href="http://www.jeffjade.com/2015/10/19/2015-10-18-Efficacious-win-software/">http://www.jeffjade.com/2015/10/19/2015-10-18-Efficacious-win-software/</a><br><a href="https://wsgzao.github.io/post/windows/">https://wsgzao.github.io/post/windows/</a><br><a href="http://jingyan.baidu.com/article/ad310e80c0c7f11848f49e7d.html">http://jingyan.baidu.com/article/ad310e80c0c7f11848f49e7d.html</a><br><a href="http://fengqingwuhen.blog.163.com/blog/static/17747406320141019104445935/">http://fengqingwuhen.blog.163.com/blog/static/17747406320141019104445935/</a><br><a href="http://www.cnblogs.com/peiqianggao/p/4956451.html">http://www.cnblogs.com/peiqianggao/p/4956451.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>原创</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>详解 Android 通信</title>
    <url>/2017/02/13/AndroidComm/</url>
    <content><![CDATA[<blockquote>
<p>一文详尽 Android 通信：四大组件之间 &amp; 进程间 &amp; 线程间 &amp; 多个App间</p>
</blockquote>
<p><img src="http://img.shedoor.net/ocnyang/android_comm/androidcomm.jpg">  </p>
<span id="more"></span>

<h2 id="本文大纲"><a href="#本文大纲" class="headerlink" title="本文大纲"></a>本文大纲</h2><p><strong>看完本文能收获什么？按目录索引，你可以学习到：</strong></p>
<ol>
<li><p>组件间的通信，Activity，fragment，Service， Provider，Receiver</p>
</li>
<li><p>进程间的通信，AIDL</p>
</li>
<li><p>线程间的通信，Handler，AnsycTask，IntentService</p>
</li>
<li><p>多个App间的通信</p>
</li>
<li><p>使用大型开源框架完成组件通信，EventBus，otto</p>
</li>
</ol>
<p><strong>建议阅读本文时遵循以下学习思路</strong></p>
<ol>
<li><p>研究对象：Activity，fragment等组件</p>
</li>
<li><p>信息存在形式：Intent，Bundle，静态变量，全局变量，还是点击事件，触摸事件的回调监听，或者文件形式（Sharepreference，SQLite，File , NetStream） ，本质就是信息源</p>
</li>
<li><p>信息传递的形式：网路，回调监听，线程，Intent，全局Application</p>
</li>
<li><p>相同形式的思路，不会出现第二次，请读者举一反三</p>
</li>
<li><p>最后强调研究对象是单一的</p>
</li>
</ol>
<h2 id="Activity通信"><a href="#Activity通信" class="headerlink" title="Activity通信"></a>Activity通信</h2><h3 id="Activity-和-Activity"><a href="#Activity-和-Activity" class="headerlink" title="Activity 和 Activity"></a>Activity 和 Activity</h3><p><strong>1. 常规方式：Intent Bundle</strong></p>
<p>通过Intent 启动另一个Activity时，有两种重载方式：</p>
<pre><code>startActivity(new Intent(),new Bundle());
startActivityForResult(new Intent(),FLAG,new Bundle());
</code></pre>
<p>从参数列表就可以总结出来，有Intent，和Bundle,可以传递8种基本数据类型和可序列化的数据类型，比如字符串和字节数组。提到可序列化，就引发 Intent和Bundle 的局限性了:</p>
<ol>
<li>Intent Bundle 无法传递“不可序列化”的数据，比如Bitmap，InputStream，解决办法有很多种，最简单的就是将“不可序列化”的对象，转换成字节数组，这里因为主要是讲解通信，所以不展开讲了。  </li>
<li>Intent Bundle 能传递的数据大小在40K以内 。  </li>
</ol>
<blockquote>
<p>很多人不理解为什么把Intent和Bundle放在一起谈，因为Intent 底层存储信息的原理也是通过Bundle存储！</p>
</blockquote>
<p><strong>2. 公有静态变量</strong></p>
<p>比如 <code>public static String flag=“杨欧神”；</code></p>
<p>使用方式 比如在其他Activity当中 <code>FirstActivity.flag=“OCNYang”;</code> 修改静态变量的值</p>
<p><strong>3. 基于物理形式：</strong></p>
<p>比如 <strong><code>File，SQLite，Sharepreference</code></strong> 物理形式</p>
<p><strong>4. 全局变量：</strong></p>
<p>比如Application：Application是与Activity，Service齐名的组件，非常强大，它的特点是全局组件共用，单例形式存在，在其他组件中，我们只需要 <code>Context.getApplication（）</code> 获得该对象的引用即可</p>
<h3 id="Activity-和-Fragment，Service，BrodcastReceiver"><a href="#Activity-和-Fragment，Service，BrodcastReceiver" class="headerlink" title="Activity 和 Fragment，Service，BrodcastReceiver"></a>Activity 和 Fragment，Service，BrodcastReceiver</h3><p>首先都遵循，如何启动它们，就如何传递信息的原则：</p>
<p><strong>1. Activity与Fragment</strong></p>
<p><code>1. 通过构造函数传递</code>  <code>2. 获取Fragment的实例对象</code>   </p>
<pre><code>//CustFragment 是自定义的fragment，参数列表也可以自己定义咯，
getSupportFragmentManager().beginTransaction()
             .add(new CustFragment(自定义的的参数列表),new String(&quot;参数&quot;))

//------------------method two-----------------------
getSupportFragmentManager().findFragmentById(R.id.headlines_fragment);
//------------------method three----------------------
getSupportFragmentManager().findFragmentByTag(&quot;HeadLines&quot;);
</code></pre>
<blockquote>
<p>聪明的读者可能会问Fragment如何与Activity通信类似的问题，这是个好问题，请注意我们的研究的原则是单一目标原则，在这节我研究的是Activity，你的疑惑在后面都会一一解答  </p>
</blockquote>
<p><strong>2. Activity与Service</strong></p>
<p>Activity启动Service的两种方式：</p>
<pre><code>//CustomService 是自定义Service，完成一些后台操作

startService(new Intent(FirstActivity.this，CustomService.class));

bindService(new Intent(FirstActivity.this，CustomService.class)), new ServiceConnection() &#123;
          @Override
          public void onServiceConnected(ComponentName name, IBinder service) &#123;
              //当前启动的service 一些数据就会回调回这里，我们在Activity中操作这些数据即可
              get
          &#125;

          @Override
          public void onServiceDisconnected(ComponentName name) &#123;

          &#125;
      &#125;,flags);
</code></pre>
<p>从启动方式就可以看出，通过Bundle对象的形式存储，通过Intent传输，来完成Activity向Service传递数据的操作</p>
<p><strong>3. Activity与BroadcastReceiver</strong></p>
<p>启动广播的形式也有两种:</p>
<pre><code>//method one ！！！-----------------------------------------------
registerReceiver(new BroadcastReceiver() &#123;
          @Override
          public void onReceive(Context context, Intent intent) &#123;

          &#125;
      &#125;,new IntentFilter(),&quot;&quot;,new Handler());

//method two ！！！-----------------------------------------------
registerReceiver(new BroadcastReceiver() &#123;
          @Override
          public void onReceive(Context context, Intent intent) &#123;

          &#125;
      &#125;,new IntentFilter());  
</code></pre>
<blockquote>
<p>关于method one 的第三个参数Handler很多人会很费解<br>参照registerReceiver中源码关于该Handler参数的解释：<br><code>Handler identifying the thread that will receive the Intent. If null, the main thread of the process will be used.</code><br>定义了一个用于接收Intent的子线程，如果不填或者默认为null，那么就会在主线程中完成接收Intent的操作  </p>
</blockquote>
<p>很明显，Activity与BroadcastReceiver通信时，用的也是Intent传递，Bundle存储。</p>
<p><strong>4. 通讯时的同步问题</strong></p>
<blockquote>
<p>这里的同步通讯问题，为下文Fragment通讯作铺垫，不是这个问题不重要，不值得引起你注意，只是我想把问题放在它最应该出现的位置。</p>
</blockquote>
<p>以上只是基础的传递数据的形式，大部分都是静态的，现在有一种需求，用户操作Activity，发出了某些指令，比如按下，滑动，触摸等操作，如何完成这些信息传递呢？这就要求同步了。</p>
<p>同步传递消息也很简单，就是调用系统写好的回调接口</p>
<p>首先我们要知道，用户 点击，触摸 这些行为 也属于 通信的范畴—点击和触摸属于 信息源；<br>比如用户行为进行点击，那就实现 ：</p>
<pre><code>new Button(mCotext).setOnClickListener(new View.OnClickListener() &#123;
       @Override
       public void onClick(View v) &#123;
           new ImageView(mCotext).invalidate();
       &#125;
   &#125;);
</code></pre>
<p>通过此招提示指定的ImageView：嘿！老兄，你该刷新了</p>
<p>又或者 当用户 进行触摸操作，我们需要实现放大缩小平移指定的区域：</p>
<pre><code>new RelativeLayout(mCotext).setOnTouchListener(new View.OnTouchListener() &#123;
          @Override
          public boolean onTouch(View v, MotionEvent event) &#123;
              //缩放
              v.setScaleX(1f);
              v.setScaleY(1f);
              //平移
              v.setTranslationX(1f);
              v.setTranslationY(1f);
              v.setTranslationY(1f);
              //旋转
              v.setRotation(2f);
              v.setRotationX(2f);
              v.setRotationY(2f);

              v.invalidate();
              return true;
          &#125;
      &#125;);
</code></pre>
<p>嘿，你看，当用户进行触摸操作，我们可以通过回调onTouchListenter来完成“触摸”这一操作</p>
<blockquote>
<p>关于View重绘机制以及优化刷新UI的细节，不属于本文讨论范围。</p>
</blockquote>
<h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><h3 id="1-Fragment-与Activity通信"><a href="#1-Fragment-与Activity通信" class="headerlink" title="1. Fragment 与Activity通信"></a>1. Fragment 与Activity通信</h3><p>通过实例对象传递</p>
<p>同样的，在 Fragment 中 <code>getActivity()</code> 可以获取到它相关联的 Activity 实例，就可以轻松获取并且修改 Activity 的数据。</p>
<h3 id="2-Fragment-与-多个Fragment通信"><a href="#2-Fragment-与-多个Fragment通信" class="headerlink" title="2. Fragment 与 多个Fragment通信"></a>2. Fragment 与 多个Fragment通信</h3><p>首先，两个Fragment之间不可能直接通信（非正规因素除外），Google官方提出的解决办法是 通过相关联的Activity来完成两个Fragment的通信</p>
<p>只需要记住三步：</p>
<p><strong>1. 定义一个接口：</strong></p>
<p>在让Fragment关联Activity之前，可以在Fragment中定义一个接口，然后让宿主Activity来实现这个接口。接着，在Fragment中捕获这个接口，并且在onAttach()中 捕获Activity实例</p>
<pre><code>//只需关注接口是如何定义的，以及onAttack中的实现
public class HeadlinesFragment extends ListFragment &#123;
    //定义的接口引用
    OnHeadlineSelectedListener mCallback;

    // 自定义回调接口，宿主Activity必须要实现它
    public interface OnHeadlineSelectedListener &#123;
        public void onArticleSelected(int position);
    &#125;

    @Override
    public void onAttach(Activity activity) &#123;
        super.onAttach(activity);

        // 在这里只是为了确保Activity实现了我们定义的接口，如果没有实现，则抛出异常
        try &#123;
            mCallback = (OnHeadlineSelectedListener) activity;
        &#125; catch (ClassCastException e) &#123;
            throw new ClassCastException(activity.toString()
                    + &quot; must implement OnHeadlineSelectedListener&quot;);
        &#125;
    &#125;

    ...
&#125;
</code></pre>
<p>一旦 Activity 通过 <code>OnHeadlineSelectedListener</code> 的实例 mCallBack 回调  <code>onArticleSelected（）</code> ，Fragment 就可以传递信息给 Activity 了</p>
<p>例如 下面是 ListFragment 的一个回调方法，当用户点击了 list 中的 item，这个 Fragment 就会通过回调接口向宿主 Activity 传递事件</p>
<pre><code>@Override
   public void onListItemClick(ListView l, View v, int position, long id) &#123;
       // 向Activity传递事件信息
       mCallback.onArticleSelected(position);
   &#125;
</code></pre>
<p><strong>2. 在宿主Activity实现这个接口</strong></p>
<p>怎么实现？很简单，参考下面代码：</p>
<pre><code>public static class MainActivity extends Activity
        implements HeadlinesFragment.OnHeadlineSelectedListener&#123;
    ...

    public void onArticleSelected(int position) &#123;
        // 用户从从 HeadlinesFragment选中了一个标题
        //响应用户的操作，做一些业务逻辑
    &#125;
&#125;
</code></pre>
<p><strong>3. 向其他Fragment传递信息 （完成通信）</strong></p>
<p>宿主Activity可以通过findFragmentById()向指定的Fragment传递信息，宿主Activity可以直接获取Fragment实例，回调Fragment的公有方法</p>
<p>例如：</p>
<p>宿主Activity 包含了一个Listfragment用来展示条目信息，当每个条目被点击的时候，我们希望ListFragment向另外一个DetailsFragment传递一个信息用来 展示不同的细节</p>
<pre><code>public static class MainActivity extends Activity
        implements HeadlinesFragment.OnHeadlineSelectedListener&#123;
    ...

     public void onArticleSelected(int position) &#123;
        // 用户在 HeadlinesFragment中选中了一个item

        //在activity中添加新的fragment
        ArticleFragment articleFrag = (ArticleFragment)
                getSupportFragmentManager().findFragmentById(R.id.article_fragment);

        if (articleFrag != null) &#123;
            // If article 对象 可以复用, 我们就不需要创建两遍了

            // 回调articleFrag 更新
            articleFrag.updateArticleView(position);

        &#125; else &#123;
            // 创建 Fragment 并为其添加一个参数，用来指定应显示的文章
            ArticleFragment newFragment = new ArticleFragment();
            Bundle args = new Bundle();
            args.putInt(ArticleFragment.ARG_POSITION, position);
            newFragment.setArguments(args);

            FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();

            // 将 fragment_container View 时中的内容替换为此 Fragment ，
            // 然后将该事务添加到返回堆栈，以便用户可以向后回滚
            transaction.replace(R.id.fragment_container, newFragment);
            int setTransition=TRANSIT_FRAGMENT_OPEN;
            transaction.setTransition(setTransition);
            transaction.addToBackStack(null);

            // 执行事务
            transaction.commit();
        &#125;
    &#125;
&#125;
</code></pre>
<p>下面我写了一个实例来供大家理解：</p>
<p>各个类的联系图：</p>
<p><img src="http://img.shedoor.net/ocnyang/android_comm/%E9%80%9A%E4%BF%A1fragment.jpg">  </p>
<p>这里写图片描述</p>
<p>效果如下：</p>
<p><img src="http://img.shedoor.net/ocnyang/android_comm/Fragment%E9%80%9A%E4%BF%A1_gif.gif">  </p>
<p>这里写图片描述</p>
<p><a href="http://download.csdn.net/detail/chivalrousman/9545616">Fragment 通信 Demo 实例</a>  </p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h3 id="Service-与-Activity-通信"><a href="#Service-与-Activity-通信" class="headerlink" title="Service 与 Activity 通信"></a>Service 与 Activity 通信</h3><p>主要是如何获得Service实例的问题<br>总结来说两步：</p>
<ol>
<li><p>在Service定义内部类，继承Binder，封装Service作为内部类的属性，并且在onBind方法中返回内部类的实例对象  </p>
</li>
<li><p>在Activity中实现ServiceConnection ，获取到Binder对象，再通过Binder获取Service</p>
<blockquote>
</blockquote>
<p> public class LocalService extends Service {</p>
<pre><code> // 传递给客户端的Binder
 private final IBinder mBinder = new LocalBinder();
 //构造Random对象
 private final Random mGenerator = new Random();

 /**
  * 这个类提供给客户端  ，因为Service总是运行在同一个进程中的
  */
 public class LocalBinder extends Binder &#123;
     LocalService getService() &#123;
         // 当客户端回调的时候，返回LoacalService实例
         return LocalService.this;
     &#125;
 &#125;

 @Override
 public IBinder onBind(Intent intent) &#123;
     return mBinder;
 &#125;

 /**交给客户端回调的方法 */
 public int getRandomNumber() &#123;
   return mGenerator.nextInt(100);
 &#125;
</code></pre>
<p> }</p>
<p> public class BindingActivity extends Activity {</p>
<pre><code> LocalService mService;
 boolean mBound = false;

 @Override
 protected void onCreate(Bundle savedInstanceState) &#123;
     super.onCreate(savedInstanceState);
     setContentView(R.layout.main);
 &#125;

 @Override
 protected void onStart() &#123;
     super.onStart();
     // 绑定 LocalService
     Intent intent = new Intent(this, LocalService.class);
     bindService(intent, mConnection, Context.BIND_AUTO_CREATE);
 &#125;

 @Override
 protected void onStop() &#123;
     super.onStop();
     // 解绑 service
     if (mBound) &#123;
         unbindService(mConnection);
         mBound = false;
     &#125;
 &#125;

 /**button已经通过 android:onClick (attribute) 设置此方法响应用户click*/
 public void onButtonClick(View v) &#123;
     if (mBound) &#123;
         // 回调 LocalService的方法.
         //因为在主线程中刷新UI，可能会造成线程阻塞，这里只是为了测试
         int num = mService.getRandomNumber();
         Toast.makeText(this, &quot;number: &quot; + num, Toast.LENGTH_SHORT).show();
     &#125;
 &#125;

 /**定义通过bindService 回调的Binder */
 private ServiceConnection mConnection = new ServiceConnection() &#123;

     @Override
     public void onServiceConnected(ComponentName className,
             IBinder service) &#123;
        //先通过Binder获得Service的内部类 LoacalBinder
         LocalBinder binder = (LocalBinder) service;
          // 现在可以获得service对象了
         mService = binder.getService();
         mBound = true;
     &#125;

     @Override
     public void onServiceDisconnected(ComponentName arg0) &#123;
         mBound = false;
     &#125;
 &#125;;
</code></pre>
<p> }</p>
</li>
</ol>
<p>除了这种回调的方式外</p>
<p>还有一种方式 是在Service中 发送广播，</p>
<p>比如 在 Service 中 开启了一个子线程执行任务，就在子线程的 run() 方法中去 <code>sendBroadcast(intent);</code><br>数据用Intent封装，传递形式用广播</p>
<h2 id="AIDL-完成进程间通信"><a href="#AIDL-完成进程间通信" class="headerlink" title="AIDL 完成进程间通信"></a>AIDL 完成进程间通信</h2><p>关于进程和线程的细节改天详细说明，我们首先了解一下进程和线程的概念：</p>
<blockquote>
<p>当某个应用组件启动且该应用没有运行其他任何组件时，<a href="http://ocnyang.com/">Android</a> 系统会使用单个执行线程为应用启动新的 Linux<br>进程。默认情况下，同一应用的所有组件在相同的进程和线程（称为“主”线程）中运行。<br>如果某个应用组件启动且该应用已存在进程（因为存在该应用的其他组件），则该组件会在此进程内启动并使用相同的执行线程。<br>但是，我们也可以安排应用中的其他组件在单独的进程中运行，并为任何进程创建额外的线程。  </p>
</blockquote>
<blockquote>
<p>各类组件元素的清单文件条目—：activity，servicer，eceiver 和 provider 均支持 android:process 属性，此属性可以指定该组件应在哪个进程运行。我们可以设置此属性，使每个组件均在各自的进程中运行，或者使一些组件共享一个进程，而其他组件则不共享。 此外，我们还可以设置 android:process，使不同应用的组件在相同的进程中运行  </p>
</blockquote>
<p>以及了解一下 进程间通信的概念</p>
<blockquote>
<p>Android 利用远程过程调用 (RPC) 提供了一种进程间通信 (IPC) 机制，通过这种机制，由 Activity<br>或其他应用组件调用的方法将（在其他进程中）远程执行，而所有结果将返回给调用方。这就要求把方法调用及其数据分解至操作系统可以识别的程度，并将其从本地进程和地址空间传输至远程进程和地址空间，然后在远程进程中重新组装并执行该调用。<br>然后，返回值将沿相反方向传输回来。 Android 提供了执行这些 IPC 事务所需的全部代码，因此我们只需集中精力定义和实现 RPC<br>编程接口即可。  </p>
</blockquote>
<blockquote>
<p>要执行 IPC，必须使用 bindService() 将应用绑定到服务上。</p>
</blockquote>
<p>具体实现 可以 <a href="http://blog.csdn.net/u013478336/article/details/43818185">参考这个实例</a> 和文末给出的官方文档</p>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>Handler 和AsyncTask都是用来完成子线程和主线程即UI线程通信的</p>
<p>都可以解决主线程 处理耗时操作，造成界面卡顿或者程序无响应ANR异常 这一类问题</p>
<p>Handler 是 一种机制【Handler+Message+Looper】，所有的数据通过Message携带，，所有的执行顺序按照队列的形式执行，Looper用来轮询判断消息队列，Handler用来接收和发送Message</p>
<p>AsyncTask 是一个单独的类，设计之初的目的只是为了 异步方式完成耗时操作的，顺便可以通知主线程刷新Ui，AsyncTask的内部机制则是维护了一个线程池，提升性能。</p>
<p>在这里提供另一种优雅的做法完成线程间的通信：</p>
<p>扩展 IntentService 类</p>
<p>由于大多数启动服务都不必同时处理多个请求（实际上，这种多线程情况可能很危险），因此使用 IntentService 类实现服务值得一试。<br>但如需同时处理多个启动请求，则更适合使用该基类Service。</p>
<p>IntentService 执行以下操作：</p>
<ul>
<li>创建默认的工作线程，用于在应用的主线程外执行传递给 onStartCommand() 的所有 Intent。</li>
<li>创建工作队列，用于将一个 Intent 逐一传递给 onHandleIntent() 实现，这样我们就永远不必担心多线程问题。</li>
<li>在处理完所有启动请求后停止服务，因此我们不必调用 stopSelf()。</li>
<li>提供 onBind() 的默认实现（返回 null）。</li>
<li>提供 onStartCommand() 的默认实现，可将 Intent 依次发送到工作队列和 onHandleIntent() 实现。<br>综上所述，您只需实现 onHandleIntent() 来完成客户端提供的工作即可。（不过，我们还需要为服务提供小型构造函数。）  </li>
</ul>
<p>以下是 IntentService 的实现示例：</p>
<pre><code>public class HelloIntentService extends IntentService &#123;

  /**
   * 必须有构造函数 必须调用父 IntentService(String)带有name的构造函数来执行工作线程
   */
  public HelloIntentService() &#123;
      super(&quot;HelloIntentService&quot;);
  &#125;

  /**
   * IntentService 调用默认的工作线程启动服务
   * 当此方法结束，, IntentService 服务结束
   */
  @Override
  protected void onHandleIntent(Intent intent) &#123;
      // 通常在这里会执行一些操作，比如下载文件
      //在这里只是sleep 5 s
      long endTime = System.currentTimeMillis() + 5*1000;
      while (System.currentTimeMillis() &amp;lt; endTime) &#123;
          synchronized (this) &#123;
              try &#123;
                  wait(endTime - System.currentTimeMillis());
              &#125; catch (Exception e) &#123;
              &#125;
          &#125;
      &#125;
  &#125;
&#125;
</code></pre>
<p>看吧，我们只需要一个构造函数和一个 onHandleIntent() 实现即可。</p>
<p>对于Service 当然也有基础一点的做法，来完成多线程的操作，只不过代码量更多了：</p>
<pre><code>public class HelloService extends Service &#123;
  private Looper mServiceLooper;
  private ServiceHandler mServiceHandler;

  // Handler 接收来自主线程的Message
  private final class ServiceHandler extends Handler &#123;
      public ServiceHandler(Looper looper) &#123;
          super(looper);
      &#125;
      @Override
      public void handleMessage(Message msg) &#123;
         //执行任务，比如下载什么的，这里只是 让线程sleep
          long endTime = System.currentTimeMillis() + 5*1000;
          while (System.currentTimeMillis() &amp;lt; endTime) &#123;
              synchronized (this) &#123;
                  try &#123;
                      wait(endTime - System.currentTimeMillis());
                  &#125; catch (Exception e) &#123;
                  &#125;
              &#125;
          &#125;
          // 手动停止服务，来处理下一个线程
          stopSelf(msg.arg1);
      &#125;
  &#125;

  @Override
  public void onCreate() &#123;
    //启动线程.  注意我们在主线程中创建了一些子线程, 这些线程都没有加锁同步. 这些现场都是后台线程，所以不会阻塞UI线程
    HandlerThread thread = new HandlerThread(&quot;ServiceStartArguments&quot;,
            Process.THREAD_PRIORITY_BACKGROUND);
    thread.start();

    // Handler开始轮询遍历了
    mServiceLooper = thread.getLooper();
    mServiceHandler = new ServiceHandler(mServiceLooper);
  &#125;

  @Override
  public int onStartCommand(Intent intent, int flags, int startId) &#123;
      Toast.makeText(this, &quot;service starting&quot;, Toast.LENGTH_SHORT).show();

      // 每一次请求，都会通过handler发送Message
      // startID只是为了让我们知道正在进行的是哪一个线程，以便于我们停止服务
      Message msg = mServiceHandler.obtainMessage();
      msg.arg1 = startId;
      mServiceHandler.sendMessage(msg);

      // If we get killed, after returning from here, restart
      return START_STICKY;
  &#125;

  @Override
  public IBinder onBind(Intent intent) &#123;
      // 不提供 binding, 所以返回空
      return null;
  &#125;

  @Override
  public void onDestroy() &#123;
    Toast.makeText(this, &quot;service done&quot;, Toast.LENGTH_SHORT).show();
  &#125;
&#125;
</code></pre>
<h2 id="多个App间的通信"><a href="#多个App间的通信" class="headerlink" title="多个App间的通信"></a>多个App间的通信</h2><p>首先我们要知道以下两点：</p>
<ol>
<li>Android 应用一般具有若干个Activity。每个Activity显示一个用户界面，用户可通过该界面执行特定任务（比如，查看地图或拍照）。要将用户从一个Activity转至另一Activity，应用必须使用 Intent 定义做某事的“意向”。 当我们使用诸如 startActivity() 的方法将 Intent 传递至系统时，系统会使用 Intent 识别和启动相应的应用组件。使用意向甚至可以让我们的应用开始另一个应用中包含的Activity。</li>
<li>Intent 可以为 显式 以便启动特定组件（特定的 Activity 实例）或隐式 以便启动处理意向操作（比如“拍摄照片”）的任何组件。  </li>
</ol>
<h3 id="1-向另一个应用发送用户"><a href="#1-向另一个应用发送用户" class="headerlink" title="1. 向另一个应用发送用户"></a>1. 向另一个应用发送用户</h3><p>Android最重要的功能之一，是可以操作其他应用，比如在我们的应用中，需要使用地图显示公司地址，我们无序在地图应用程序中构建Activity，而是直接创建Intent查看 地址的请求，Android系统之后启动 可以在地图上显示 地址的应用。</p>
<p><strong>1) 构建隐式的意图</strong></p>
<p>隐式意图不用声明要启动的组件类名称，而是声明操作，比如查看，编辑，发送，或者获取某项。</p>
<p>如果您我们的数据是Uri，可以这样构建Intent：</p>
<pre><code>//当我们的应用通过startActivity()调用此Intent时，电话应用会发起向指定电话号码呼叫
Uri number = Uri.parse(&quot;tel:5551234&quot;);
Intent callIntent = new Intent(Intent.ACTION_DIAL, number);  
</code></pre>
<p>这里还有一些其他Intent的操作和Uri数据对:</p>
<p><strong>·</strong> <code>查看地图：</code></p>
<pre><code>// 基于地址的地图位置
Uri location = Uri.parse(&quot;geo:0,0?q=1600+Amphitheatre+Parkway,+Mountain+View,+California&quot;);
// 基于经纬度的地图位置
// Uri location = Uri.parse(&quot;geo:37.422219,-122.08364?z=14&quot;); // z param is zoom level
Intent mapIntent = new Intent(Intent.ACTION_VIEW, location);
</code></pre>
<p><strong>·</strong> <code>查看网页：</code></p>
<pre><code>Uri webpage = Uri.parse(&quot;http://www.ocnyang.com&quot;);
Intent webIntent = new Intent(Intent.ACTION_VIEW, webpage);
</code></pre>
<p>有的同学会问了，我从哪里可以知道，Intent可以传递的 Uri的类型，或者其他数据类型呢？</p>
<p>答：可以查阅 <a href="https://developer.android.com/reference/android/content/Intent.html#ACTION_VIEW">Google Intent 的 API</a></p>
<p><strong>2) 确认是否存在 接收意向的应用</strong></p>
<blockquote>
<p>注意：如果调用了意向，但设备上没有可用于处理意向的应用，我们的应用将崩溃。</p>
</blockquote>
<p>要确认是否存在可响应意向的可用Activity，请调用 queryIntentActivities() 来获取能够处理ntent 的Activity列表。 如果返回的 List 不为空，则可以安全地使用该意向。例如：</p>
<pre><code>PackageManager packageManager = getPackageManager();
List activities = packageManager.queryIntentActivities(intent,
        PackageManager.MATCH_DEFAULT_ONLY);
boolean isIntentSafe = activities.size() &gt; 0;
</code></pre>
<p>如果 isIntentSafe 是 true，则至少有一个应用将响应该意向。 如果它是 false，则没有任何应用处理该意向。</p>
<p><strong>3) 启动指定Activity</strong></p>
<p>当我指定意图后，通过startActivity(intent);就可以启动指定Activity</p>
<p>此处有一个Google官方的示例：</p>
<pre><code>// 构建Intent
Uri location = Uri.parse(&quot;geo:0,0?q=1600+Amphitheatre+Parkway,+Mountain+View,+California&quot;);
Intent mapIntent = new Intent(Intent.ACTION_VIEW, location);

// 确定意图可以被接收
PackageManager packageManager = getPackageManager();
List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(mapIntent, 0);
boolean isIntentSafe = activities.size() &gt; 0;

//启动指定应用
if (isIntentSafe) &#123;
    startActivity(mapIntent);
&#125;
</code></pre>
<p><strong>4) 显示应用选择器</strong></p>
<p>比如我们要完成 <strong>分享操作</strong>，用户可以使用多个App完成分享，我们应明确显示选择器对话框，如图</p>
<p><img src="http://img.shedoor.net/ocnyang/android_comm/intent-chooser.png" alt="intent-chooser">  </p>
<p>要显示选择器，需要使用Intent的createChooser()方法 创建Intent，并将其传递至 startActivity()</p>
<pre><code>Intent intent = new Intent(Intent.ACTION_SEND);
...

String title = getResources().getString(R.string.chooser_title);
// Create intent to show chooser
Intent chooser = Intent.createChooser(intent, title);

// Verify the intent will resolve to at least one activity
if (intent.resolveActivity(getPackageManager()) != null) &#123;
    startActivity(chooser);
&#125;
</code></pre>
<p>这将显示一个对话框，其中有响应传递给 createChooser() 方法的意向的应用列表，并且将提供的文本用作 对话框标题</p>
<h3 id="2-接收其他Activity返回的结果"><a href="#2-接收其他Activity返回的结果" class="headerlink" title="2. 接收其他Activity返回的结果"></a>2. 接收其他Activity返回的结果</h3><p>通过Intent.startActivityForResult()来完成。</p>
<p>首先在启动另一个Activity时，我们需要指定request code以便返回结果时，我们可以正常处理它。</p>
<pre><code>static final int PICK_CONTACT_REQUEST = 1;  // The request code
...
private void pickContact() &#123;
    Intent pickContactIntent = new Intent(Intent.ACTION_PICK, Uri.parse(&quot;content://contacts&quot;));
    pickContactIntent.setType(Phone.CONTENT_TYPE);
    startActivityForResult(pickContactIntent, PICK_CONTACT_REQUEST);
&#125;
</code></pre>
<p>当用户完成操作后，返回数据，系统会调用Activity的 onActivityResult()方法，</p>
<pre><code>@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;
    // 检查requestCode是否真确
    if (requestCode == PICK_CONTACT_REQUEST) &#123;
        // 确保请求时成功的
        if (resultCode == RESULT_OK) &#123;
           // 完成我们的业务逻辑
        &#125;
    &#125;
&#125;
</code></pre>
<p>为了成功处理结果，我们必须了解Intent的格式，比如联系人返回的是带内容的URI，照相机返回的是Bitmap<br>如何根据返回的URI来读取数据，我们需要对ContentResolver 和 ContentProvider 有了解</p>
<p>下面就是一个三者结合的获取联系人的实例：</p>
<pre><code>@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;
    // 检查requestCode
    if (requestCode == PICK_CONTACT_REQUEST) &#123;
        // 确保请求成功
        if (resultCode == RESULT_OK) &#123;
            //获得选择的联系人的URI
            Uri contactUri = data.getData();
            // 我们只需要NUMBER这一列的信息，
            String[] projection = &#123;Phone.NUMBER&#125;;

            // 显示根据NUMBER查询的结果
            // We don&#39;t need a selection or sort order (there&#39;s only one result for the given URI)
            // 在这里我们并没有对查询的结果进行排序，因为在主线程中进行这种数据库操作，有可能阻塞线程
            //优化方案是异步完成排序的操作，这里只是展示多个App间的通信
            Cursor cursor = getContentResolver()
                    .query(contactUri, projection, null, null, null);
            cursor.moveToFirst();

            //从NUMBER那一列当中取回phone NUMBER
            int column = cursor.getColumnIndex(Phone.NUMBER);
            String number = cursor.getString(column);
            //接下来就是要操作这些phone number了
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="3-接收其他Activity返回的结果"><a href="#3-接收其他Activity返回的结果" class="headerlink" title="3. 接收其他Activity返回的结果"></a>3. 接收其他Activity返回的结果</h3><p>要允许其他应用开始您的Activity，需要 在相应元素的宣示说明文件中添加一个 元素。</p>
<p>例如，此处有一个在数据类型为文本或图像时处理 ACTION_SEND 意向的意向过滤器：</p>
<pre><code>&lt;activity android:name=&quot;ShareActivity&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.SEND&quot;/&gt;
        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;
        &lt;data android:mimeType=&quot;text/plain&quot;/&gt;
        &lt;data android:mimeType=&quot;image/*&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>
<p>定义操作，通常是系统定义的值之一，比如ACTION_SEND 或 ACTION_VIEW。</p>
<p>定义与Intent关联的数据，只需通过 android:mimeType 指定我们接收的数据类型，比如text/plain 或 image/jpeg。</p>
<p>所有的隐式Intent，都使用 CATEGORY_DEFAULT 进行定义</p>
<h3 id="4-处理Activity中的Intent"><a href="#4-处理Activity中的Intent" class="headerlink" title="4. 处理Activity中的Intent"></a>4. 处理Activity中的Intent</h3><p>当Activity开始时，调用getIntent检索开始Activity的Intent，</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) &#123;
    super.onCreate(savedInstanceState);

    setContentView(R.layout.main);

    Intent intent = getIntent();
    Uri data = intent.getData();

    // 指出接收的数据类型
    if (intent.getType().indexOf(&quot;image/&quot;) != -1) &#123;
        // 处理带有图片的Intent
    &#125; else if (intent.getType().equals(&quot;text/plain&quot;)) &#123;
        // 处理带有文本的Intent
    &#125;
&#125;
</code></pre>
<h3 id="5-向指定Activity中返回数据"><a href="#5-向指定Activity中返回数据" class="headerlink" title="5. 向指定Activity中返回数据"></a>5. 向指定Activity中返回数据</h3><p>只需调用setResult指定结果代码和Intent</p>
<pre><code>Intent result = new Intent(&quot;com.example.RESULT_ACTION&quot;, Uri.parse(&quot;content://result_uri&quot;);
setResult(Activity.RESULT_OK, result);
finish();
</code></pre>
<p>记住必须为结果指定结果码，通常为 RESULT_OK 或 RESULT_CANCELED。</p>
<p>我们也可以在Intent中 用Bundle存储额外的信息</p>
<p>细心的同学可能发现一个问题：</p>
<p>启动 Activity 有 startActivity() 和 startActivityForResult() 两种启动方式，返回结果的形式id偶有 setResult() 吗？</p>
<p>如果开启当前Activity的Intent可能需要结果，只需调用 setResult()。 如果原始 Activity 已调用 startActivityForResult()，则系统将向其传递您提供给 setResult() 的结果；否则，会忽略结果。</p>
<h2 id="使用大型开源框架完成组件间的通信"><a href="#使用大型开源框架完成组件间的通信" class="headerlink" title="使用大型开源框架完成组件间的通信"></a>使用大型开源框架完成组件间的通信</h2><p>Github上非常火的两大通信组件EventBus和otto：</p>
<h3 id="1-EventBus"><a href="#1-EventBus" class="headerlink" title="1. EventBus"></a>1. EventBus</h3><p>EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。</p>
<p>传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。</p>
<p><strong>1）概念：</strong></p>
<p>事件(Event)：又可称为消息，本文中统一用事件表示。其实就是一个对象，可以是网络请求返回的字符串，也可以是某个开关状态等等。事件类型(EventType)指事件所属的 Class。</p>
<p>事件分为一般事件和 Sticky 事件，相对于一般事件，Sticky 事件不同之处在于，当事件发布后，再有订阅者开始订阅该类型事件，依然能收到该类型事件最近一个 Sticky 事件。</p>
<p>订阅者(Subscriber)：订阅某种事件类型的对象。当有发布者发布这类事件后，EventBus 会执行订阅者的 onEvent 函数，这个函数叫事件响应函数。订阅者通过 register 接口订阅某个事件类型，unregister 接口退订。订阅者存在优先级，优先级高的订阅者可以取消事件继续向优先级低的订阅者分发，默认所有订阅者优先级都为 0。</p>
<p>发布者(Publisher)：发布某事件的对象，通过 post 接口发布事件。</p>
<p>本项目较为简单，总体设计和流程图：</p>
<p><img src="http://img.shedoor.net/ocnyang/android_comm/EventBus-Publish-Subscribe.png" alt="EventBus-Publish-Subscribe">  </p>
<p>使用方式：</p>
<p>build.gradle 中加入依赖</p>
<pre><code>compile &#39;org.greenrobot:eventbus:3.0.0&#39;
</code></pre>
<p>代码中指需三步</p>
<blockquote>
<p><strong>1.</strong> 定义事件：只需要是一个Java类</p>
</blockquote>
<pre><code>public class MessageEvent &#123;
    public final String message;
    public MessageEvent(String message) &#123;
        this.message = message;
    &#125;
&#125;
</code></pre>
<blockquote>
<p><strong>2.</strong> 完成订阅者</p>
</blockquote>
<pre><code>//MessageEvent被Eventbus post提交的时候 将会回调这个方法
//这种方式 提示我们可以直接定义自己的事件
@Subscribe
public void onMessageEvent(MessageEvent event)&#123;
    Toast.makeText(getActivity(), event.message, Toast.LENGTH_SHORT).show();
&#125;

// 当一些其他事件post提交的时候，回调这个方法
@Subscribe
public void handleSomethingElse(SomeOtherEvent event)&#123;
    doSomethingWith(event);
</code></pre>
<blockquote>
<p>在Activity或者Fragment中绑定订阅者</p>
</blockquote>
<pre><code>@Override
public void onStart() &#123;
    super.onStart();
    EventBus.getDefault().register(this);
&#125;

@Override
public void onStop() &#123;
   EventBus.getDefault().unregister(this);
    super.onStop();
&#125;
</code></pre>
<blockquote>
<p><strong>3.</strong> 发布事件：</p>
</blockquote>
<pre><code>EventBus.getDefault().post(new MessageEvent(&quot;Hello everyone!&quot;));
</code></pre>
<h2 id="本文参考并翻译"><a href="#本文参考并翻译" class="headerlink" title="本文参考并翻译"></a>本文参考并翻译</h2><blockquote>
<p><a href="http://www.androidchina.net/5028.html#rd">文章来源</a></p>
</blockquote>
<ul>
<li><a href="https://developer.android.com/training/basics/fragments/communicating.html">Google 课程 Communicating with Other Fragments</a></li>
<li><a href="https://developer.android.com/guide/components/aidl.html">Google 解释 AIDL进程间通信</a></li>
<li><a href="https://developer.android.com/training/multiple-threads/communicate-ui.html">Google 解释 Handler</a></li>
<li><a href="https://developer.android.com/reference/android/os/AsyncTask.html">Google 解释 AsyncTask</a></li>
<li><a href="https://developer.android.com/reference/android/content/BroadcastReceiver.html">Google BroadcastReceiver API</a></li>
<li><a href="https://developer.android.com/training/basics/intents/index.html?hl=vi">Google 课程 Interacting with Other Apps</a></li>
<li><a href="https://developer.android.com/guide/topics/providers/content-provider-creating.html">Google 解释 contentprovider</a></li>
<li><a href="https://developer.android.com/reference/android/content/BroadcastReceiver.html">Google BroadcastReceiver 课程</a></li>
<li><a href="https://developer.android.com/guide/components/services.html">Google Service 课程</a></li>
<li><a href="https://developer.android.com/guide/components/processes-and-threads.html#">Google 解释 进程和线程</a></li>
<li><a href="http://greenrobot.org/eventbus/documentation/">EventBus官方文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Android教程系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Glide图片加载库的使用</title>
    <url>/2016/08/17/GlideUse/</url>
    <content><![CDATA[<p>Glide是 Google推荐的图片加载库,它可以支持来自url,Android资源,文件,Uri中的图片加载,同时还支持gif图片的加载,以及各种图片显示前的bitmap处理(例如:圆角图片,圆形图片,高斯模糊,旋转,灰度等等),缓存处理,请求优先级处理,动画处理,缩略图处理,图片大小自定义等等.可谓是非常的强大.</p>
<span id="more"></span>

<h2 id="1-添加Glide库"><a href="#1-添加Glide库" class="headerlink" title="1.添加Glide库"></a>1.添加Glide库</h2><p>需要在build.gradle中加入依赖,目前最新的版本是3.7.0,<a href="https://github.com/bumptech/glide">Glide库地址</a>  </p>
<pre><code class="java"> compile &#39;com.github.bumptech.glide:glide:3.7.0&#39;
</code></pre>
<h2 id="2-加载网络图片"><a href="#2-加载网络图片" class="headerlink" title="2.加载网络图片"></a>2.加载网络图片</h2><pre><code>/**
 * Created by mChenys on 2016/6/6.
 */
public class TestGlideActivity extends Activity &#123;
    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_test);
        String url = &quot;http://www.qq745.com/uploads/allimg/141106/1-141106153Q5.png&quot;;
        ImageView targetView = (ImageView) findViewById(R.id.iv_target);
        Glide.with(this).
                load(url).
                asBitmap(). //强制处理为bitmap
                into(targetView);//显示到目标View中
    &#125;
&#125;
</code></pre>
<h2 id="3-加载资源图片"><a href="#3-加载资源图片" class="headerlink" title="3.加载资源图片"></a>3.加载资源图片</h2><pre><code>public class TestGlideActivity extends Activity &#123;
    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_test);
        int resourceId = R.drawable.test;
        ImageView targetView = (ImageView) findViewById(R.id.iv_target);
        Glide.with(this).
                load(resourceId).
                asBitmap().
                into(targetView);
    &#125;
&#125;
</code></pre>
<h2 id="4-加载本地文件图片"><a href="#4-加载本地文件图片" class="headerlink" title="4.加载本地文件图片"></a>4.加载本地文件图片</h2><pre><code>public class TestGlideActivity extends Activity &#123;
    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_test);
        File file = new File(Environment.getExternalStorageDirectory(), &quot;test.jpg&quot;);
        ImageView targetView = (ImageView) findViewById(R.id.iv_target);
        Glide.with(this).
                load(file).
                asBitmap().
                into(targetView);
    &#125;
&#125;
</code></pre>
<h2 id="5-从Uri中加载"><a href="#5-从Uri中加载" class="headerlink" title="5.从Uri中加载"></a>5.从Uri中加载</h2><pre><code>/**
 * Created by mChenys on 2016/6/6.
 */
public class TestGlideActivity extends Activity &#123;
    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_test);
        Uri uri = Uri.parse(&quot;android.resource://&quot; + this.getPackageName() + &quot;/&quot; + R.drawable.test);
        ImageView targetView = (ImageView) findViewById(R.id.iv_target);
        Glide.with(this).
                load(uri).
                asBitmap().
                into(targetView);
    &#125;
&#125;
</code></pre>
<h2 id="6-加载gif图片"><a href="#6-加载gif图片" class="headerlink" title="6.加载gif图片"></a>6.加载gif图片</h2><pre><code>public class TestGlideActivity extends Activity &#123;
    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_test);
        ImageView targetView = (ImageView) findViewById(R.id.iv_target);
        Glide.with(this).
                load(R.drawable.smail).
                asGif().//注意:这里显示的指明了要加载的是gif图片,当然即使不指明,glide也会自己判断.
                into(targetView);
    &#125;
&#125;
</code></pre>
<p>效果图:<br><img src="http://img.blog.csdn.net/20160606225115608">  </p>
<h2 id="7-设置默认图片和加载失败时显示的图片"><a href="#7-设置默认图片和加载失败时显示的图片" class="headerlink" title="7.设置默认图片和加载失败时显示的图片"></a>7.设置默认图片和加载失败时显示的图片</h2><pre><code>public class TestGlideActivity extends Activity &#123;
    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_test);
        ImageView targetView = (ImageView) findViewById(R.id.iv_target);
        Glide.with(this).
                load(R.drawable.test).
                asBitmap().
                placeholder(R.drawable.bg_loading).//加载中显示的图片
                error(R.drawable.bg_error).//加载失败时显示的图片
                into(targetView);
    &#125;
&#125;
</code></pre>
<h2 id="8-淡入显示效果"><a href="#8-淡入显示效果" class="headerlink" title="8.淡入显示效果"></a>8.淡入显示效果</h2><pre><code>public class TestGlideActivity extends Activity &#123;
    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_test);
        ImageView targetView = (ImageView) findViewById(R.id.iv_target);
        Glide.with(this).
                load(R.drawable.test).
                placeholder(R.drawable.bg_loading).//加载中显示的图片
                error(R.drawable.bg_error).//加载失败时显示的图片
                crossFade().//淡入显示,注意:如果设置了这个,则必须要去掉asBitmap
                into(targetView);
    &#125;
&#125;
</code></pre>
<p>另外,crossFade还可以接收一个参数来设置淡入显示效果的持续时间,crossFade(int duration);<br>如果你想直接显示图片,而不是淡入显示图片,则可以通过dontAnimate()方法设置.</p>
<h2 id="9-调整图片像素大小"><a href="#9-调整图片像素大小" class="headerlink" title="9.调整图片像素大小"></a>9.调整图片像素大小</h2><pre><code>public class TestGlideActivity extends Activity &#123;
    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_test);
        ImageView targetView = (ImageView) findViewById(R.id.iv_target);
        Glide.with(this).
                load(R.drawable.test).
                placeholder(R.drawable.bg_loading).//加载中显示的图片
                error(R.drawable.bg_error).//加载失败时显示的图片
                crossFade(1000).//淡入显示的时间,注意:如果设置了这个,则必须要去掉asBitmap
                override(80,80).//设置最终显示的图片像素为80*80,注意:这个是像素,而不是控件的宽高
                into(targetView);
    &#125;
&#125;
</code></pre>
<h2 id="10-设置CenterCrop-FitCenter"><a href="#10-设置CenterCrop-FitCenter" class="headerlink" title="10.设置CenterCrop,FitCenter"></a>10.设置CenterCrop,FitCenter</h2><p>CenterCrop,FitCenter都是对目标图片进行裁剪,了解过ImageView的ScaleType属性就知道,这2种裁剪方式在ImageView上也是有的,分别对应ImageView的ImageView.ScaleType.CENTER_CROP和mageView.ScaleType.FIT_CENTER的.</p>
<pre><code>public class TestGlideActivity extends Activity &#123;
    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_test);
        ImageView targetView = (ImageView) findViewById(R.id.iv_target);
        targetView.setScaleType(ImageView.ScaleType.FIT_CENTER);
        Glide.with(this).
                load(R.drawable.test).
                placeholder(R.drawable.bg_loading).//加载中显示的图片
                error(R.drawable.bg_error).//加载失败时显示的图片
                crossFade(1000).//淡入淡出,注意:如果设置了这个,则必须要去掉asBitmap
                override(80,80).//设置最终显示的图片像素为80*80,注意:这个是像素,而不是控件的宽高
                centerCrop().//中心裁剪,缩放填充至整个ImageView
                into(targetView);
    &#125;
&#125;
</code></pre>
<h2 id="11-缓存策略设置"><a href="#11-缓存策略设置" class="headerlink" title="11.缓存策略设置"></a>11.缓存策略设置</h2><p>内存缓存设置,通过skipMemoryCache(boolean)来设置是否需要缓存到内存,默认是会缓存到内存的.</p>
<pre><code>/**
 * Created by mChenys on 2016/6/6.
 */
public class TestGlideActivity extends Activity &#123;
    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_test);
        ImageView targetView = (ImageView) findViewById(R.id.iv_target);
        targetView.setScaleType(ImageView.ScaleType.FIT_CENTER);
        Glide.with(this).
                load(R.drawable.test).
                placeholder(R.drawable.bg_loading).//加载中显示的图片
                error(R.drawable.bg_error).//加载失败时显示的图片
                crossFade(1000).//淡入淡出,注意:如果设置了这个,则必须要去掉asBitmap
                override(80,80).//设置最终显示的图片像素为80*80,注意:这个是像素,而不是控件的宽高
                centerCrop().//中心裁剪,缩放填充至整个ImageView
                skipMemoryCache(true).//跳过内存缓存
                into(targetView);
    &#125;
&#125;
</code></pre>
<p>磁盘缓存,磁盘缓存通过diskCacheStrategy(DiskCacheStrategy)来设置,DiskCacheStrategy一共有4种模式:  </p>
<ul>
<li>DiskCacheStrategy.NONE:什么都不缓存</li>
<li>DiskCacheStrategy.SOURCE:仅缓存原图(全分辨率的图片)</li>
<li>DiskCacheStrategy.RESULT:仅缓存最终的图片,即修改了尺寸或者转换后的图片</li>
<li>DiskCacheStrategy.ALL:缓存所有版本的图片,默认模式  <blockquote>
</blockquote>
</li>
</ul>
<pre><code>public class TestGlideActivity extends Activity &#123;
    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_test);
        ImageView targetView = (ImageView) findViewById(R.id.iv_target);
        targetView.setScaleType(ImageView.ScaleType.FIT_CENTER);
        Glide.with(this).
                load(R.drawable.test).
                placeholder(R.drawable.bg_loading).//加载中显示的图片
                error(R.drawable.bg_error).//加载失败时显示的图片
                crossFade(1000).//淡入淡出,注意:如果设置了这个,则必须要去掉asBitmap
                override(80, 80).//设置最终显示的图片像素为80*80,注意:这个是像素,而不是控件的宽高
                centerCrop().//中心裁剪,缩放填充至整个ImageView
                skipMemoryCache(true).//跳过内存缓存
                diskCacheStrategy(DiskCacheStrategy.RESULT).//保存最终图片
                into(targetView);
    &#125;
&#125;
</code></pre>
<h2 id="12-缓存设置"><a href="#12-缓存设置" class="headerlink" title="12.缓存设置"></a>12.缓存设置</h2><p>在GlideModule 中,我们可以设置磁盘缓存的位置,磁盘缓存的大小和内存缓存的大小,同时还可以设置图片的显示质量.  </p>
<p>要是用GlideModule ,需要创建它的实现类,然后在manifests中申明实现类的全类路径:</p>
<pre><code>&lt;meta-data
          android:name=&quot;com.example.mchenys.httputilsdemo.image.glide.module.SimpleGlideModule&quot;
          android:value=&quot;GlideModule&quot; /&gt;
</code></pre>
<p>GlideModule 的实现类,需要实现applyOptions方法:</p>
<pre><code>/**
 * 所以你知道要创建一个额外的类去定制 Glide。
 * 下一步是要全局的去声明这个类，让 Glide 知道它应该在哪里被加载和使用。
 * Glide 会扫描 AndroidManifest.xml 为 Glide module 的 meta 声明。
 * 因此，你必须在 AndroidManifest.xml 的 &lt;application&gt; 标签内去声明这个SimpleGlideModule。
 * Created by mChenys on 2016/6/10.
 */
public class SimpleGlideModule implements GlideModule &#123;
    public static DiskCache cache;

    @Override
    public void applyOptions(Context context, GlideBuilder builder) &#123;
        // 在 Android 中有两个主要的方法对图片进行解码：ARGB8888 和 RGB565。前者为每个像素使用了 4 个字节，
        // 后者仅为每个像素使用了 2 个字节。ARGB8888 的优势是图像质量更高以及能存储一个 alpha 通道。
        // Picasso 使用 ARGB8888，Glide 默认使用低质量的 RGB565。
        // 对于 Glide 使用者来说：你使用 Glide module 方法去改变解码规则。
        builder.setDecodeFormat(DecodeFormat.PREFER_ARGB_8888);
        //设置缓存目录
        File cacheDir = PathUtils.getDiskCacheDir(context, CacheConfig.IMG_DIR);

        cache = DiskLruCacheWrapper.get(cacheDir, DiskCache.Factory.DEFAULT_DISK_CACHE_SIZE);// 250 MB
        builder.setDiskCache(new DiskCache.Factory() &#123;
            @Override
            public DiskCache build() &#123;
                return cache;
            &#125;
        &#125;);
        //设置memory和Bitmap池的大小
        MemorySizeCalculator calculator = new MemorySizeCalculator(context);
        int defaultMemoryCacheSize = calculator.getMemoryCacheSize();
        int defaultBitmapPoolSize = calculator.getBitmapPoolSize();

        int customMemoryCacheSize = (int) (1.2 * defaultMemoryCacheSize);
        int customBitmapPoolSize = (int) (1.2 * defaultBitmapPoolSize);

        builder.setMemoryCache(new LruResourceCache(customMemoryCacheSize));
        builder.setBitmapPool(new LruBitmapPool(customBitmapPoolSize));
    &#125;

    @Override
    public void registerComponents(Context context, Glide glide) &#123;
    &#125;
&#125;
</code></pre>
<h2 id="13-设置图片请求的优先级"><a href="#13-设置图片请求的优先级" class="headerlink" title="13.设置图片请求的优先级"></a>13.设置图片请求的优先级</h2><p>Glide 可以用 Priority 枚举来设置图片的加载优先级,这样我们就可以针对那些需要显示的图片设置高的优先级了.</p>
<p>Priority 有4种级别:</p>
<ul>
<li>Priority.LOW  </li>
<li>Priority.NORMAL  </li>
<li>Priority.HIGH  </li>
<li>Priority.IMMEDIATE  </li>
</ul>
<p>例如:</p>
<pre><code>/**
    * 高优先级加载
    * @param url
    * @param imageView
    * @param listener
    */
   public static void loadImageWithHighPriority(Object url,ImageView imageView, final LoaderListener listener) &#123;
       if (url == null) &#123;
           if (listener != null) &#123;
               listener.onError();
           &#125;
       &#125; else &#123;
           Glide.with(imageView.getContext()).
                   load(url).
                   asBitmap().
                   priority(Priority.HIGH).//高优先级
                   dontAnimate().
                   listener(new RequestListener&lt;Object, Bitmap&gt;() &#123;
                       @Override
                       public boolean onException(Exception e, Object model, Target&lt;Bitmap&gt; target, boolean isFirstResource) &#123;
                           if (null != listener) &#123;
                               listener.onError();
                           &#125;
                           return false;
                       &#125;

                       @Override
                       public boolean onResourceReady(Bitmap resource, Object model, Target&lt;Bitmap&gt; target, boolean isFromMemoryCache, boolean isFirstResource) &#123;
                           if (null != listener) &#123;
                               listener.onSuccess();
                           &#125;
                           return false;
                       &#125;
                   &#125;).into(imageView);
       &#125;
   &#125;
</code></pre>
<h2 id="14-设置加载缩略图"><a href="#14-设置加载缩略图" class="headerlink" title="14.设置加载缩略图"></a>14.设置加载缩略图</h2><p>通过设置缩略图,我们可以在显示目标图片之前先展示一个第分辨率或者其他图片,当全分辨率的目标图片在后台加载完成后,<br>Glide会自动切换显示全像素的目标图片.  </p>
<p>设置缩略图有2种方式:<br>通过thumbnail(float)指定0.0f~1.0f的原始图像大小,例如全像素的大小是500<em>500,如果设置为thumbnail为0.1f,即目标图片的10%,显示的缩略图大小就是50</em>50;</p>
<pre><code>public class TestGlideActivity extends Activity &#123;
    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_test);
        ImageView targetView = (ImageView) findViewById(R.id.iv_target);

        Glide.with(this).
                load(R.drawable.test).
                placeholder(R.drawable.bg_loading).//加载中显示的图片
                error(R.drawable.bg_error).//加载失败时显示的图片
                crossFade(1000).//淡入淡出,注意:如果设置了这个,则必须要去掉asBitmap
                override(80, 80).//设置最终显示的图片像素为80*80,注意:这个是像素,而不是控件的宽高
                centerCrop().//中心裁剪,缩放填充至整个ImageView
                skipMemoryCache(true).//跳过内存缓存
                diskCacheStrategy(DiskCacheStrategy.RESULT).//保存最终图片
                thumbnail(0.1f).//10%的原图大小
                into(targetView);
    &#125;
&#125;
</code></pre>
<p>通过thumbnail(DrawableRequestBuilder)方式来指定缩略图,该缩略图可以使用load的所有方式(网络,文件,uri,资源)加载.</p>
<pre><code>public class TestGlideActivity extends Activity &#123;
    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_test);
        ImageView targetView = (ImageView) findViewById(R.id.iv_target);
        //缩略图请求
        DrawableRequestBuilder&lt;String&gt; thumbnailRequest = Glide
                .with(this)
                .load(&quot;http://www.qq745.com/uploads/allimg/141106/1-141106153Q5.png&quot;);

        Glide.with(this).
                load(R.drawable.test).
//                placeholder(R.drawable.bg_loading).//加载中显示的图片
//                error(R.drawable.bg_error).//加载失败时显示的图片
//                crossFade(1000).//淡入淡出,注意:如果设置了这个,则必须要去掉asBitmap
                override(80, 80).//设置最终显示的图片像素为80*80,注意:这个是像素,而不是控件的宽高
                centerCrop().//中心裁剪,缩放填充至整个ImageView
                skipMemoryCache(true).//跳过内存缓存
                diskCacheStrategy(DiskCacheStrategy.RESULT).//保存最终图片
                thumbnail(thumbnailRequest).//设置缩略图
                into(targetView);
    &#125;
&#125;
</code></pre>
<h2 id="15-Transformations-Bitmap"><a href="#15-Transformations-Bitmap" class="headerlink" title="15.Transformations Bitmap"></a>15.Transformations Bitmap</h2><p>在显示目标图片之前,我们可以对目标图片的Bitmap进行相应的处理,例如::圆角图片,圆形图片,高斯模糊,旋转,灰度等等.<br>只需要实现Transformation接口即可,该接口的transform方法会返回显示图片前的Bitmap对象,在该方法中对<br>Bitmap的任何处理,都会影响到最终的显示结果.<br>当然,如果你只是想要对图片做常规的 bitmap 转换，你可以继承抽象类BitmapTransformation,它简化了Transformation接口的实现，这应该能覆盖大部分的应用场景了。  </p>
<p>使用的时候,通过transform(Transformation… transformations)来设置.例如:  </p>
<pre><code>public class TestGlideActivity extends Activity &#123;
    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_test);
        ImageView targetView = (ImageView) findViewById(R.id.iv_target);
        Glide.with(this).
                load(R.drawable.test).
                asBitmap().
                transform(new BlurTransformation(this)).//高斯模糊处理
                into(targetView);
    &#125;
&#125;
</code></pre>
<p>下面贴出常用的几个Bitmap的转换处理的代码,在github上也有glide-transformations-master库.  </p>
<h3 id="圆图处理"><a href="#圆图处理" class="headerlink" title="圆图处理"></a>圆图处理</h3><pre><code>public class CropCircleTransformation implements Transformation&lt;Bitmap&gt; &#123;

    private BitmapPool mBitmapPool;

    public CropCircleTransformation(Context context) &#123;
        this(Glide.get(context).getBitmapPool());
    &#125;

    public CropCircleTransformation(BitmapPool pool) &#123;
        this.mBitmapPool = pool;
    &#125;

    @Override
    public Resource&lt;Bitmap&gt; transform(Resource&lt;Bitmap&gt; resource, int outWidth, int outHeight) &#123;
        Bitmap source = resource.get();
        int size = Math.min(source.getWidth(), source.getHeight());

        int width = (source.getWidth() - size) / 2;
        int height = (source.getHeight() - size) / 2;

        Bitmap bitmap = mBitmapPool.get(size, size, Bitmap.Config.ARGB_8888);
        if (bitmap == null) &#123;
            bitmap = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888);
        &#125;

        Canvas canvas = new Canvas(bitmap);
        Paint paint = new Paint();
        BitmapShader shader =
                new BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP);
        if (width != 0 || height != 0) &#123;
            // source isn&#39;t square, move viewport to center
            Matrix matrix = new Matrix();
            matrix.setTranslate(-width, -height);
            shader.setLocalMatrix(matrix);
        &#125;
        paint.setShader(shader);
        paint.setAntiAlias(true);

        float r = size / 2f;
        canvas.drawCircle(r, r, r, paint);

        return BitmapResource.obtain(bitmap, mBitmapPool);
    &#125;

    @Override public String getId() &#123;
        return &quot;CropCircleTransformation()&quot;;
    &#125;
&#125;
</code></pre>
<h3 id="圆角处理"><a href="#圆角处理" class="headerlink" title="圆角处理"></a>圆角处理</h3><pre><code>public class RoundedCornersTransformation implements Transformation&lt;Bitmap&gt; &#123;

    private BitmapPool mBitmapPool;

    private int radius;
    private int margin;

    public RoundedCornersTransformation(Context context, int radius, int margin) &#123;
        this(Glide.get(context).getBitmapPool(), radius, margin);
    &#125;

    public RoundedCornersTransformation(BitmapPool pool, int radius, int margin) &#123;
        mBitmapPool = pool;
        this.radius = radius;
        this.margin = margin;
    &#125;

    @Override
    public Resource&lt;Bitmap&gt; transform(Resource&lt;Bitmap&gt; resource, int outWidth, int outHeight) &#123;
        Bitmap source = resource.get();

        int width = source.getWidth();
        int height = source.getHeight();

        Bitmap bitmap = mBitmapPool.get(width, height, Bitmap.Config.ARGB_8888);
        if (bitmap == null) &#123;
            bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
        &#125;

        Canvas canvas = new Canvas(bitmap);
        Paint paint = new Paint();
        paint.setAntiAlias(true);
        paint.setShader(new BitmapShader(source, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP));
        canvas.drawRoundRect(new RectF(margin, margin, width - margin, height - margin), radius, radius,
                paint);

        return BitmapResource.obtain(bitmap, mBitmapPool);
    &#125;

    @Override public String getId() &#123;
        return &quot;RoundedTransformation(radius=&quot; + radius + &quot;, margin=&quot; + margin + &quot;)&quot;;
    &#125;
&#125;
</code></pre>
<h3 id="灰度处理"><a href="#灰度处理" class="headerlink" title="灰度处理"></a>灰度处理</h3><pre><code>public class GrayscaleTransformation implements Transformation&lt;Bitmap&gt; &#123;

    private BitmapPool mBitmapPool;

    public GrayscaleTransformation(Context context) &#123;
        this(Glide.get(context).getBitmapPool());
    &#125;

    public GrayscaleTransformation(BitmapPool pool) &#123;
        mBitmapPool = pool;
    &#125;

    @Override
    public Resource&lt;Bitmap&gt; transform(Resource&lt;Bitmap&gt; resource, int outWidth, int outHeight) &#123;
        Bitmap source = resource.get();

        int width = source.getWidth();
        int height = source.getHeight();

        Bitmap.Config config =
                source.getConfig() != null ? source.getConfig() : Bitmap.Config.ARGB_8888;
        Bitmap bitmap = mBitmapPool.get(width, height, config);
        if (bitmap == null) &#123;
            bitmap = Bitmap.createBitmap(width, height, config);
        &#125;

        Canvas canvas = new Canvas(bitmap);
        ColorMatrix saturation = new ColorMatrix();
        saturation.setSaturation(0f);
        Paint paint = new Paint();
        paint.setColorFilter(new ColorMatrixColorFilter(saturation));
        canvas.drawBitmap(source, 0, 0, paint);

        return BitmapResource.obtain(bitmap, mBitmapPool);
    &#125;

    @Override public String getId() &#123;
        return &quot;GrayscaleTransformation()&quot;;
    &#125;
&#125;
</code></pre>
<h3 id="旋转处理"><a href="#旋转处理" class="headerlink" title="旋转处理"></a>旋转处理</h3><pre><code>public class RotateTransformation extends BitmapTransformation &#123;

    private float rotateRotationAngle = 0f;

    public RotateTransformation(Context context, float rotateRotationAngle) &#123;
        super(context);

        this.rotateRotationAngle = rotateRotationAngle;
    &#125;

    @Override
    protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123;
        Matrix matrix = new Matrix();

        matrix.postRotate(rotateRotationAngle);

        return Bitmap.createBitmap(toTransform, 0, 0, toTransform.getWidth(), toTransform.getHeight(), matrix, true);
    &#125;

    @Override
    public String getId() &#123;
        return &quot;rotate&quot; + rotateRotationAngle;
    &#125;
&#125;
</code></pre>
<h3 id="高斯模糊处理"><a href="#高斯模糊处理" class="headerlink" title="高斯模糊处理"></a>高斯模糊处理</h3><pre><code>public class BlurTransformation implements Transformation&lt;Bitmap&gt; &#123;

    private static int MAX_RADIUS = 25;
    private static int DEFAULT_DOWN_SAMPLING = 1;

    private Context mContext;
    private BitmapPool mBitmapPool;

    private int mRadius;
    private int mSampling;

    public BlurTransformation(Context context) &#123;
        this(context, Glide.get(context).getBitmapPool(), MAX_RADIUS, DEFAULT_DOWN_SAMPLING);
    &#125;

    public BlurTransformation(Context context, BitmapPool pool) &#123;
        this(context, pool, MAX_RADIUS, DEFAULT_DOWN_SAMPLING);
    &#125;

    public BlurTransformation(Context context, BitmapPool pool, int radius) &#123;
        this(context, pool, radius, DEFAULT_DOWN_SAMPLING);
    &#125;

    public BlurTransformation(Context context, int radius) &#123;
        this(context, Glide.get(context).getBitmapPool(), radius, DEFAULT_DOWN_SAMPLING);
    &#125;

    public BlurTransformation(Context context, BitmapPool pool, int radius, int sampling) &#123;
        mContext = context;
        mBitmapPool = pool;
        mRadius = radius;
        mSampling = sampling;
    &#125;

    public BlurTransformation(Context context, int radius, int sampling) &#123;
        mContext = context;
        mBitmapPool = Glide.get(context).getBitmapPool();
        mRadius = radius;
        mSampling = sampling;
    &#125;

    @Override
    public Resource&lt;Bitmap&gt; transform(Resource&lt;Bitmap&gt; resource, int outWidth, int outHeight) &#123;
        Bitmap source = resource.get();

        int width = source.getWidth();
        int height = source.getHeight();
        int scaledWidth = width / mSampling;
        int scaledHeight = height / mSampling;

        Bitmap bitmap = mBitmapPool.get(scaledWidth, scaledHeight, Bitmap.Config.ARGB_8888);
        if (bitmap == null) &#123;
            bitmap = Bitmap.createBitmap(scaledWidth, scaledHeight, Bitmap.Config.ARGB_8888);
        &#125;

        Canvas canvas = new Canvas(bitmap);
        canvas.scale(1 / (float) mSampling, 1 / (float) mSampling);
        Paint paint = new Paint();
        paint.setFlags(Paint.FILTER_BITMAP_FLAG);
        canvas.drawBitmap(source, 0, 0, paint);

        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR2) &#123;
            try &#123;
                bitmap = RSBlur.blur(mContext, bitmap, mRadius);
            &#125; catch (RSRuntimeException e) &#123;
                bitmap = FastBlur.blur(bitmap, mRadius, true);
            &#125;
        &#125; else &#123;
            bitmap = FastBlur.blur(bitmap, mRadius, true);
        &#125;

        return BitmapResource.obtain(bitmap, mBitmapPool);
    &#125;

    @Override public String getId() &#123;
        return &quot;BlurTransformation(radius=&quot; + mRadius + &quot;, sampling=&quot; + mSampling + &quot;)&quot;;
    &#125;
&#125;
</code></pre>
<p>网上提供的FastBlur,<strong>可兼容低版本的高斯模糊处理</strong></p>
<pre><code>public class FastBlur &#123;

    public static Bitmap blur(Bitmap sentBitmap, int radius, boolean canReuseInBitmap) &#123;

        Bitmap bitmap;
        if (canReuseInBitmap) &#123;
            bitmap = sentBitmap;
        &#125; else &#123;
            bitmap = sentBitmap.copy(sentBitmap.getConfig(), true);
        &#125;

        if (radius &lt; 1) &#123;
            return (null);
        &#125;

        int w = bitmap.getWidth();
        int h = bitmap.getHeight();

        int[] pix = new int[w * h];
        bitmap.getPixels(pix, 0, w, 0, 0, w, h);

        int wm = w - 1;
        int hm = h - 1;
        int wh = w * h;
        int div = radius + radius + 1;

        int r[] = new int[wh];
        int g[] = new int[wh];
        int b[] = new int[wh];
        int rsum, gsum, bsum, x, y, i, p, yp, yi, yw;
        int vmin[] = new int[Math.max(w, h)];

        int divsum = (div + 1) &gt;&gt; 1;
        divsum *= divsum;
        int dv[] = new int[256 * divsum];
        for (i = 0; i &lt; 256 * divsum; i++) &#123;
            dv[i] = (i / divsum);
        &#125;

        yw = yi = 0;

        int[][] stack = new int[div][3];
        int stackpointer;
        int stackstart;
        int[] sir;
        int rbs;
        int r1 = radius + 1;
        int routsum, goutsum, boutsum;
        int rinsum, ginsum, binsum;

        for (y = 0; y &lt; h; y++) &#123;
            rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0;
            for (i = -radius; i &lt;= radius; i++) &#123;
                p = pix[yi + Math.min(wm, Math.max(i, 0))];
                sir = stack[i + radius];
                sir[0] = (p &amp;amp; 0xff0000) &gt;&gt; 16;
                sir[1] = (p &amp;amp; 0x00ff00) &gt;&gt; 8;
                sir[2] = (p &amp;amp; 0x0000ff);
                rbs = r1 - Math.abs(i);
                rsum += sir[0] * rbs;
                gsum += sir[1] * rbs;
                bsum += sir[2] * rbs;
                if (i &gt; 0) &#123;
                    rinsum += sir[0];
                    ginsum += sir[1];
                    binsum += sir[2];
                &#125; else &#123;
                    routsum += sir[0];
                    goutsum += sir[1];
                    boutsum += sir[2];
                &#125;
            &#125;
            stackpointer = radius;

            for (x = 0; x &lt; w; x++) &#123;

                r[yi] = dv[rsum];
                g[yi] = dv[gsum];
                b[yi] = dv[bsum];

                rsum -= routsum;
                gsum -= goutsum;
                bsum -= boutsum;

                stackstart = stackpointer - radius + div;
                sir = stack[stackstart % div];

                routsum -= sir[0];
                goutsum -= sir[1];
                boutsum -= sir[2];

                if (y == 0) &#123;
                    vmin[x] = Math.min(x + radius + 1, wm);
                &#125;
                p = pix[yw + vmin[x]];

                sir[0] = (p &amp;amp; 0xff0000) &gt;&gt; 16;
                sir[1] = (p &amp;amp; 0x00ff00) &gt;&gt; 8;
                sir[2] = (p &amp;amp; 0x0000ff);

                rinsum += sir[0];
                ginsum += sir[1];
                binsum += sir[2];

                rsum += rinsum;
                gsum += ginsum;
                bsum += binsum;

                stackpointer = (stackpointer + 1) % div;
                sir = stack[(stackpointer) % div];

                routsum += sir[0];
                goutsum += sir[1];
                boutsum += sir[2];

                rinsum -= sir[0];
                ginsum -= sir[1];
                binsum -= sir[2];

                yi++;
            &#125;
            yw += w;
        &#125;
        for (x = 0; x &lt; w; x++) &#123;
            rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0;
            yp = -radius * w;
            for (i = -radius; i &lt;= radius; i++) &#123;
                yi = Math.max(0, yp) + x;

                sir = stack[i + radius];

                sir[0] = r[yi];
                sir[1] = g[yi];
                sir[2] = b[yi];

                rbs = r1 - Math.abs(i);

                rsum += r[yi] * rbs;
                gsum += g[yi] * rbs;
                bsum += b[yi] * rbs;

                if (i &gt; 0) &#123;
                    rinsum += sir[0];
                    ginsum += sir[1];
                    binsum += sir[2];
                &#125; else &#123;
                    routsum += sir[0];
                    goutsum += sir[1];
                    boutsum += sir[2];
                &#125;

                if (i &lt; hm) &#123;
                    yp += w;
                &#125;
            &#125;
            yi = x;
            stackpointer = radius;
            for (y = 0; y &lt; h; y++) &#123;
                // Preserve alpha channel: ( 0xff000000 &amp;amp; pix[yi] )
                pix[yi] = (0xff000000 &amp;amp; pix[yi]) | (dv[rsum] &lt; 16) | (dv[gsum] &lt; 8) | dv[bsum];

                rsum -= routsum;
                gsum -= goutsum;
                bsum -= boutsum;

                stackstart = stackpointer - radius + div;
                sir = stack[stackstart % div];

                routsum -= sir[0];
                goutsum -= sir[1];
                boutsum -= sir[2];

                if (x == 0) &#123;
                    vmin[y] = Math.min(y + r1, hm) * w;
                &#125;
                p = x + vmin[y];

                sir[0] = r[p];
                sir[1] = g[p];
                sir[2] = b[p];

                rinsum += sir[0];
                ginsum += sir[1];
                binsum += sir[2];

                rsum += rinsum;
                gsum += ginsum;
                bsum += binsum;

                stackpointer = (stackpointer + 1) % div;
                sir = stack[stackpointer];

                routsum += sir[0];
                goutsum += sir[1];
                boutsum += sir[2];

                rinsum -= sir[0];
                ginsum -= sir[1];
                binsum -= sir[2];

                yi += w;
            &#125;
        &#125;

        bitmap.setPixels(pix, 0, w, 0, 0, w, h);

        return (bitmap);
    &#125;
&#125;
</code></pre>
<h3 id="RenderScript处理高斯模糊"><a href="#RenderScript处理高斯模糊" class="headerlink" title="RenderScript处理高斯模糊"></a>RenderScript处理高斯模糊</h3><blockquote>
<p>android4.3之后可使用,需要在build.gradle中配置:</p>
</blockquote>
<pre><code>defaultConfig &#123;
    //BlurTransformation
    renderscriptTargetApi 23
    renderscriptSupportModeEnabled true
&#125;
</code></pre>
<blockquote>
</blockquote>
<pre><code>public class RSBlur &#123;

    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)
    public static Bitmap blur(Context context, Bitmap blurredBitmap, int radius) throws RSRuntimeException &#123;
        try &#123;
            RenderScript rs = RenderScript.create(context);
            Allocation input = Allocation.createFromBitmap(rs, blurredBitmap, Allocation.MipmapControl.MIPMAP_NONE,
                    Allocation.USAGE_SCRIPT);
            Allocation output = Allocation.createTyped(rs, input.getType());
            ScriptIntrinsicBlur blur = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs));

            blur.setInput(input);
            blur.setRadius(radius);
            blur.forEach(output);
            output.copyTo(blurredBitmap);
            rs.destroy();
        &#125; catch (RSRuntimeException e) &#123;
            blurredBitmap = FastBlur.blur(blurredBitmap, radius, true);
        &#125;
        return blurredBitmap;
    &#125;
&#125;
</code></pre>
<h2 id="16-动画处理"><a href="#16-动画处理" class="headerlink" title="16.动画处理"></a>16.动画处理</h2><p>通过animate()方法可以设置xml文件定义的4种补间动画(alpha、scale、translate、rotate)<br>例如:</p>
<p>res\anim\left_in.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;translate
        android:duration=&quot;@android:integer/config_mediumAnimTime&quot;
        android:fromXDelta=&quot;-50%p&quot;
        android:toXDelta=&quot;0&quot;/&gt;
    &lt;alpha
        android:duration=&quot;@android:integer/config_mediumAnimTime&quot;
        android:fromAlpha=&quot;0.0&quot;
        android:toAlpha=&quot;1.0&quot;/&gt;
&lt;/set&gt;
</code></pre>
<p>使用方式:  </p>
<pre><code>public class TestGlideActivity extends Activity &#123;
    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_test);
        ImageView targetView = (ImageView) findViewById(R.id.iv_target);
        Glide.with(this).
                load(R.drawable.test).
                asBitmap().
                animate(R.anim.left_in).//加载xml文件定义的动画
                into(targetView);
    &#125;
&#125;
</code></pre>
<p>处理此外,还可以通过animate指定属性动画:</p>
<pre><code> public class TestGlideActivity extends Activity &#123;
    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_test);
        ImageView targetView = (ImageView) findViewById(R.id.iv_target);

        ViewPropertyAnimation.Animator animationObject = new ViewPropertyAnimation.Animator() &#123;
            @Override
            public void animate(View view) &#123;
                //设置属性动画
                ObjectAnimator moveIn = ObjectAnimator.ofFloat(view, &quot;translationX&quot;, -500f, 0f);
                ObjectAnimator rotate = ObjectAnimator.ofFloat(view, &quot;rotation&quot;, 0f, 360f);
                ObjectAnimator fadeInOut = ObjectAnimator.ofFloat(view, &quot;alpha&quot;, 1f, 0f, 1f);
                ObjectAnimator moveTop = ObjectAnimator.ofFloat(view, &quot;translationY&quot;, 0f, -2000, 0f);
                AnimatorSet animSet = new AnimatorSet();
                //先左进,然后旋转伴随淡入效果,最后移动向上
                animSet.play(rotate).with(fadeInOut).after(moveIn).before(moveTop);
                animSet.setDuration(5000);
                animSet.start();
            &#125;
        &#125;;
        Glide.with(this).
                load(R.drawable.test).
                asBitmap().
                animate(animationObject).//加载属性动画
                into(targetView);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>我这里发现好像当调用了crossFade()方法，animate()方法定义的动画好像不会被调用，也就是没有效果。另外好像过渡动画只对ImageView对象有效果，当传入into()方法的参数为ViewTarget类型对象时，crossFade()和animate()好像都不会调用。这个还有待继续验证。  </p>
</blockquote>
<h2 id="17-回调：SimpleTarget和ViewTarget"><a href="#17-回调：SimpleTarget和ViewTarget" class="headerlink" title="17.回调：SimpleTarget和ViewTarget"></a>17.回调：SimpleTarget和ViewTarget</h2><p>Target接口代表Glide中资源最终被加载到的地方并且可以毁掉Glide中的生命周期方法。Target可以回调的生命周期方法有：  </p>
<ul>
<li>onLoadStarted</li>
<li>onResourceReady</li>
<li>onLoadCleared</li>
<li>onLoadFailed  </li>
</ul>
<p>典型的生命周期是：onLoadStarted -&gt; onResourceReady 或者 onLoadFailed -&gt; onLoadCleared。<br>实际可能某些方法不会调用，例如加入直接从内存缓存中加载资源，onLoadStarted方法便不会被调用了。<br>这里介绍两个Target实现类，同时也代表着两个常见的需求。<br><strong>有时候我们只是希望获得一张图片，而不想把它加载到什么地方上显示，对于这个需求使用SimpleTarget最合适不过了。</strong>  </p>
<pre><code>private SimpleTarget target = new SimpleTarget&lt;Bitmap&gt;() &#123;  
    @Override
    public void onResourceReady(Bitmap bitmap, GlideAnimation glideAnimation) &#123;

       //在这里我们就可以获得加载的资源了，当然这里是一个bitmap。
    &#125;
&#125;;

private void loadImageSimpleTarget() &#123;  
    Glide
        .with( context )
        .load( imageUrl)
        .asBitmap()
        .into( target ); //使用Target。
&#125;
</code></pre>
<blockquote>
<p>这里有点要在强调一下，就是关于传给with()方法的context实例。要记得Glide的生命周期会和这个context实例的生命周期相绑定。所以可能会有这样的场景：在activityA中获得图片，你把这个activityA传给with()方法，然后还没获得图片，用户跳转到activityB，在activityB要显示这个图片。很显然activityA在回调onStop()的时候Glide也停止请求那张图片，所以在activityB中也就没有图片可显示啦。  </p>
</blockquote>
<p>还可以指定SimpleTarget获得的资源的尺寸：  </p>
<pre><code>private SimpleTarget target2 = new SimpleTarget&lt;Bitmap&gt;( 250, 250 ) &#123;  
    @Override
    public void onResourceReady(Bitmap bitmap, GlideAnimation glideAnimation) &#123;
        imageView2.setImageBitmap( bitmap );
    &#125;
&#125;;  
</code></pre>
<p>另一个需求那就更常见了，而且也更迫切。__当你自定义一个view的时候，同时这个view还不是继承ImageView但是ta也有显示图片的需要，怎么办？__用ViewTarget来办：  </p>
<pre><code>//自定义的一个ViewGroup
public class CustomView extends FrameLayout &#123;  
    ImageView iv;
    TextView tv;

    public void initialize(Context context) &#123;
        inflate( context, R.layout.custom_view_, this );

        iv = (ImageView) findViewById( R.id.custom_view_image );
        tv = (TextView) findViewById( R.id.custom_view_text );
    &#125;

    public CustomView(Context context, AttributeSet attrs) &#123;
        super( context, attrs );
        initialize( context );
    &#125;

    public CustomView(Context context, AttributeSet attrs, int defStyleAttr) &#123;
        super( context, attrs, defStyleAttr );
        initialize( context );
    &#125;

    public void setImage(Drawable drawable) &#123;
        iv = (ImageView) findViewById( R.id.custom_view_image );

        iv.setImageDrawable( drawable );
    &#125;
&#125;

    CustomView customView = (CustomView) findViewById( R.id.custom_view );

    //定义一个ViewTarget，注意传入自定义View对象，还有ViewTarget的泛型。
    viewTarget = new ViewTarget&lt;CustomView, GlideDrawable&gt;( customView ) &#123;
        @Override
        public void onResourceReady(GlideDrawable resource, GlideAnimation&lt;? super GlideDrawable&gt; glideAnimation) &#123;
          //这里我们获得传入的自定义View，在这个自定义View中我们写了该View设置图片的方法。
            this.view.setImage( resource.getCurrent() );
        &#125;
    &#125;;

    Glide
        .with( context.getApplicationContext() )
        .load( eatFoodyImages[2] )
        .into( viewTarget ); //使用Target。  
</code></pre>
<h2 id="18-调试和错误处理"><a href="#18-调试和错误处理" class="headerlink" title="18.调试和错误处理"></a>18.调试和错误处理</h2><p>可以使用ADB命令来查看资源请求时的日志：  </p>
<pre><code>adb shell setprop log.tag.GenericRequest DEBUG [还可选VERBOSE，INFO，WARN，ERROR日志级别]  
</code></pre>
<p>虽然有error()帮我们处理请求图片出错时的情况，但有时我们也想自己作一些处理，最起码得看看发生了什么是吧。用listener()注册一个RequestListener便可以得到请求资源时的一些关键回调方法：  </p>
<pre><code>private RequestListener&lt;String, GlideDrawable&gt; requestListener = new RequestListener&lt;String, GlideDrawable&gt;() &#123;  
    @Override
    public boolean onException(Exception e, String model, Target&lt;GlideDrawable&gt; target, boolean isFirstResource) &#123;
        //获得异常你想怎么处理随你的便利。
        return false;  //如果返回true，Glide认为你已经处理好了这个异常，那么error()方法也就不会调用了。
    &#125;

    @Override
    public boolean onResourceReady(GlideDrawable resource, String model, Target&lt;GlideDrawable&gt; target, boolean isFromMemoryCache, boolean isFirstResource) &#123;
        return false;
    &#125;
&#125;;

Glide  
    .with( context )
    .load(UsageExampleListViewAdapter.eatFoodyImages[0])
    .listener( requestListener ) //注册监听器。
    .error( R.drawable.cupcake )
    .into( imageViewPlaceholder );  
</code></pre>
<p>当然Glide还有其它的监听器也很有用，例如LifecycleListener就可以在Glide里监听Fragment和Activity的onStart()、onStop()和onDestroy()回调。  </p>
<h2 id="19-集成自己的网络库"><a href="#19-集成自己的网络库" class="headerlink" title="19.集成自己的网络库"></a>19.集成自己的网络库</h2><p>你可以使用自己的网络库，但这个细讲起来还比较复杂。这里介绍当你的工程使用的是OkHttp或者Volley的情况，稍微配置一下build.gradle，其它什么都不用做了：  </p>
<pre><code>dependencies &#123;  
    // 其它配置

    compile &#39;com.github.bumptech.glide:glide:3.7.0&#39;

    // 特别注意这个，就是ta让你可以使用OkHttp作为自己的网络请求库。
    compile &#39;com.github.bumptech.glide:okhttp-integration:1.4.0@aar&#39;
    compile &#39;com.squareup.okhttp:okhttp:2.7.5&#39;

    // 针对Volley的配置。
    //compile &#39;com.github.bumptech.glide:volley-integration:1.4.0@aar&#39;
    //compile &#39;com.mcxiaoke.volley:library:1.0.8&#39;

    // 针对OkHttp3的配置。
    //compile &#39;com.github.bumptech.glide:okhttp3-integration:1.4.0@aar&#39;
    //compile &#39;com.squareup.okhttp3:okhttp:3.2.0&#39;
&#125;
</code></pre>
<blockquote>
<p><a href="http://www.androidchina.net/5022.html">摘录来源</a></p>
</blockquote>
]]></content>
      <categories>
        <category>第三方框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Glide</tag>
        <tag>图片加载</tag>
        <tag>第三方框架</tag>
      </tags>
  </entry>
  <entry>
    <title>《Effective Java》笔记</title>
    <url>/2016/11/03/EffectiveJava/</url>
    <content><![CDATA[<p>Effective Java 笔记摘录  </p>
<span id="more"></span>

<h2 id="对象的创建与销毁"><a href="#对象的创建与销毁" class="headerlink" title="对象的创建与销毁"></a>对象的创建与销毁</h2><ul>
<li> Item 1: 使用static工厂方法，而不是构造函数创建对象：仅仅是创建对象的方法，并非Factory Pattern</li>
<li> 优点    +  命名、接口理解更高效，通过工厂方法的函数名，而不是参数列表来表达其语义    +  Instance control，并非每次调用都会创建新对象，可以使用预先创建好的对象，或者做对象缓存；便于实现单例；或不可实例化的类；对于immutable的对象来说，使得用<code>==</code>判等符合语义，且更高效；    +  工厂方法能够返回任何返回类型的子类对象，甚至是私有实现；使得开发模块之间通过接口耦合，降低耦合度；而接口的实现也将更加灵活；接口不能有static方法，通常做法是为其再创建一个工厂方法类，如Collection与Collections；    +  Read More: Service Provider Framework</li>
<li>缺点<pre><code>+  仅有static工厂方法，没有public/protected构造函数的类将无法被继承；见仁见智，这一方面也迫使开发者倾向于组合而非继承；    +  Javadoc中不能和其他static方法区分开，没有构造函数的集中显示优点；但可以通过公约的命名规则来改善；
</code></pre>
</li>
<li>小结<br>static工厂方法和public构造函数均有其优缺点，在编码过程中，可以先考虑一下工厂方法是否合适，再进行选择。</li>
<li> Item 2: 使用当构造函数的参数较多，尤其是其中还有部分是可选参数时，使用Builder模式</li>
<li> 以往的方法    +  Telescoping constructor：针对可选参数，从0个到最多个，依次编写一个构造函数，它们按照参数数量由少到多逐层调用，最终调用到完整参数的构造函数；代码冗余，有时还得传递无意义参数，而且容易导致使用过程中出隐蔽的bug；    +  JavaBeans Pattern：灵活，但是缺乏安全性，有状态不一致问题，线程安全问题；</li>
<li> Builder Pattern    +  代码灵活简洁；具备安全性；    +  immutable    +  参数检查：最好放在要build的对象的构造函数中，而非builder的构建过程中    +  支持多个field以varargs的方式设置（每个函数只能有一个varargs）    +  一个builder可以build多个对象    +  Builder结合泛型，实现Abstract Factory Pattern    +  传统的抽象工厂模式，是用Class类实现的，然而其有缺点：newInstance调用总是去调用无参数构造函数，不能保证存在；newInstance方法会抛出所有无参数构造函数中的异常，而且不会被编译期的异常检查机制覆盖；可能会导致运行时异常，而非编译期错误；</li>
<li>小结<br>Builder模式在简单地类（参数较少，例如4个以下）中，优势并不明显，但是需要予以考虑，尤其是当参数可能会变多时，有可选参数时更是如此。</li>
<li> Item 3: 单例模式！<br>不管以哪种形式实现单例模式，它们的核心原理都是将构造函数私有化，并且通过静态方法获取一个唯一的实例，在这个获取的过程中你必须保证线程安全、反序列化导致重新生成实例对象等问题，该模式简单，但使用率较高。</li>
<li>double-check-locking  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> RestAdapter sRestAdapter = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RestAdapter <span class="title">provideRestAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sRestAdapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (RestProvider.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sRestAdapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sRestAdapter = <span class="keyword">new</span> RestAdapter();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sRestAdapter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
DCL可能会失效，因为指令重排可能导致同步解除后，对象初始化不完全就被其他线程获取；使用volatile关键字修饰对象，或者使用static SingletonHolder来避免该问题（后者JLS推荐）；</li>
<li> class的static代码：一个类只有在被使用时才会初始化，而类初始化过程是非并行的，这些都由JLS能保证</li>
<li> 用enum实现单例</li>
<li> 还存在反射安全性问题：利用反射，可以访问私有方法，可通过加一个控制变量，该变量在getInstance函数中设置，如果不是从getInstance调用构造函数，则抛出异常；</li>
<li>Item 4: 将构造函数私有化，使得不能从类外创建实例，同时也能禁止类被继承<br>util类可能不希望被实例化，有其需求</li>
<li> Item 5: 避免创建不必要的对象</li>
<li> 提高性能：创建对象需要时间、空间，“重量级”对象尤甚；immutable的对象也应该避免重复创建，例如String；</li>
<li> 避免auto-boxing</li>
<li> 但是因此而故意不创建必要的对象是错误的，使用object pool通常也是没必要的</li>
<li> lazy initialize也不是特别必要，除非使用场景很少且很重量级</li>
<li> Map#keySet方法，每次调用返回的是同一个Set对象，如果修改了返回的set，其他使用的代码可能会产生bug</li>
<li> 需要defensive copying的时候，如果没有创建一个新对象，将导致很隐藏的Bug</li>
<li> Item 6: 不再使用的对象一定要解除引用，避免memory leak</li>
<li> 例如，用数组实现一个栈，pop的时候，如果仅仅是移动下标，没有把pop出栈的数组位置引用解除，将发生内存泄漏</li>
<li> 程序发生错误之后，应该尽快把错误抛出，而不是以错误的状态继续运行，否则可能导致更大的问题</li>
<li> 通过把变量（引用）置为null不是最好的实现方式，只有在极端情况下才需要这样；好的办法是通过作用域来使得变量的引用过期，所以尽量缩小变量的作用域是很好的实践；注意，在Dalvik虚拟机中，存在一个细微的bug，可能会导致内存泄漏，<a href="MemoryLeak.md">详见</a></li>
<li> 当一个类管理了一块内存，用于保存其他对象（数据）时，例如用数组实现的栈，底层通过一个数组来管理数据，但是数组的大小不等于有效数据的大小，GC器却并不知道这件事，所以这时候，需要对其管理的数据对象进行null解引用</li>
<li> 当一个类管理了一块内存，用于保存其他对象（数据）时，程序员应该保持高度警惕，避免出现内存泄漏，一旦数据无效之后，需要立即解除引用</li>
<li> 实现缓存的时候也很容易导致内存泄漏，放进缓存的对象一定要有换出机制，或者通过弱引用来进行引用</li>
<li> listner和callback也有可能导致内存泄漏，最好使用弱引用来进行引用，使得其可以被GC</li>
<li> Item 7: 不要使用finalize方法</li>
<li> finalize方法不同于C++的析构函数，不是用来释放资源的好地方</li>
<li> finalize方法执行并不及时，其执行线程优先级很低，而当对象unreachable之后，需要执行finalize方法之后才能释放，所以会导致对象生存周期变长，甚至根本不会释放</li>
<li> finalize方法的执行并不保证执行成功/完成</li>
<li> 使用finalize时，性能会严重下降</li>
<li> finalize存在的意义    +  充当“safety net”的角色，避免对象的使用者忘记调用显式termination方法，尽管finalize方法的执行时间没有保证，但是晚释放资源好过不释放资源；此处输出log警告有利于排查bug    +  用于释放native peer，但是当native peer持有必须要释放的资源时，应该定义显式termination方法</li>
<li> 子类finalize方法并不会自动调用父类finalize方法（和构造函数不同），为了避免子类不手动调用父类的finalize方法导致父类的资源未被释放，当需要使用finalize时，使用finalizer guardian比较好：    +  定义一个私有的匿名Object子类对象，重写其finalize方法，在其中进行父类要做的工作    +  因为当父类对象被回收时，finalizer guardian也会被回收，它的finalize方法就一定会被触发</li>
</ul>
<h2 id="Object的方法"><a href="#Object的方法" class="headerlink" title="Object的方法"></a>Object的方法</h2><p>尽管Object不是抽象类，但是其定义的非final方法设计的时候都是希望被重写的，finalize除外。</p>
<ul>
<li> Item 8: 当重写equals方法时，遵循其语义</li>
<li> 能不重写equals时就不要重写    +  当对象表达的不是值，而是可变的状态时    +  对象不需要使用判等时    +  父类已重写，且满足子类语义</li>
<li> 当需要判等，且继承实现无法满足语义时，需要重写（通常是“value class”，或immutable对象）</li>
<li> 当用作map的key时</li>
<li> 重写equals时需要遵循的语义    +  Reflexive（自反性）: x.equals(x)必须返回true（x不为null）    +  Symmetric（对称性）: x.equals(y) == y.equals(x)    +  Transitive（传递性）: x.equals(y) &amp;&amp; y.equals(z) ==&gt; x.equals(z)    +  Consistent（一致性）: 当对象未发生改变时，多次调用应该返回同一结果    +  x.equals(null)必须返回false</li>
<li> 实现建议    +  先用==检查是否引用同一对象，提高性能    +  用instanceof再检查是否同一类型    +  再强制转换为正确的类型    +  再对各个域进行equals检查，遵循同样的规则    +  确认其语义正确，编写测例    +  重写equals时，同时也重写hashCode    +  ！重写equals方法，传入的参数是Object</li>
<li> Item 9: 重写equals时也重写hashCode函数</li>
<li> 避免在基于hash的集合中使用时出错</li>
<li> 语义    +  一致性    +  当两个对象equals返回true时，hashCode方法的返回值也要相同</li>
<li>hashCode的计算方式    +  要求：equals的两个对象hashCode一样，但是不equals的对象hashCode不一样    +  取一个素数，例如17，result = 17    +  对每一个关心的field（在equals中参与判断的field），记为f，将其转换为一个int，记为c<ul>
<li> boolean: f ? 1 : 0</li>
<li> byte/char/short/int: (int) f</li>
<li> long: (int) (f ^ (f &gt;&gt; 32))</li>
<li> float: Float.floatToIntBits(f)</li>
<li> double: Double.doubleToLongBits(f)，再按照long处理</li>
<li> Object: f == null ? 0 : f.hashCode()</li>
<li> array: 先计算每个元素的hashCode，再按照int处理    +  对每个field计算的c，result = 31 * result + c    +  返回result    +  编写测例</li>
</ul>
</li>
<li> 计算hashCode时，不重要的field（未参与equals判断）不要参与计算</li>
<li> Item 10: 重写toString()方法</li>
<li> 增加可读性，简洁、可读、具有信息量</li>
<li> Item 11: 慎重重写clone方法</li>
<li> Cloneable接口是一个mixin interface，用于表明一个对象可以被clone</li>
<li> Contract    +  x.clone() != x    +  x.clone().getClass() ==  x.getClass()：要求太弱，当一个非final类重写clone方法的时候，创建的对象一定要通过super.clone()来获得，所有父类都遵循同样的原则，如此最终通过Object.clone()创建对象，能保证创建的是正确的类实例。而这一点很难保证。    +  x.clone().equals(x)    +  不调用构造函数：要求太强，一般都会在clone函数里面调用</li>
<li> 对于成员变量都是primitive type的类，直接调用super.clone()，然后cast为自己的类型即可（重写时允许返回被重写类返回类型的子类，便于使用方，不必每次cast）</li>
<li> 成员变量包含对象（包括primitive type数组），可以通过递归调用成员的clone方法并赋值来实现</li>
<li> 然而上述方式违背了final的使用协议，final成员不允许再次赋值，然而clone方法里面必须要对其赋值，则无法使用final保证不可变性了</li>
<li> 递归调用成员的clone方法也会存在性能问题，对HashTable递归调用深拷贝也可能导致StackOverFlow（可以通过遍历添加来避免）</li>
<li> 优雅的方式是通过super.clone()创建对象，然后为成员变量设置相同的值，而不是简单地递归调用成员的clone方法</li>
<li> 和构造函数一样，在clone的过程中，不能调用non final的方法，如果调用虚函数，那么该函数会优先执行，而此时被clone的对象状态还未完成clone/construct，会导致corruption。因此上一条中提及的“设置相同的值”所调用的方法，要是final或者private。</li>
<li> 重载类的clone方法可以省略异常表的定义，如果重写时把可见性改为public，则应该省略，便于使用；如果设计为应该被继承，则应该重写得和Object的一样，且不应该实现Cloneable接口；多线程问题也需要考虑；</li>
<li> 要实现clone方法的类，都应该实现Cloneable接口，同时把clone方法可见性设为public，返回类型为自己，应该调用super.clone()来创建对象，然后手动设置每个域的值</li>
<li> clone方法太过复杂，如果不实现Cloneable接口，也可以通过别的方式实现copy功能，或者不提供copy功能，immutable提供copy功能是无意义的</li>
<li> 提供拷贝构造函数，或者拷贝工厂方法，而且此种方法更加推荐，但也有其不足</li>
<li> 设计用来被继承的类时，如果不实现一个正确高效的clone重写，那么其子类也将无法实现正确高效的clone功能</li>
<li> Item 12: 当对象自然有序时，实现Comparable接口</li>
<li> 实现Comparable接口可以利用其有序性特点，提高集合使用/搜索/排序的性能</li>
<li> Contact    +  sgn(x.compareTo(y)) == - sgn(y.compareTo(x))，当类型不对时，应该抛出ClassCastException，抛出异常的行为应该是一致的    +  transitive: x.compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0 ==&gt; x.compareTo(z) &gt; 0    +  x.compareTo(y) == 0 ==&gt; sgn(x.compareTo(z)) == sgn(y.compareTo(z))    +  建议，但非必须：与equals保持一致，即 x.compareTo(y) == 0 ==&gt; x.equals(y)，如果不一致，需要在文档中明确指出</li>
<li> TreeSet, TreeMap等使用的就是有序保存，而HashSet, HashMap则是通过equals + hashCode保存</li>
<li> 当要为一个实现了Comparable接口的类增加成员变量时，不要通过继承来实现，而是使用组合，并提供原有对象的访问方法，以保持对Contract的遵循</li>
<li> 实现细节    +  优先比较重要的域    +  谨慎使用返回差值的方式，有可能会溢出</li>
</ul>
<h2 id="Classes-and-Interfaces"><a href="#Classes-and-Interfaces" class="headerlink" title="Classes and Interfaces"></a>Classes and Interfaces</h2><ul>
<li> Item 13: 最小化类、成员的可见性</li>
<li> 封装（隐藏）：公开的接口需要暴露，而接口的实现则需要隐藏，使得接口与实现解耦，降低模块耦合度，增加可测试性、稳定性、可维护性、可优化性、可修改性</li>
<li> 如果一个类只对一个类可见，则应该将其定义为私有的内部类，而没必要public的类都应该定义为package private</li>
<li> 为了便于测试，可以适当放松可见性，但也只应该改为package private，不能更高</li>
<li> 成员不能是非private的，尤其是可变的对象。一旦外部可访问，将失去对其内容的控制能力，而且会有多线程问题</li>
<li> 暴露的常量也不能是可变的对象，否则public static final也将失去其意义，final成员无法改变其指向，但其指向的对象却是可变的（immutable的对象除外），长度非0的数组同样也是有问题的，可以考虑每次访问时创建拷贝，或者使用<code>Collections.unmodifiableList(Arrays.asList(arr))</code></li>
<li> Item 14: public class中，使用accessor method而非public field</li>
<li> 后者外部可以直接访问，失去了安全性</li>
<li> package private或者private则可以不必这样</li>
<li> 把immutable的field置为public勉强可以接受，mutable的成员一定不能置为public</li>
<li> Item 15: 最小化可变性</li>
<li> 不提供可以改变本对象状态的方法</li>
<li> 保证类不可被继承</li>
<li> 使用final field</li>
<li> 使用private field</li>
<li> 在构造函数、accessor中，对mutable field使用defensive copy</li>
<li> 实现建议    +  操作函数，例如BigInteger的add方法，不是static的，但也不能改变本对象的状态，则使用functional的方式，返回一个新的对象，其状态是本对象修改之后的状态    +  如此实现的immutable对象生来就是线程安全的，无需同步操作，但应该鼓励共用实例，避免创建过多重复的对象    +  正确实现的immutable对象也不需要clone, copy方法；可以适当引入Object cache；</li>
<li> 劣势    +  每一个值都需要一个对象，调用改变状态的方法而创建一个新的对象，尤其是它是重量级的，开销会变大；连续调用这样的方法，影响更大；    +  为常用的多次操作组合提供一个方法</li>
<li> 其他    +  保证class无法被继承，除了声明为final外，还可以将默认构造函数声明为private或package private，然后提供public static工厂方法    +  使用public static工厂方法，具体实现类可以有多个，还能进行object cache    +  当实现Serializable接口是，一定要实现readObject/readResolve方法，或者使用ObjectOutputStream.writeUnshared/ObjectInputStream.readUnshared</li>
<li> 小结    +  除非有很好的理由让一个Class mutable，否则应该使其immutable    +  如果非要mutable，也应尽可能限制其可变性</li>
<li> Item 16: Favor composition (and forwarding) over inheritance</li>
<li> 跨包继承、继承不是被设计为应该被继承的实现类，是一件很危险的事情，继承接口、继承抽象类，当然是没问题的</li>
<li> 如果子类的功能依赖于父类的实现细节，那么一旦父类发生变化，子类将有可能出现Bug，即便代码都没有修改；而设计为应被继承的类，在修改后，是应该有文档说明的，子类开发者既可以得知，也可以知道如何修改</li>
<li> 例子：统计HashSet添加元素的次数    +  用继承方式，重写add，addAll，在其中计数，这就不对，因为HashSet内部的addAll是通过调用add实现的    +  但是通过不重写addAll也只不对的，以后有可能HashSet的实现就变了    +  在重写中重新实现一遍父类的逻辑也是行不通的，因为这可能会导致性能问题、bug等，而且有些功能不访问私有成员也是无法实现的    +  还有一个原因就是父类的实现中，可能会增加方法，改变其行为，而这一点，在子类中是无法控制的</li>
<li> 而通过组合的方式，将不会有这些问题，把另一个类的对象声明为私有成员，外部将无法访问它，自己也能在转发（forwarding）过程中执行拦截操作，也不必依赖其实现细节，这种组合、转发的实现被称为wrapper，或者Decorator pattern，或者delegation（严格来说不是代理，代理一般wrapper对象都需要把自己传入到被wrap的对象方法中？）</li>
<li> 缺点    +  不适用于callback frameworks？</li>
<li> 继承应该在is-a的场景中使用</li>
<li> 继承除了会继承父类的API功能，也会继承父类的设计缺陷，而组合则可以隐藏成员类的设计缺陷</li>
<li> Item 17: Design and document for inheritance or else prohibit it</li>
<li> 一个类必须在文档中说明，每个可重写的方法，在该类的实现中的哪些地方会被调用（the class must document its self-use of overridable methods）。调用时机、顺序、结果产生的影响，包括多线程、初始化等情况。</li>
<li> 被继承类应该通过谨慎选择protected的方法或成员，来提供一些hook，用于改变其内部的行为，例如java.util.AbstractList::removeRange。</li>
<li> The only way to test a class designed for inheritance is to write subclasses. 用于判断是否需要增加或者减少protected成员/方法，通常写3个子类就差不多了。</li>
<li> You must test your class by writing subclasses before you release it.</li>
<li> Constructors must not invoke overridable methods. 父类的构造函数比子类的构造函数先执行，而如果父类构造函数中调用了可重写的方法，那么就会导致子类的重写方法比子类的构造函数先执行，会导致corruption。</li>
<li> 如果实现了Serializable/Cloneable接口，neither clone nor readObject may invoke an overridable method, directly or indirectly. 重写方法会在deserialized/fix the clone’s state之前执行。</li>
<li> 如果实现了Serializable接口，readResolve/writeReplace必须是protected，而非private</li>
<li> designing a class for inheritance places substantial limitations on the class.</li>
<li> The best solution to this problem is to prohibit subclassing in classes that are not designed and documented to be safely subclassed. 声明为final class或者把构造函数私有化（提供public static工厂方法）。</li>
<li> 如果确实想要允许继承，就应该为每个被自己使用的可重写方法都写好文档</li>
<li> Item 18: Prefer interfaces to abstract classes</li>
<li> Java类只允许单继承，接口可以多继承，使用接口定义类型，使得class hierarchy更加灵活</li>
<li> 定义mixin（optional functionality to be “mixed in”）时使用interface是很方便的，需要增加此功能的类只需要implement该接口即可，而如果使用抽象类，则无法增加一个extends语句</li>
<li> 接口允许构建没有hierarchy的类型系统</li>
<li> 使用接口定义类型，可以使得item 16中提到的wrapper模式更加安全、强大，</li>
<li> skeletal implementation：该类为abstract，把必须由client实现的方法设为abstract，可以有默认实现的则提供默认实现</li>
<li> simulated multiple inheritance：通过实现定义的接口，同时在内部实现一个匿名的skeletal implementation，将对对该接口的调用转发到匿名类中，起到“多继承”的效果</li>
<li> simple implementation：提供一个非抽象的接口实现类，提供一个最简单、能work的实现，也允许被继承</li>
<li> 使用接口定义类型的缺点：不便于演进，一旦接口发布，如果想要增加功能（增加方法），则client将无法编译；而使用abstract class，则没有此问题，只需要提供默认实现即可</li>
<li> 小结    +  通过接口定义类型，可以允许多实现（多继承）    +  但是演进需求大于灵活性、功能性时，抽象类更合适    +  提供接口时，提供一个skeletal implementation，同时审慎考虑接口设计</li>
<li> Item 19: 仅仅用interface去定义一个类型，该接口应该有实现类，使用者通过接口引用，去调用接口的方法</li>
<li> 避免用接口去定义常量，应该用noninstantiable utility class去定义常量</li>
<li> 相关常量的命名，通过公共前缀来实现分组</li>
<li> Item 20: Prefer class hierarchies to tagged classes</li>
<li> tagged class: 在内部定义一个tag变量，由其控制功能的转换</li>
<li> tag classes are verbose, error-prone, and inefficient</li>
<li> 而class hierarchy，不同功能由不同子类实现，公共部分抽象为一个基类，也能反映出各个子类之间的关系</li>
<li> Item 21: Use function objects to represent strategies</li>
<li> 只提供一个功能函数的类实例，没有成员变量，只需一个对象（单例），为其功能定义一个接口，则可以实现策略模式，把具体策略传入相应函数中，使用策略</li>
<li> 具体的策略实例通常使用匿名类定义，调用使用该策略的方法时才予以创建/预先创建好之后每次将其传入</li>
<li> Item 22: Favor static member classes over nonstatic</li>
<li> 有4种nested class：non-static member class; static member class(inner class); anonymous class; local class</li>
<li> static member class    +  经常作为helper class，和外部类一起使用    +  如果nested class的生命周期独立于外部类存在，则必须定义为static member class，否则可能造成内存泄漏    +  private static member class用处一：表示（封装）外部类的一些成员，例如Map的Entry内部类。</li>
<li> non-static member class    +  将持有外部类实例的强引用，可以直接引用外部类的成员和方法    +  用处一：定义一个Adapter，使得外部内的实例，可以作为和外部类语义不同的实例来查看（访问），例如Collection的Iterator。    +  如果nested class不需要引用外部类的成员和方法，则一定要将其定义为static，避免空间/时间开销，避免内存泄漏</li>
<li>anonymous class    +  当在非static代码块内定义时，会持有外部类的引用，否则不会持有    +  限制<ul>
<li> 只能在被声明的地方进行实例化</li>
<li> 无法进行instanceof测试</li>
<li> 不能用匿名类实现多个接口</li>
<li> 不能用匿名类继承一个类的同时实现接口</li>
<li> 匿名类中新添加的方法无法在匿名类外部访问</li>
<li> 不能有static成员    +  应该尽量保持简短    +  用处一：创建function object    +  用处二：创建process object，例如：Runnable, Thread, TimberTask    +  用处三：用于public static工厂方法，例如Collections类里面的一些工厂方法，很多是返回一个匿名的内部实现</li>
</ul>
</li>
<li> local class    +  比较少用    +  是否static取决于其定义的上下文    +  可以在作用域内重复使用    +  不能有static成员    +  也应尽量保持简短</li>
<li> 小结    +  四种nested class    +  如果nested class在整个外部类内都需要可见，或者定义代码太长，应使用member class    +  能static就一定要static，即便需要对外部类进行引用，对于生命周期独立于外部类的，也应该通过WeakReference进行引用，避免内存泄漏；至于生命周期和外部类一致的，则不必这样</li>
</ul>
<h2 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h2><ul>
<li> Item 23: Don’t use raw types in new code</li>
<li> Java泛型，例如<code>List&lt;E&gt;</code>，真正使用的时候都是<code>List&lt;String&gt;</code>等，把E替换为实际的类型</li>
<li> Java泛型从1.5引入，为了保持兼容性，实现的是伪泛型，类型参数信息在编译完成之后都会被擦除，其在运行时的类型都是raw type，类型参数保存的都是Object类型，<code>List&lt;E&gt;</code>的raw type就是<code>List</code></li>
<li> 编译器在编译期通过类型参数，为读操作自动进行了类型强制转换，同时在写操作时自动进行了类型检查</li>
<li> 如果使用raw type，那编译器就不会在写操作时进行类型检查了，写入错误的类型也不会报编译错误，那么在后续读操作进行强制类型转换时，将会导致转换失败，抛出异常</li>
<li> 一旦错误发生，应该让它尽早被知道（抛出/捕获），编译期显然优于运行期</li>
<li><code>List</code>与<code>List&lt;Object&gt;</code>的区别    +  前者不具备类型安全性，后者具备，例如以下代码  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Uses raw type (List) - fails at runtime!</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">  unsafeAdd(strings, <span class="keyword">new</span> Integer(<span class="number">42</span>));</span><br><span class="line">  String s = strings.get(<span class="number">0</span>); <span class="comment">// Compiler-generated cast</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unsafeAdd</span><span class="params">(List list, Object o)</span> </span>&#123;</span><br><span class="line">  list.add(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  不会报编译错误，但会给一个编译警告：<code>Test.java:10: warning: unchecked call to add(E) in raw type List list.add(o);</code>，而运行时则会发生错误。    +  但如果使用<code>List&lt;Object&gt;</code>，即<code>unsageAdd</code>参数改为<code>List&lt;Object&gt; list, Object o</code>，则会报编译错误：<code>Test.java:5: unsafeAdd(List&lt;Object&gt;,Object) cannot be applied to (List&lt;String&gt;,Integer) unsafeAdd(strings, new Integer(42));</code>      +  因为<code>List&lt;String&gt;</code>是<code>List</code>的子类，但却不是<code>List&lt;Object&gt;</code>的子类。      +  并不是说这个场景应该使用<code>List&lt;Object&gt;</code>，这个场景应该使用<code>List&lt;String&gt;</code>，这里只是为了说明<code>List</code>和<code>List&lt;Object&gt;</code>是有区别的。</li>
<li><code>List</code> v.s. <code>List&lt;?&gt;</code>（unbounded wildcard types），当不确定类型参数，或者说类型参数不重要时，也不应该使用raw type，而应该使用<code>List&lt;?&gt;</code>    +  任何参数化的List均是<code>List&lt;?&gt;</code>的子类，可以作为参数传入接受<code>List&lt;?&gt;</code>的函数，例如以下代码均是合法的：  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="keyword">new</span> List&lt;Object&gt;());</span><br><span class="line">func(<span class="keyword">new</span> List&lt;Integer&gt;());</span><br><span class="line">func(<span class="keyword">new</span> List&lt;String&gt;());</span><br></pre></td></tr></table></figure>    +  持有`List<?>`的引用后，并不能向其中加入任何元素，读取出来的元素也是`Object`类型，而不会被自动强转为任何类型。    +  如果`List<?>`的行为不能满足需求，可以考虑使用模板方法，或者`List<E extends XXX>`（bounded wildcard types）</li>
<li>You must use raw types in class literals.<pre><code>+  `List.class`, `String[].class`, and `int.class` are all legal, but `List&lt;String&gt;.class` and `List&lt;?&gt;.class` are not.
</code></pre>
</li>
<li><code>instanceof</code>不支持泛型，以下用法是推荐的，但不应该将<code>o</code>强转为<code>List</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Legitimate use of raw type - instanceof operator</span></span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Set) &#123; <span class="comment">// Raw type</span></span><br><span class="line">  Set&lt;?&gt; m = (Set&lt;?&gt;) o; <span class="comment">// Wildcard type</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>相关术语汇总<br><img src="http://img.shedoor.net/ocnyangcom/java_generic_terms.png" alt="java_generic_terms.png"></li>
<li> Item 24: Eliminate unchecked warnings</li>
<li> 当出现类型不安全的强制转换时（一般都是涉及泛型，raw type），编译器会给出警告，首先要做的是尽量消除不安全的转换，消除警告</li>
<li> 实在无法消除/确定不会导致运行时的<code>ClassCastException</code>，可以通过<code>@SuppressWarnings(&quot;unchecked&quot;)</code>消除警告，但不要直接忽略该警告</li>
<li> 使用<code>@SuppressWarnings(&quot;unchecked&quot;)</code>时，应该在注视内证明确实不存在运行时的<code>ClassCastException</code>；同时应该尽量减小其作用的范围，通常是应该为一个赋值语句添加注解</li>
<li> Item 25: Prefer lists to arrays</li>
<li> arrays are covariant(协变): 如果<code>Sub</code>是<code>Super</code>的子类，那么<code>Sub[]</code>也是<code>Super[]</code>的子类</li>
<li> generics are invariant(不变): 任意两个不同的类<code>Type1</code>和<code>Type2</code>，<code>List&lt;Type1&gt;</code>和<code>List&lt;Type2&gt;</code>之间没有任何继承关系</li>
<li>考虑以下代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fails at runtime!</span></span><br><span class="line">Object[] objectArray = <span class="keyword">new</span> Long[<span class="number">1</span>];</span><br><span class="line">objectArray[<span class="number">0</span>] = <span class="string">&quot;I don&#x27;t fit in&quot;</span>; <span class="comment">// Throws ArrayStoreException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Won&#x27;t compile!</span></span><br><span class="line">List&lt;Object&gt; ol = <span class="keyword">new</span> ArrayList&lt;Long&gt;(); <span class="comment">// Incompatible types</span></span><br><span class="line">ol.add(<span class="string">&quot;I don&#x27;t fit in&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li> arrays are reified(具体化): array在运行时能知道且强制要求元素的类型</li>
<li> generics are implemented by erasure(non-reifiable): 仅仅在编译时知道元素的类型</li>
<li> 数组和泛型同时使用时会受到很大限制    +  以下语句均不能通过编译：<code>new List&lt;E&gt;[], new List&lt;String&gt;[], new E[]</code>；但是声明是可以的，例如<code>List&lt;String&gt;[] stringLists</code></li>
<li> non-reifiable type: 例如<code>E, List&lt;E&gt;, List&lt;String&gt;</code>，这些类型在运行时的信息比编译时的信息更少</li>
<li> 只有unbounded wildcard type才是reifiable的，如：<code>List&lt;?&gt;, Map&lt;?, ?&gt;</code></li>
<li> 常规来说，不能返回泛型元素的数组，因为会报编译错误：<code>generic array creation errors</code></li>
<li> 当泛型和<code>varargs</code>一起使用时，也会导致编译警告</li>
<li> 有时为了类型安全，不得不做些妥协，牺牲性能和简洁，使用List而不是数组</li>
<li> 把数组强转为non-reifiable类型是非常危险的，仅应在非常确定类型安全的情况下使用</li>
<li> Item 26: Favor generic types</li>
<li> 当需要一个类成员的数据类型具备一般性时，应该用泛型，这也正是泛型的设计场景之一，不应该用Object类</li>
<li> 但使用泛型有时也不得不进行cast，例如当泛型遇上数组</li>
<li> 总的来说把suppress数组类型强转的unchecked warning比suppress一个标量类型强转的unchecked warning风险更大，但有时出于代码简洁性考虑，也不得不做出妥协</li>
<li> 有时看似与item 25矛盾，实属无奈，Java原生没有List，ArrayList不得不基于数组实现，HashMap也是基于数组实现的</li>
<li> 泛型比使用者进行cast更加安全，而且由于Java泛型的擦除实现，也可以和未做泛型的老代码无缝兼容</li>
<li> Item 27: Favor generic methods</li>
<li>泛型方法的类型参数在函数修饰符（可见性/static/final等）和返回值之间，例子：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Generic method</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">union</span><span class="params">(Set&lt;E&gt; s1, Set&lt;E&gt; s2)</span> </span>&#123;</span><br><span class="line">    Set&lt;E&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(s1);</span><br><span class="line">    result.addAll(s2);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>recursive type bound<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Using a recursive type bound to express mutual comparability</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function">T <span class="title">max</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li>
<li> 泛型方法要比方法使用者进行cast更加安全</li>
<li> Item 28: Use bounded wildcards to increase API flexibility</li>
<li>考虑以下代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushAll</span><span class="params">(Iterable&lt;E&gt; src)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popAll</span><span class="params">(Collection&lt;E&gt; dst)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stack&lt;Number&gt; numberStack = <span class="keyword">new</span> Stack&lt;Number&gt;();</span><br><span class="line">Iterable&lt;Integer&gt; integers = ... ;</span><br><span class="line">numberStack.pushAll(integers);</span><br><span class="line"></span><br><span class="line">Stack&lt;Number&gt; numberStack = <span class="keyword">new</span> Stack&lt;Number&gt;();</span><br><span class="line">Collection&lt;Object&gt; objects = ... ;</span><br><span class="line">numberStack.popAll(objects);</span><br></pre></td></tr></table></figure>
pushAll和popAll的调用均无法通过编译，因为尽管<code>Integer</code>是<code>Number</code>的子类，但<code>Iterable&lt;Integer&gt;</code>不是<code>Iterable&lt;Number&gt;</code>的子类，这是由泛型的invariant特性导致的，所以<code>Iterable&lt;Integer&gt;</code>不能传入接受<code>Iterable&lt;Number&gt;</code>参数的函数，popAll的使用同理</li>
<li> bounded wildcards: <code>&lt;? extends E&gt;</code>, <code>&lt;? super E&gt;</code>, PECS stands for producer-extends, consumer-super. 如果传入的参数是要输入给该类型数据的，则应该使用extends，如果是要容纳该类型数据的输出，则应该使用super</li>
<li> 这很好理解，作为输入是要赋值给E类型的，当然应该是E的子类（这里的extends包括E类型本身）；而容纳输出是要把E赋值给传入参数的，当然应该是E的父类（同样包括E本身）</li>
<li> 返回值类型不要使用bounded wildcards，否则使用者也需要使用，这将会给使用者造成麻烦</li>
<li> 代码对于bounded wildcards的使用在使用者那边应该是透明的，即他们不会感知到bounded wildcards的存在，如果他们也需要考虑bounded wildcards的问题，则说明对bounded wildcards的使用有问题了</li>
<li>有时候编译器的类型推导在遇到bounded wildcards会无法完成，这时就需要显示指定类型信息，例如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">union</span><span class="params">(Set&lt;? extends E&gt; s1, Set&lt;? extends E&gt; s2)</span></span>;</span><br><span class="line"></span><br><span class="line">Set&lt;Integer&gt; integers = ... ;</span><br><span class="line">Set&lt;Double&gt; doubles = ... ;</span><br><span class="line"><span class="comment">//Set&lt;Number&gt; numbers = union(integers, doubles); //compile error</span></span><br><span class="line">Set&lt;Number&gt; numbers = Union.&lt;Number&gt;union(integers, doubles);  <span class="comment">//compile pass</span></span><br></pre></td></tr></table></figure></li>
<li> Comparables are always consumers, so you should always use <code>Comparable&lt;? super T&gt;</code> in preference to <code>Comparable&lt;T&gt;</code>. The same is true of comparators, so you should always use <code>Comparator&lt;? super T&gt;</code> in preference to <code>Comparator&lt;T&gt;</code>.</li>
<li> unbounded type parameter(<code>&lt;E&gt; ... List&lt;E&gt;</code>) v.s. unbounded wildcard(<code>List&lt;?&gt;</code>)：if a type parameter appears only once in a method declaration, replace it with a wildcard.</li>
<li> Item 29: Consider typesafe heterogeneous containers</li>
<li> 使用泛型时，类型参数是有限个的，例如<code>List&lt;T&gt;</code>，<code>Map&lt;K, V&gt;</code>，但有时可能需要一个容器，能放入任意类型的对象，但需要具备类型安全性，例如数据库的一行，它的每一列都可能是任意类型的数据</li>
<li>由于<code>Class</code>类从1.5就被泛型化了，所以使得这种需求可以实现，例如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Typesafe heterogeneous container pattern - API</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Favorites</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getFavorite</span><span class="params">(Class&lt;T&gt; type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li> 通常这样使用的<code>Class</code>对象被称为type token，它传入函数，用来表述编译时和运行时的类型信息</li>
<li><code>Favorites</code>的实现也是很简单的：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Typesafe heterogeneous container pattern - implementation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Favorites</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Object&gt; favorites = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;Type is null&quot;</span>);</span><br><span class="line">        favorites.put(type, instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getFavorite</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type.cast(favorites.get(type));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li> 注意，这里的unbound wildcard并不是应用于Map的，而是应用于Class的类型参数，因此Map可以put key进去，而且key可以是任意类型参数的Class对象</li>
<li> 另外，Map的value类型是Object，一旦put到Map中去，其编译期类型信息就丢失了，将通过get方法的动态类型转换（cast）来重新获得其类型信息</li>
<li> cast方法将检查类型信息，如果是该类型（或其子类），转换将成功，并返回引用，否则将抛出ClassCastException</li>
<li>这一heterogeneous container实现有两个不足    +  通过为put方法传入Class的raw type，使用者可以很轻易地破坏类型安全性，解决方案也很简单，在put时也进行一下cast：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Achieving runtime type safety with a dynamic cast</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span> </span>&#123;</span><br><span class="line">    favorites.put(type, type.cast(instance));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这样做的效果是使得想要破坏类型安全性的put使用者产生异常，而使用get的使用者则不会因为恶意put使用者产生异常。这种做法也被<code>java.util.Collections</code>包中的一些方法使用，例如命名为checkedSet, checkedList, checkedMap的类。<pre><code>+  这个容器内不能放入non-reifiable的类型，例如`List&lt;String&gt;`，因为`List&lt;String&gt;.class`是有语法错误的，`List&lt;String&gt;`, `List&lt;Integer&gt;`都只有同一个class对象：`List.class`；另外`String[].class`是合法的。
</code></pre>
</li>
<li><code>Favorites</code>使用的类型参数是unbounded的，可以put任意类型，也可以使用bounded type token，使用bounded时可能需要把<code>Class&lt;?&gt;</code>转换为<code>Class&lt;? extends Annotation&gt;</code>，直接用<code>class.cast</code>将会导致unchecked warning，可以通过<code>class.asSubclass</code>来进行转换，例子：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use of asSubclass to safely cast to a bounded type token</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Annotation <span class="title">getAnnotation</span><span class="params">(AnnotatedElement element, String annotationTypeName)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; annotationType = <span class="keyword">null</span>; <span class="comment">// Unbounded type token</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        annotationType = Class.forName(annotationTypeName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> element.getAnnotation(annotationType.asSubclass(Annotation.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Enums-and-Annotations"><a href="#Enums-and-Annotations" class="headerlink" title="Enums and Annotations"></a>Enums and Annotations</h2><ul>
<li> Item 30: Use enums instead of int constants</li>
<li> 类型安全</li>
<li> 可以为常量提供数据和方法的绑定</li>
<li> 可以遍历</li>
<li>实现建议    +  如果是通用的，应该定义为top level enum，否则应定义为内部类    +  constant-specific method implementations<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Enum type with constant-specific method implementations</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    PLUS   &#123; <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x + y;&#125; &#125;,</span><br><span class="line">    MINUS  &#123; <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x - y;&#125; &#125;,</span><br><span class="line">    TIMES  &#123; <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x * y;&#125; &#125;,</span><br><span class="line">    DIVIDE &#123; <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x / y;&#125; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    +  结合constant-specific data
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Enum type with constant-specific class bodies and data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    PLUS(<span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS(<span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x - y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES(<span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE(<span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x / y; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String symbol;</span><br><span class="line">    Operation(String symbol) &#123; <span class="keyword">this</span>.symbol = symbol; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> symbol; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    +  If switch statements on enums are not a good choice for implementing con- stant-specific behavior on enums, what are they good for? Switches on enums are good for augmenting external enum types with constant-specific behavior.</li>
<li> A minor performance disadvantage of enums over int constants is that there is a space and time cost to load and initialize enum types.</li>
<li> 所以，在安卓设备（手机、平板）上，应该避免使用enum，减小空间和时间的开销</li>
<li> Item 31: Use instance fields instead of ordinals</li>
<li> 每个enum的常量都有一个<code>ordinal()</code>方法获取其在该enum类型中的位置，但该方法只应该在实现<code>EnumSet</code>, <code>EnumMap</code>等类型的时候被使用，其他情形都不应该被使用</li>
<li> 如果需要为每一个常量绑定一个数据，可以使用instance field实现，如果需要绑定方法，则可以用constant-specific method implementations，参考上一个item</li>
<li> Item 32: Use EnumSet instead of bit fields</li>
<li> bit fields的方式不优雅、容易出错、没有类型安全性</li>
<li> EnumSet则没有这些缺点，而且对于大多数enum类型来说，其性能都和bit field相当</li>
<li> 通用建议：声明变量时，不要用实现类型，应该用接口类型，例如，应该用<code>List&lt;Integer&gt;</code>而不是<code>ArrayList&lt;Integer&gt;</code></li>
<li> EnumSet并非immutable的，可以通过<code>Conllections.unmodifiableSet</code>来封装为immutable，但是代码简洁性与性能都将受到影响</li>
<li> Item 33: Use EnumMap instead of ordinal indexing</li>
<li> 同前文所述，应该避免使用ordinal。当需要用enum作为下标从数组获取数据时，可以换个角度思考，以enum作为key从map里面获取数据。</li>
<li> 数组和泛型不兼容，因此使用数组也会导致编译警告；而且ordinal的值本来就不是表达index含义的，极易导致隐蔽错误</li>
<li> EnumMap内部使用数组实现，因此性能和数组相当</li>
<li>使用数组也会导致程序可扩展性下降，考虑以下两种实现<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Using ordinal() to index array of arrays - DON&#x27;T DO THIS!</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Phase</span> </span>&#123;</span><br><span class="line">    SOLID, LIQUID, GAS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Transition</span> </span>&#123;</span><br><span class="line">      MELT, FREEZE, BOIL, CONDENSE, SUBLIME, DEPOSIT;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Rows indexed by src-ordinal, cols by dst-ordinal</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Transition[][] TRANSITIONS = &#123;</span><br><span class="line">              &#123; <span class="keyword">null</span>,    MELT,     SUBLIME &#125;,</span><br><span class="line">              &#123; FREEZE,  <span class="keyword">null</span>,     BOIL    &#125;,</span><br><span class="line">              &#123; DEPOSIT, CONDENSE, <span class="keyword">null</span>    &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Returns the phase transition from one phase to another</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Transition <span class="title">from</span><span class="params">(Phase src, Phase dst)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TRANSITIONS[src.ordinal()][dst.ordinal()];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Using a nested EnumMap to associate data with enum pairs</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Phase</span> </span>&#123;</span><br><span class="line">    SOLID, LIQUID, GAS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Transition</span> </span>&#123;</span><br><span class="line">        MELT(SOLID, LIQUID), FREEZE(LIQUID, SOLID),</span><br><span class="line">        BOIL(LIQUID, GAS),   CONDENSE(GAS, LIQUID),</span><br><span class="line">        SUBLIME(SOLID, GAS), DEPOSIT(GAS, SOLID);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Phase src;</span><br><span class="line">        <span class="keyword">final</span> Phase dst;</span><br><span class="line"></span><br><span class="line">        Transition(Phase src, Phase dst) &#123;</span><br><span class="line">            <span class="keyword">this</span>.src = src;</span><br><span class="line">            <span class="keyword">this</span>.dst = dst;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize the phase transition map</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Phase, Map&lt;Phase,Transition&gt;&gt; m =</span><br><span class="line">            <span class="keyword">new</span> EnumMap&lt;Phase, Map&lt;Phase,Transition&gt;&gt;(Phase.class);</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Phase p : Phase.values())</span><br><span class="line">                m.put(p,<span class="keyword">new</span> EnumMap&lt;Phase,Transition&gt;(Phase.class));</span><br><span class="line">            <span class="keyword">for</span> (Transition trans : Transition.values())</span><br><span class="line">                m.get(trans.src).put(trans.dst, trans);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Transition <span class="title">from</span><span class="params">(Phase src, Phase dst)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m.get(src).get(dst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当需要增加<code>Phase</code>时，前者需要谨慎地修改<code>TRANSITIONS</code>数组的内容（这一步骤容易出错），而后者则只需要增加相应<code>Transition</code>即可，<code>from</code>函数的逻辑完全不受影响。</li>
<li> Item 34: Emulate extensible enums with interfaces</li>
<li> 当enum遇到可扩展性时，总是一个糟糕的问题；扩展类是基础类的实例，但反过来不是，这一点很让人困惑；想要枚举所有基础类和扩展类的enum对象时，并没有一个很好地办法；</li>
<li> 而对于可扩展性的需求，是真实存在的，例如：operation codes (opcodes)</li>
<li> 实现方式是通过定义一个接口，enum类型（基础与扩展）均实现该接口，而在使用enum的地方，接收这个接口作为参数</li>
<li> enum类型是不可扩展的，但是interface具备可扩展性，如果API使用接口而非实现去代表operation，API就有了可扩展性</li>
<li> 泛型高级用法：<code>&lt;T extends Enum&lt;T&gt; &amp; Operation&gt; ... Class&lt;T&gt;</code>，T类型是enum类型，且是<code>Operation</code>子类</li>
<li> 这一方式的不足：enum类型对接口的实现是不能继承的</li>
<li> Item 35: Prefer annotations to naming patterns</li>
<li> 在1.5之前，naming patterns很常见，在JUnit中都是这样，例如要求测例方法一<code>test</code>开头</li>
<li> naming patterns有很多问题    +  拼写错误不能及时发现    +  无法保证naming patterns只在正确的场景使用，例如可能有人以<code>test</code>开头命名测例类，方法却没有，JUnit则不会运行测例    +  没有值/类型信息，编译器无法提前发现问题</li>
<li> 使用annotations可以很好的解决这些问题，但是annotations的功能也是有限的    +  <code>@Retention(RetentionPolicy.RUNTIME)</code>能限定其保留时期    +  <code>@Target(ElementType.METHOD)</code>能限定其应用的程序元素    +  还有其他meta-annotations，如<code>@IntDef</code></li>
<li> annotations接收的参数如果是数组，为其赋值一个单独的元素也是合法的</li>
<li> Item 36: Consistently use the Override annotation</li>
<li> <code>@Override</code>会使得重写的准确性得到检查</li>
<li> 重载和重写的区别：一个只是函数名一样，通过参数列表决定执行哪个版本，是编译时多态；一个是通过虚函数机制实现，是运行时多态；</li>
<li> Item 37: Use marker interfaces to define types</li>
<li> 定义一个空的接口，表明某个类型的属性，例如<code>Serializable</code></li>
<li> 另一种方式是使用annotation，表明者其具有某种属性</li>
<li> marker interface的优点    +  定义了一个类型，可以进行instanceof判断，可以声明参数类型    +  比annotation更简洁</li>
<li> marker annotation的优点    +  当一个类型（通过interface或者annotation）被声明后，如果想要加入更多的信息，annotation更方便，即annotation对修改是开放的，因为它的属性可以有默认值，而interface则不行，定义了方法就必须实现    +  annotation可以被应用到更多代码的元素中，不仅仅是类型</li>
<li> 实现建议    +  如果仅仅只应用于类型，则应该优先考虑annotation    +  如果希望mark的对象被限定于某个接口的实例（即为一个接口增加另外一种语义，却不改变其API），可以考虑使用marker interface</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li> Item 38: Check parameters for validity</li>
<li> 一个函数（包括构造函数）首先要做的事情就是验证参数合法性，如果不合法则应该抛出相应异常，这是对“尽早发现错误尽早抛出”原则的遵循，否则等到错误发生时将可能难以判断错误的根源所在，甚至程序不会显式报错，而是执行了错误的行为，导致更严重的后果</li>
<li> 不由被调用函数使用，而是存起来留作后用的参数，更加要检查其合法性</li>
<li> Javadoc里面应该注明<code>@throw</code>项，并说明原因</li>
<li> 非公开的API（private或package private），则不应该通过抛异常来报错，应该采用<code>assert</code>，assert可以通过配置虚拟机参数开启或关闭，如果关闭则不会被执行</li>
<li> 灵活运用，设计API时，就应该尽量设计得通用一些，即可以接受更大范围的参数，毕竟检查参数也是有开销的</li>
<li> 另外可以考虑抛出<code>RuntimeException</code>的子类，因为这样的异常不用放到函数的异常表中，函数的使用者也不用必须<code>try-catch</code>或者<code>throw</code>，但doc一定要写明</li>
<li> Item 39: Make defensive copies when needed</li>
<li> 编码一大原则：永远不要信任用户（调用方）输入的数据，也不要信任它们不会篡改返回的数据，因此defensive copy很有必要</li>
<li> 编写一个类时，如果成员变量是mutable的，那么就需要在构造函数（或者setter）中进行深拷贝，并且，先拷贝，再验证已拷贝数据的合法性（既不是先验证，也不是验证传入的数据，避免TOCTOU attack）</li>
<li> 另外深拷贝时，传入对象的类如果不是final的，就不能用clone方法进行拷贝，因为不能保证clone方法返回的就正好是这个类的实例（有可能会是恶意的子类）</li>
<li> 为mutable成员提供getter方法时，返回前也要进行深拷贝，但此时可以用clone方法，因为我们确定成员就是我们想要的类的对象</li>
<li> java内建的Map, Set等容器，实现上是没有进行深拷贝的，因为是泛型，所以put进去或者get出来的时候，编译期都不知道具体是什么类型，是无法调用构造函数的，如果想要测试这一问题，需要确定key和value的类型都是mutable的，如果测<code>Map&lt;String, Integer&gt;</code>，那结果肯定是错误的，但如果测<code>Map&lt;StringBuilder, Date&gt;</code>，就可以知道确实如此；所以如果要把用户传入的数据放入Map，且key/value是mutable的，那么就需要在put之前进行深拷贝，否则可能会被用户attack</li>
<li> 长度非零的数组都是mutable的</li>
<li> 尽量使用immutable的成员就可以省去深拷贝带来的性能开销</li>
<li> 如果确实信任用户，就可以把深拷贝省去，但一定要在文档内说明，例如：wrapper模式，如果用户恶意，那损害的也就仅仅是其自身；或者用户都是自己的代码，可以确信安全。</li>
<li> Item 40: Design method signatures carefully</li>
<li> 命名要合理，可理解：清除表达函数的功能；符合常识；保持风格一致；</li>
<li> 类/接口的成员方法数量不要太多，否则会令人难以理解，而且不利于测试、维护</li>
<li> 不要随便提供helper方法，只有当很有必要时才提供</li>
<li> 避免过长参数列表（不多于4个），尤其是参数类型相同，否则既难记（倒还好），又可能引起隐晦的bug（传入参数顺序错了，编译不报错，运行时行为确是错的）    +  可以通过把参数列表过长的方法拆分为几个方法，但要避免导致方法过多    +  创建helper类，容纳作用相关联的的参数    +  类似于构造对象的Builder模式，为函数的调用创建一个builder</li>
<li> 参数类型，使用interface，而不是实现类</li>
<li> 对于起控制作用的参数，使用二值enum，而不是boolean，便于扩展；对于安卓来说，可以通过<code>@IntDef</code>辅助定义int常量，模拟enum</li>
<li> Item 41: Use overloading judiciously</li>
<li> 慎用重载，重载（overload）与重写（override）的区别可以见上文，简言之，前者编译时多态，后者运行时多态</li>
<li> 重载是编译时多态，版本选择在编译期完成，根据编译期参数的类型信息来进行决策</li>
<li> 建议不要用参数类型来设计不同的重载版本，应该通过参数列表长度，或者没有父子类关系的不同参数类型，例如接受int和float的类型，后者也还是可能会有问题</li>
<li> Item 42: Use varargs judiciously</li>
<li> varargs的原理是调用时首先创建一个数组，然后把传入的参数放入数组，数组长度为参数个数</li>
<li> 一个方法需要0或多个同类型数据这个需求很常见，然而也有另一个很常见的需求：需要一个或多个同类型数据，此时单纯用varargs不太优雅，可以让方法先接受一个数据，在接受一个varargs</li>
<li> varargs最初是为了printf和反射设计的</li>
<li> 可以通过把传入参数从一个数组改为varargs，来改良该方法（变得更灵活），而且对已有代码“无影响”，<code>Arrays.asList</code>便是一个例子，但接受varargs最初是为了打印数组内容设计的，而不是为了把多个数据变成一个List</li>
<li> Don’t retrofit every method that has a final array parameter; use varargs only when a call really operates on a variable-length sequence of values.</li>
<li> 以下两种函数声明都可能会产生问题：</li>
</ul>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ReturnType1 <span class="title">suspect1</span><span class="params">(Object... args)</span> </span>&#123; &#125;</span><br><span class="line">&lt;T&gt; <span class="function">ReturnType2 <span class="title">suspect2</span><span class="params">(T... args)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

 如果传入一个基本类型的数组进去（例如int[]），那么这两个方法接受的都是一个int[][]，即相当于接受了一个只有一个元素的数组，而这个数组的数据类型是int[]！而如果传入一个对象的数组，则相当于传入了数组长度个数的varargs。`Arrays.asList`方法就存在这个问题！
</code></pre>
<ul>
<li> varargs也存在性能影响，因为每次调用都会创建、初始化一个数组。如果为了不失API灵活性，同时大部分调用的参数个数都是有限个，例如0<del>3个，那么可以声明5个重载版本，分别接受0</del>3个参数，另外加一个3个参数+varargs的版本</li>
<li> Item 43: Return empty arrays or collections, not nulls</li>
<li> 可能有人认为返回null能减小内存开销，然：    +  永远不要过度考虑性能问题，只有当profiling显示瓶颈就是这里的时候，再考虑性能优化与代码优雅性的牺牲，当然，无副作用的优化肯定尽早采纳    +  可以每次需要返回空数组/集合时，返回同一个空数组/集合，这样就只需要一次内存分配</li>
<li> Collection的<code>&lt;T&gt; T[] toArray(T[] a)</code>方法，可以每次调用时传入一个空数组，因为该方法保证如果集合元素可以被放入提供的参数数组中，将不会分配新内存，当放不下时才会分配</li>
<li> 下面实现返回集合的值的方式也是值得借鉴的</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The right way to return a copy of a collection</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Cheese&gt; <span class="title">getCheeseList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cheesesInStock.isEmpty())</span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList(); <span class="comment">// Always returns same list</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Cheese&gt;(cheesesInStock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Item 44: Write doc comments for all exposed API elements    +  对于API暴露的部分（类、接口、方法、成员等），都应该先写好文档；为了提高代码的可维护性，未暴露的部分也应该写好文档；    +  每个方法的文档的内容，应该是描述该方法与调用者之间的约定，不必是实现细节，细节可以看代码，约定则是使用者关心的东西；设计为被继承的类，方法文档应该描述该方法做了什么，而不是怎么做的；    +  方法的文档中，应该描述约定的前提条件，执行后产生的影响，尤其是对于“系统”（或者说这个对象）状态的影响；不符合前提条件的情形将抛出异常；    +  更多细节<ul>
<li> <code>@param</code>, <code>@return</code>, <code>@throws</code> 描述不要句号结尾</li>
<li> <code>@throws</code> 的描述应该以if开头，其他都应该是名词描述</li>
<li> <code>@&#123;code&#125;</code>与<code>@&#123;literal&#125;</code></li>
<li> 有泛型时，需要说明每个类型参数</li>
<li> enum类型要为每个常量注释含义</li>
<li> annotation的定义，要为每个成员/参数注释含义</li>
<li> 线程安全性说明，可见性说明，序列化说明</li>
</ul>
</li>
</ul>
<h2 id="编程通用"><a href="#编程通用" class="headerlink" title="编程通用"></a>编程通用</h2><ul>
<li> Item 45: Minimize the scope of local variables</li>
<li> 在变量第一次使用的时候进行声明，声明时尽量就进行初始化</li>
<li> 因此也更倾向于使用for-loop，而不是while-loop，因为后者需要使用while-loop外定义的控制变量</li>
<li> for-loop的终结条件变量n，也应该在循环变量i初始化时计算，避免重复计算</li>
<li> 保持方法简短，一个方法只做一件事</li>
<li> Item 46: Prefer for-each loops to traditional for loops</li>
<li>优点之一：可以避免一些容易犯的bug<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Can you spot the bug?</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Suit</span> </span>&#123; CLUB, DIAMOND, HEART, SPADE &#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Rank</span> </span>&#123; ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT,</span><br><span class="line">            NINE, TEN, JACK, QUEEN, KING &#125;</span><br><span class="line">...</span><br><span class="line">Collection&lt;Suit&gt; suits = Arrays.asList(Suit.values());</span><br><span class="line">Collection&lt;Rank&gt; ranks = Arrays.asList(Rank.values());</span><br><span class="line">List&lt;Card&gt; deck = <span class="keyword">new</span> ArrayList&lt;Card&gt;();</span><br><span class="line"><span class="keyword">for</span> (Iterator&lt;Suit&gt; i = suits.iterator(); i.hasNext(); )</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;Rank&gt; j = ranks.iterator(); j.hasNext(); )</span><br><span class="line">        deck.add(<span class="keyword">new</span> Card(i.next(), j.next()));</span><br></pre></td></tr></table></figure></li>
</ul>
<pre><code>`i.next()`在内层循环被调用了多次。以下写法则直观且不易出错：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Preferred idiom for nested iteration on collections and arrays</span></span><br><span class="line"><span class="keyword">for</span> (Suit suit : suits)</span><br><span class="line">    <span class="keyword">for</span> (Rank rank : ranks)</span><br><span class="line">        deck.add(<span class="keyword">new</span> Card(suit, rank));</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li> 此种写法不仅可用于集合和数组，任何实现<code>Iterable</code>接口的类都可以用于冒号后面的部分</li>
<li> 缺点    +  有性能代价！一定会创建Iterator，对于安卓开发，不建议如此。    +  不能在for-each语法中进行remove，用Iterator遍历时，能remove    +  遍历过程中替换原有元素    +  Parallel iteration</li>
<li> Item 47: Know and use the libraries</li>
<li> don’t reinvent the wheel</li>
<li> 视野！</li>
<li> Item 48: Avoid float and double if exact answers are required</li>
<li> float和double设计为用于科学计算，“精确近似”，需要确切结果的，不要使用，例如：货币相关！应该使用BigDecimal, int, 或者long。</li>
<li> BigDecimal使用有些不方便，性能也比primitive类型低</li>
<li> Item 49: Prefer primitive types to boxed primitives</li>
<li> 两种类型的区别    +  boxed类型，除了包含数值外，还有不同的唯一标示，即值一样，对象可以不一样，这一点很重要！    +  boxed类型，比primitive类型多一个值，null    +  boxed类型，时间、空间效率均低一些</li>
<li> caveats    +  有些操作会auto-unbox，例如：加减乘除，大小比较，但判等（<code>==</code>）不会！    +  Applying the <code>==</code> operator to boxed primitives is almost always wrong.    +  boxed类型，值为null时，会unbox为什么呢？会抛出<code>NullPointerException</code>    +  当boxed和primitive出现在同一个运算中，boxed类型会auto-unbox（包括判等）    +  大量重复的box/unbox会导致性能大幅下降</li>
<li> 使用场景与注意事项    +  放到标准集合里面，必须是boxed类型    +  作为类型参数（泛型），必须是boxed类型    +  auto-box是安全的，也能省去繁琐的代码，但是auto-unbox则可能引起隐蔽的错误</li>
<li> Item 50: Avoid strings where other types are more appropriate</li>
<li> Strings are poor substitutes for other value types. 只有当数据确实就是文本时，才适合用String。</li>
<li> Strings are poor substitutes for enum types.</li>
<li> Strings are poor substitutes for aggregate types. 把一系列数据转化为一个String（序列化），然后再反序列化，也应该用Json，如果自定义分隔符，既不优雅，也不安全。</li>
<li> Strings are poor substitutes for capabilities. capability是一种称呼，通常就是说不同的对象，凭借一个key去同一个地方保存、获取数据；如果用String，那么如果内容相同，那key就会冲突，不安全；ThreadLocal的发展史*。</li>
<li> Item 51: Beware the performance of string concatenation</li>
<li> 用<code>+</code>连接n个String，时间复杂度为<code>O(n^2)</code>，因为String是immutable的，所以每次拼接都会拷贝两者的内容</li>
<li> 使用<code>StringBuilder</code>进行拼接操作；不过对于安卓开发来说，基本没什么影响，因为在打包的过程中，这一优化会自动完成；</li>
<li> Item 52: Refer to objects by their interfaces</li>
<li> 如果有接口，那么函数参数、返回值、成员变量、局部变量，都应该使用接口来保持对象的引用，只有在通过构造函数创建对象时才应该引用具体的实现类型；面向接口编程更广义的实践；</li>
<li> 面向接口编程使得程序更加灵活，切换实现类非常简单；但如果代码功能/正确性依赖于实现类特有的特性，那么切换时就需要仔细考虑一下；</li>
<li> 当然，如果对应功能的接口不存在，那直接引用该类当然是可以的；value type; class-based framework; 或者实现类提供了接口不存在的功能</li>
<li> Item 53: Prefer interfaces to reflection</li>
<li> 反射可以访问私有成员</li>
<li> 反射可以调用编译时不存在的类的方法，当然需要运行时已经加载</li>
<li> 但是反射也是有代价的    +  编译期的类型检查完全失效，类型安全性丧失    +  反射代码繁琐且易出错，当然这一点有一些好的框架可以避免，例如<a href="https://github.com/jOOQ/jOOR">JOOR</a>    +  性能下降，反射调用性能会低很多</li>
<li> 反射常用的场景    +  class browsers, object inspectors, code analysis tools, and interpretive embedded systems, remote procedure call (RPC) systems    +  反射功能强大，也有一些不足，如果合适利用，还是非常方便的    +  例如编译期有些类尚未获得，但是如果有其父类/接口，则可以声明为父类/接口，只通过反射创建实例，其余代码都无需反射</li>
<li> Item 54: Use native methods judiciously</li>
<li> 设计之初的三大用途    +  访问平台相关的功能，例如registries and file locks    +  访问老的C/C++版本的库，访问老的数据    +  追求性能</li>
<li> 近年来JVM/Java的发展，性能已有很大改善，追求性能而使用JNI通常来说都已经没必要了</li>
<li> JNI的劣势    +  不安全，内存管理不受JVM控制了，溢出等问题都有可能发生了    +  平台相关    +  难以调试    +  Java和native层的交互是有开销的    +  native代码比Java代码更难懂</li>
<li> 对于安卓应用开发来说，JNI还有一点就是隐藏实现，Java代码反编译非常容易，而native代码则难一些</li>
<li> Item 55: Optimize judiciously</li>
<li> 只有当确实需要时，才考虑性能优化，当然一些常见的范式，初次编码时就应该遵循</li>
<li> Strive to write good programs rather than fast ones; speed will follow.</li>
<li> Strive to avoid design decisions that limit performance.</li>
<li> Consider the performance consequences of your API design decisions.</li>
<li> It is a very bad idea to warp an API to achieve good performance.</li>
<li> 当确实需要优化性能时：measure performance before and after each attempted optimization.</li>
<li> 找到原因后，首先考虑的是算法的优化，然后是上层的优化</li>
<li> 在进行优化前，对程序进行profiling，确定瓶颈，否则可能浪费精力反而性能下降</li>
<li> Item 56: Adhere to generally accepted naming conventions</li>
<li> 包名要体现出组件的层次结构，全小写</li>
<li> 公布到外部的，包名以公司/组织的域名开头，例如：edu.cmu, com.sun</li>
<li> …</li>
</ul>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul>
<li> Item 57: Use exceptions only for exceptional conditions</li>
<li> exceptions are, as their name implies, to be used only for exceptional conditions; they should never be used for ordinary control flow.</li>
<li> A well-designed API must not force its clients to use exceptions for ordinary control flow.    +  如果一个类的某个方法，依赖于该类当前处于某个特定状态，则应该提供一个单独的状态检查方法，例如Iterator的next和hasNext方法    +  另外如果不提供状态检查方法，也可以让方法在异常状态下，返回一个特定的非法值    +  如果该类被并发访问，且访问时未进行互斥处理，则必须使用返回非法值的方式；另外考虑到性能因素，也更倾向于返回非法值；其他情况下，都应该使用状态检查方法，可读性更好，更容易检查错误；</li>
<li> Item 58: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors</li>
<li> use checked exceptions for conditions from which the caller can reasonably be expected to recover.</li>
<li> unchecked exception: <code>RuntimeException</code>, <code>Error</code>通常都不需要、也不应该catch</li>
<li> Use runtime exceptions to indicate programming errors. 通常用于表示程序运行的状态违背了前提条件，违背了API的约定</li>
<li> all of the unchecked throwables you implement should subclass RuntimeException</li>
<li> Item 59: Avoid unnecessary use of checked exceptions</li>
<li> 如果即便合理的调用了API也会遇到异常情形，并且捕获异常之后能够进行一些有意义的操作，才应该使用checked exception，其他情况下都应该使用RuntimeException</li>
<li> 通常，如果一个方法会抛出checked exception，都可以将其拆分为两个方法，一个用于判断是否会抛出异常，另一部分用于处理正常情况，如果不符合约定，就抛出RuntimeException，这样使得API更易用，也更灵活；但是要考虑状态检查和执行之间，是否可能从外部其他线程修改对象的状态；</li>
<li>Item 60: Favor the use of standard exceptions</li>
<li> IllegalArgumentException, IllegalStateException, NullPointerException, IndexOutOfBoundsException, ConcurrentModificationException, UnsupportedOperationException</li>
<li> Item 61: Throw exceptions appropriate to the abstraction</li>
<li> exception translation: higher layers should catch lower-level exceptions and, in their place, throw exceptions that can be explained in terms of the higher-level abstraction.</li>
</ul>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Exception Translation</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Use lower-level abstraction to do our bidding</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span>(LowerLevelException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HigherLevelException(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li> While exception translation is superior to mindless propagation of excep- tions from lower layers, it should not be overused.</li>
<li> Item 62: Document all exceptions thrown by each method</li>
<li> Always declare checked exceptions individually, and document precisely the conditions under which each one is thrown using the Javadoc @throws tag. 不要通过声明抛出多个异常的父类来实现抛出多种异常的效果。</li>
<li> 要为每个方法可能抛出的unchecked exception写文档，但是不要将这些异常放到方法声明的异常表中去。便于API使用者区分checked和unchecked exception。</li>
<li> 如果一个类的很多方法都抛出同一个异常，那么可以将文档放到class doc中，而不是method doc中。</li>
<li> Item 63: Include failure-capture information in detail messages</li>
<li> To capture the failure, the detail message of an exception should contain the values of all parameters and fields that “contributed to the exception.”</li>
<li> 良好设计的Exception类，应该把它需要的详细信息都作为构造函数的参数，而不是统一接收String参数；这样将把生成有意义的detail信息的任务集中在了Exception类本身，而不是其使用者。</li>
<li> checked exception可以为failure-capture information提供访问方法，以便于使用者在程序上进行恢复处理；虽然unchecked exception通常不会在程序中进行恢复，但是提供同样的方法也是建议的做法。</li>
<li> Item 64: Strive for failure atomicity</li>
<li> Generally speaking, a failed method invocation should leave the object in the state that it was in prior to the invocation. 满足此属性的方法称为 failure atomic。    +  immutable对象是最简单的实现方法    +  mutable对象要达到此效果，就需要在进行操作前，对所有的参数、field进行检查    +  有可能无法在函数的第一部分进行检查，但是一定要在对对象进行修改之前进行检查    +  还有一种不太常见的方式：函数内部捕获异常，异常发生之后先回退对象的状态，再把异常抛出去    +  还可以先创建一个临时的对象，在临时对象上进行操作，成功后替换原对象的值</li>
<li> 有的情况下，failure atomic是不可能的，所以也就没必要为此做出努力了</li>
<li> 有的情况下，为了failure atomic，会增加很多额外的开销、复杂度，也就不太必要了</li>
<li> 当方法不满足failure atomic时，需要在文档中进行说明</li>
<li> Item 65: Don’t ignore exceptions</li>
<li> An empty catch block defeats the purpose of exceptions</li>
<li> At the very least, the catch block should contain a comment explaining why it is appropriate to ignore the exception.</li>
<li> 忽略异常，可能导致程序在其他不相关的地方失败/崩溃，这时将很难找到/解决根本问题</li>
</ul>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ul>
<li> Item 66: Synchronize access to shared mutable data</li>
<li> <code>synchronized</code>不仅是为了保证每个线程访问/执行时，看到的都是“正常状态”的对象（所谓正常就是没有发生多线程同时未加同步的写同一个对象，导致其状态不一致）；还能保证每个线程看到的都是最新的对象；</li>
<li> Java语言保证了基本类型中除了long和double的访问都是原子性的，并发写这些类型的数据而不进行同步控制，也不会有问题</li>
<li> 有人建议访问具有原子性操作属性的对象无需进行同步控制，还能提升性能，纯属一派胡言</li>
<li> Java语言不会保证并发访问时，其他线程写的值能立即被读的线程感知，所以同步操作不仅仅是为了互斥访问，也是为了保证多线程之间看到的始终是最新的值</li>
<li> 上述问题的根本原因就是<a href="Android-Java/JSR133.md">Java memory model</a></li>
<li>一个简单、常见、易错的例子    +  如何停止后台线程？首先不能调用<code>Thread.stop</code>方法，这个方法会导致data corruption    +  常用的方法就是用一个<code>boolean</code>变量，后台线程根据其值决定是否停止，而主线程想要停止后台线程时，修改这个变量的值即可    +  <code>boolean</code>的读写操作是原子性的，并发访问不加同步，不会导致data corruption，但是却无法保证主线程对变量的修改能及时被后台线程感知，甚至无法保证能被感知    +  指令重排，如果<code>done</code>就是个普通声明的<code>boolean</code>，以下变换在Java memory model下是允许的<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!done)</span><br><span class="line">  i++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//==&gt;</span></span><br><span class="line"><span class="keyword">if</span> (!done)</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">    i++;</span><br></pre></td></tr></table></figure>    +  可想而知，如果未进行同步操作，后台线程将永远不会停止    +  解决方法有两种
</code></pre>
<ul>
<li> 为<code>done</code>的读写访问都加上<code>synchronized</code>，注意，读写都需要，否则没有数据同步（communication）的效果；由于<code>boolean</code>的读写访问是原子性的，所以这里的<code>synchronized</code>仅仅起数据同步的作用；</li>
<li> 声明<code>done</code>的时候加上<code>volatile</code>关键字，<code>volatile</code>没有互斥的作用，仅仅是起数据同步的作用，在这里正好满足需求；这种方式性能比上一种要好一些；</li>
</ul>
</li>
<li> 使用<code>volatile</code>需要格外谨慎，因为它并没有互斥作用，如果声明一个<code>volatile int</code>，然后对其进行<code>++</code>操作，那将会导致data corruption，因为<code>++</code>不是原子性的</li>
<li> 对于这种需求，可以声明为<code>synchronized int</code>；更好的方式是使用<code>java.util.concurrent.atomic</code>包下的类，安全，高效；</li>
<li> 更根本的解决方式就是不要多线程共享mutable对象，而是共享immutable对象；甚至不要多线程共享数据；</li>
<li> 引入框架/库时，需要考虑一下它们是否会引入多线程问题</li>
<li> effectively immutable：对象不是真的immutable，但是对象分享出去之后，就不会再改变了；当然这个还是很危险的，因为并没有强制的机制保证不会被修改；</li>
<li> 小结：多线程访问共享变量时，读和写都需要进行同步操作</li>
<li> Item 67: Avoid excessive synchronization</li>
<li> 在同步代码块中，不要调用可能被重写的方法，更不要调用使用者传入对象的方法，因为这些代码是不可控的，可能导致异常、死锁、data corruption</li>
<li> 对于Observer模式中的observer list，Java 1.5之后有一个单独优化的高效并发容器：<code>CopyOnWriteArrayList</code>，每次写（添加、删除）操作都会从内部的数组创建一份新的拷贝，读（遍历）操作时完全不用加锁，对于读多写少的场景性能很好</li>
<li> 一个总的原则是，在同步代码块中，执行尽可能少的操作；如果有耗时操作，应该在保证安全的前提下，尝试各种手段，将其移出同步块；</li>
<li> 过度同步的性能影响    +  丧失了多核CPU的并行性，获得锁的开销倒是其次    +  任何时刻都需要保证每个CPU核心之间的数据同步，这有不小的开销    +  限制了JVM的代码优化空间</li>
<li> 共享数据的并发访问，一定要保证线程安全；如果可以在类内部，通过少量/高效的同步块保证，就不要把整个类的任何操作都加锁；如果做不到，那就不要进行任何同步，把这个责任交给使用者，给他们优化的空间，但一定要在文档中说明；</li>
<li> 如果<code>static</code>成员可以被某些方法修改，那一定要为它们加锁，因为这种情况下使用者无法保证线程安全性</li>
<li> Item 68: Prefer executors and tasks to threads</li>
<li> Executor Framework</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">executor.execute(runnable);</span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>
<ul>
<li> <code>Executors</code>提供了多个工厂方法，创建<code>ExecutorService</code>，还可以直接使用<code>ThreadPoolExecutor</code>，对线程池做更精细的控制</li>
<li> 如果程序负载轻，可以使用<code>Executors.newCachedThreadPool</code>，任务提交时如果没有空闲线程，将创建新的线程；如果负载重，用<code>Executors.newFixedThreadPool</code>更合适；</li>
<li> 不仅不应该自己实现任务队列，甚至都应该避免直接使用线程，而是使用Executor Framework；</li>
<li> 任务和机制被分别抽象了，前者为<code>Runnable</code>和<code>Callable</code>，后者则是executor service；</li>
<li> <code>java.util.Timer</code>也尽量不要用了，可以使用<code>ScheduledThreadPoolExecutor</code>；</li>
<li> Item 69: Prefer concurrency utilities to wait and notify</li>
<li> 正确使用<code>wait</code>和<code>notify</code>有难度，而Java又提供了更高层的抽象，何乐而不用呢？</li>
<li> <code>java.util.concurrent</code>包主要包含三块：    +  Executor Framework    +  concurrent collections    +  synchronizers</li>
<li> concurrent collections提供了标准容器的多线程高性能版本，它们内部进行了同步互斥操作，保证正确性；外部使用的时候，无需加锁，否则只会导致性能下降；    +  concurrent collections中的每一种实现，可能都有性能优化的侧重点，可能有的是多读少写高效，例如<code>CopyOnWriteArrayList</code>，所以使用时需要了解清楚其试用场景；    +  除非有明确的理由，否则，优先使用<code>ConcurrentHashMap</code>，而不是<code>Collections.synchronizedMap</code>或者<code>Hashtable</code>；也尽量避免在使用者那端进行同步操作；    +  有的concurrent collections提供了block操作接口，例如<code>BlockingQueue</code>，从中取数据的时候，如果队列为空，线程将等待，新的数据加入后，将自动唤醒等待的线程；大部分的<code>ExecutorService</code>都是采用这种方式实现的；</li>
<li> Synchronizers: <code>CountDownLatch</code>, <code>Semaphore</code>, <code>CyclicBarrier</code>, <code>Exchanger</code>    +  <code>CountDownLatch</code>: 多个线程等待另外一个或多个线程完成某种工作    +  注意thread starvation deadlock问题    +  <code>Thread.currentThread().interrupt()</code> idiom：异常可能从其他线程抛出？用此方法回到原来的线程？    +  计时的话，用<code>System.nanoTime()</code>而不是<code>System.currentTimeMillis()</code>，前者更准确，更明确</li>
<li> 如果非要用<code>wait</code>和<code>notify</code>，注意以下几点：    +  Always use the wait loop idiom to invoke the wait method; never invoke it outside of a loop.    +  wait前的条件检查可以保证不会死锁，wait后的检查可以保证安全    +  通常情况下都应该使用<code>notifyAll</code></li>
<li> Item 70: Document thread safety</li>
<li> 一个方法的声明中加了<code>synchronized</code>并不能保证它是线程安全的，并且Javadoc也不会把这个关键字输出到文档中</li>
<li> 线程安全也分好几个层次，文档中应该说明类/方法做到了何种程度上的线程安全</li>
<li> 线程安全的分类    +  immutable，对象创建后不可修改，无需进行外部的同步操作（互斥访问控制或许更恰当）；例如：<code>String</code>, <code>Long</code>, <code>BigInteger</code>；    +  unconditionally thread-safe，对象可变，但是其内部进行了正确的同步操作，无需外部进行同步；例如：<code>ConcurrentHashMap</code>；    +  conditionally thread-safe，和绝对线程安全类似，但是有些方法需要进行外部的同步操作；例如：<code>Collections.synchronized</code>返回的容器，它们的iterator使用时需要进行同步；    +  not thread-safe，类自身没有任何同步操作，需要使用者自己保证线程安全；例如：<code>ArrayList</code>；    +  thread-hostile，由于类的实现原因，使用者无论如何也无法保证线程安全，例如未加同步的修改static成员；例如：<code>System.runFinalizersOnExit</code>；</li>
<li> jsr-305引入了几个注解：<code>Immutable</code>, <code>ThreadSafe</code>, <code>NotThreadSafe</code>，对应上述前四种情形，绝对线程安全与条件线程安全都属<code>ThreadSafe</code>，对于条件线程安全还应在文档中说明何种情况下是需要外部进行同步的；</li>
<li> 如果一个类，将它用于<code>synchronized</code>的对象暴露出去了，那是很危险的，通常的做法是，内部创建一个<code>Object</code>实例，将其用于<code>synchronized</code>，但这种方式通常只适用于unconditionally thread-safe的实现。</li>
</ul>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Private lock object idiom - thwarts denial-of-service attack</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li> Item 71: Use lazy initialization judiciously</li>
<li> don’t do it unless you need to</li>
<li> 如果使用lazy initialization，那这个成员的访问方法要用<code>synchronized</code>修饰</li>
<li> 静态成员实现lazy initialization且希望高性能，使用lazy initialization holder class idiom，例如：</li>
</ul>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lazy initialization holder class idiom for static fields</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldHolder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> FieldType field = computeFieldValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> FieldType <span class="title">getField</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> FieldHolder.field; &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li> 实例成员要实现lazy initialization且希望高性能，使用double-check idiom，但是注意，double-check并非严格意义的线程安全，例如：</li>
</ul>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Double-check idiom for lazy initialization of instance fields</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field;</span><br><span class="line"><span class="function">FieldType <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  FieldType result = field;</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;  <span class="comment">// First check (no locking)</span></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">      result = field;</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>)  <span class="comment">// Second check (with locking)</span></span><br><span class="line">        field = result = computeFieldValue();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

`result`这个局部变量的作用是，通常情况下，`field`已经初始化过了，这时将只会对其产生一次读操作，性能会有所提升
</code></pre>
<ul>
<li> double-check idiom还有两个变体，各有其使用场景：single-check idiom，racy single-check idiom；前者忍受多次赋值，后者忍受多次赋值且field的操作具有原子性（primitive类型且不是long和double）；</li>
<li> Item 72: Don’t depend on the thread scheduler</li>
<li> 依赖线程调度器的正确性、性能的程序，很可能是无法移植的</li>
<li> 好的多线程程序，同时运行的线程数不应该多于CPU内核数</li>
<li> 线程无法进行有意义的工作时，就不应继续运行，忙等是不好的实现方式</li>
<li> 另外一个线程（task）的工作也不能太少，否则线程切换的开销都会大于线程执行的时间，此时性能可想而知很低</li>
<li> <code>Thread.yield</code> has no testable semantics. 所以不要用<code>Thread.yield</code>，当程序的有些线程因为线程过多而无法获得CPU时间时，应该减少线程数。</li>
<li> 线程优先级是Java平台中移植性最差的部分，所以也不要用</li>
<li>Item 73: Avoid thread groups</li>
<li> 如果设计的类需要处理一些逻辑上有关联的线程，应该考虑 thread pool executors</li>
</ul>
<h2 id="Serialization"><a href="#Serialization" class="headerlink" title="Serialization"></a>Serialization</h2><ul>
<li> Item 74: Implement Serializable judiciously</li>
<li> 实现<code>Serializable</code>接口之后，一旦类发布出去，就不能随意更改实现方式了，否则序列化-反序列化时可能失败，这降低了灵活性</li>
<li> 序列化-反序列化的格式也是暴露的API之一，而默认的格式是和内部具体实现细节绑定的，所以默认格式把内部实现细节也暴露出去了</li>
<li> 自定义序列化-反序列化格式（<code>ObjectOutputStream.putFields</code>, <code>ObjectInputStream.readFields</code>），可以缓解上述问题，但是这又带来了新的实现复杂度</li>
<li> <code>serialVersionUID</code>问题</li>
<li> 会增加bug、安全漏洞的可能性，因为反序列化得到的对象，其状态是无法保证的</li>
<li> 会增加发布新版时的测试工作</li>
<li> 被设计于用来被继承的类，谨慎实现<code>Serializable</code>接口，同样，设计的接口也谨慎继承<code>Serializable</code>接口</li>
<li> 内部类不应该实现<code>Serializable</code>接口</li>
<li> Item 75: Consider using a custom serialized form</li>
<li> Do not accept the default serialized form without first considering whether it is appropriate.</li>
<li> The default serialized form is likely to be appropriate if an object’s physical representation is identical to its logical content.</li>
<li> Even if you decide that the default serialized form is appropriate, you often must provide a readObject method to ensure invariants and security.</li>
<li> Regardless of what serialized form you choose, declare an explicit serial version UID in every serializable class you write.</li>
<li> Item 76: Write <code>readObject</code> methods defensively</li>
<li> <code>readObject</code>方法的功效和public的构造函数一样</li>
<li> 反序列化的时候，<code>readObject</code>如果不进行深拷贝、以及数据合法性验证，就会导致生成的对象数据非法，同时，也有可能获得反序列化后对象内部成员的引用（rogue object reference attacks）</li>
<li> 不要使用<code>writeUnshared</code>和<code>readUnshared</code>方法，它们并不安全</li>
<li> 前文应该提到过，非final类，构造函数以及<code>readObject</code>方法中，不能调用可重载的方法</li>
<li> Item 77: For instance control, prefer enum types to readResolve</li>
<li> if you depend on readResolve for instance control, all instance fields with object reference types must be declared transient. 否则可能会无法达到实例控制的目的。</li>
<li> The accessibility of readResolve is significant.    +  final类，应该置为private</li>
<li> Item 78: Consider serialization proxies instead of serialized instances</li>
<li> 为需要实现<code>Serializable</code>的类添加一个内部类，它的构造函数接收外部类的实例，并将其field拷贝到自身的field，并且实现<code>readResolve</code>方法，创建外部类实例，创建方法可以是构造函数、static factory函数，在其中就可以进行实例控制了</li>
</ul>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Serialization proxy for Period class</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationProxy</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Date start;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Date end;</span><br><span class="line"></span><br><span class="line">  SerializationProxy(Period p) &#123;</span><br><span class="line">    <span class="keyword">this</span>.start = p.start;</span><br><span class="line">    <span class="keyword">this</span>.end = p.end;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// readResolve method for Period.SerializationProxy</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Period(start, end);  <span class="comment">// Uses public constructor</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">234098243823485285L</span>; <span class="comment">// Any number will do (Item 75)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li> 外部类实现一个<code>writeReplace</code>方法</li>
</ul>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// writeReplace method for the serialization proxy pattern</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">writeReplace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SerializationProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li> 外部类实现<code>readObject</code>方法，并在其中抛出异常</li>
</ul>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// readObject method for the serialization proxy pattern</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream stream)</span> <span class="keyword">throws</span> InvalidObjectException </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">&quot;Proxy required&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<blockquote>
<p>摘录来源：<a href="https://notes.piasy.com/Android-Java/EffectiveJava.html">https://notes.piasy.com/Android-Java/EffectiveJava.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android教程系列</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
</search>
